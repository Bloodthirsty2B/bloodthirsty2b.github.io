{"meta":{"title":"BS2B's blog","subtitle":"YES!It worked!","description":null,"author":"Bloodthirsty2B","url":"https://bloodthirsty2b.github.io","root":"/"},"pages":[{"title":"tags","date":"2018-10-01T00:59:57.000Z","updated":"2018-10-01T01:01:40.446Z","comments":false,"path":"tags/index.html","permalink":"https://bloodthirsty2b.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"给对象添加filter方法","slug":"js/给对象添加filter方法","date":"2025-02-04T10:41:55.000Z","updated":"2025-02-10T15:53:40.658Z","comments":true,"path":"2025/02/04/js/给对象添加filter方法/","link":"","permalink":"https://bloodthirsty2b.github.io/2025/02/04/js/%E7%BB%99%E5%AF%B9%E8%B1%A1%E6%B7%BB%E5%8A%A0filter%E6%96%B9%E6%B3%95/","excerpt":"给对象添加 filter 方法es6 中数组类型拥有 filter 方法，但有时我们会需要让对象类型也使用这个方法，例如有这么一个对象： 123const person = &#123; name: &quot;star&quot;,&#125; 那么是否可以在Object.prototype上增加 filter 方法用来给所有对象使用呢？ 123456789Object.prototype.filter = function (predicate) &#123; const result = &#123;&#125; for (key in this) &#123; if (this.hasOwnProperty(key) &amp;&amp; !predicate(this[key])) &#123; result[key] = this[key] &#125; &#125; return result&#125; 答案是不允许的，因为所有引用类型的原型链上都有Object.prototype，所以这会导致这些类型都被莫名奇妙地增加了这个方法。所以，在Object上新增方法更加合适，例如： 使用Object.keys和reduce实现","text":"给对象添加 filter 方法es6 中数组类型拥有 filter 方法，但有时我们会需要让对象类型也使用这个方法，例如有这么一个对象： 123const person = &#123; name: &quot;star&quot;,&#125; 那么是否可以在Object.prototype上增加 filter 方法用来给所有对象使用呢？ 123456789Object.prototype.filter = function (predicate) &#123; const result = &#123;&#125; for (key in this) &#123; if (this.hasOwnProperty(key) &amp;&amp; !predicate(this[key])) &#123; result[key] = this[key] &#125; &#125; return result&#125; 答案是不允许的，因为所有引用类型的原型链上都有Object.prototype，所以这会导致这些类型都被莫名奇妙地增加了这个方法。所以，在Object上新增方法更加合适，例如： 使用Object.keys和reduce实现 12345678Object.filter = (obj, predicate) =&gt; &#123; Ojbect.keys(obj) .filter((key) =&gt; predicate(obj[key])) .reduce((res, key) =&gt; &#123; res[key] = obj[key] return res &#125;, &#123;&#125;)&#125; 使用Ojbect.assign展开运算符和Object.map代替上面的reduce 12345Object.filter = (obj, predicate) =&gt; Object.assign( ...Ojbect.keys(obj) .filter(key =&gt; predicate(obj[key])) .map(key =&gt; &#123; [key]: obj[key] &#125;)) 使用Object.entries和Object.fromEntries 12Object.filter = (obj, predicate) =&gt; Object.fromEntries(Object.entries(obj).filter(keyValue =&gt; predicate(keyValue[1]))) 注意：Object.fromEntries属于ES2019，有兼容性问题。","categories":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/tags/js/"}]},{"title":"export default和import的解构赋值","slug":"js/export-default和import的解构赋值","date":"2024-12-25T11:37:08.000Z","updated":"2025-02-10T15:56:55.603Z","comments":true,"path":"2024/12/25/js/export-default和import的解构赋值/","link":"","permalink":"https://bloodthirsty2b.github.io/2024/12/25/js/export-default%E5%92%8Cimport%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/","excerpt":"babel版本对export default和import解构赋值的影响","text":"babel版本对export default和import解构赋值的影响 问题重现 通常情况对某对象解构赋值： 1234567const person = &#123; name: &#x27;clinz&#x27;, age: 80&#125;// 获取name属性：const &#123; name &#125; = person 拆分成模块： 12345// person.jsexport default person = &#123; name: &#x27;clinz&#x27;, age: 80&#125; 12345// 在app.js中获取person.jsimport person from &#x27;./person&#x27;const &#123; name &#125; = personconsole.log(name) // clinzconsole.log(person.name) // clinz 以上代码是没有问题的，下面在import中解构赋值： 123// 在app.js中获取person.jsimport &#123; name &#125; from &#x27;./person&#x27;console.log(name) // undefined 原因分析1import &#123; name &#125; from &#x27;./person&#x27; 这句代码语法上是没问题的，之前用antd-init创建的项目，在项目中使用下面的代码是没问题的。但是之后用vue-cli和create-react-app创建的项目中使用下面的代码都不能正确获取到name。搜索资料后发现是babel的版本对export default处理时造成的问题： ES6中的变量解构： 12const a = &#123; b: 1 &#125;const &#123; b &#125; = a 这里可以直接用解构赋值来获得对象的同名属性，等效于： 1const b = a.b ES6的模块导入也提供了相似的语法： 1import &#123; resolve &#125; from &#x27;path&#x27; 如果使用webpack构建项目的话，注意这里的解构与普通变量的解构是有所区别的，比如在a.js里有以下代码： 123export default &#123; b: 1&#125; 如果按照普通变量的解构法则来导入这个包，即这种形式： 1import &#123; b &#125; from &#x27;./a&#x27; 是会发生错误的，并不能导出变量b。主要因为这和webpack的构建有关。使用模块导入时，当用webpack构建后，以上的 1import &#123; b &#125; from &#x27;./a&#x27; 变为了类似 1a.default.b 可以看到变量b在a.default上，并不在a上，所以解构出来是undefined。如果要正确解构，则必须在模块内导出，即： 1export const b = 1 这样的话，构建后的代码中，变量b即在a上，而不是在a.default上，从而能正确解构。 所以 1234export default &#123; name: &#x27;clinz&#x27;, age: 80&#125; 变成了 1234module.exports.default = &#123; name: &#x27;clinz&#x27;, age: 80&#125; 所以取不到name的值是正常的。那为什么antd-init建立的项目可以获取到呢？ 解决方案根据资料的描述：import语句中的“解构赋值”并不是解构赋值，而是named imports，语法上和解构赋值很像，但还是有所差别，比如下面的例子。 1import &#123; name as fullname &#125; from &#x27;./person&#x27; // 解构赋值中不能用 as 12345678let obj = &#123; a: &#123; b: &#x27;hello&#x27;, &#125;&#125;let &#123;a: &#123;b&#125;&#125; = obj // import 语句中不能这样子写console.log(b) // =&gt; hello 这种写法本来是不正确的，但babel 6之前可以允许这样子的写法，babel 6之后就不能了。 1234567// a.jsimport &#123; name, age &#125; from &quot;./b&quot;// b.jsexport default &#123; name: &#x27;clinz&#x27;, age: 80&#125; 所以还是在import 语句中多加一行 12import b from &#x27;./b&#x27;let &#123; name, age &#125; = b 或者 12// a.jsimport &#123; name, age &#125; from &quot;./b&quot; 1234// b.jslet name = &#x27;clinz&#x27;let age = 80export &#123; name, age &#125; 或者 12345// a.jsimport &#123; name, age &#125; from &quot;./b&quot;// b.jsexport let name = &#x27;clinz&#x27;export let age = 80 而antd-init使用了babel-plugin-add-module-exports，所以 export default也没问题。","categories":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/tags/js/"}]},{"title":"blob开头的视频地址","slug":"html/blob开头的视频地址","date":"2024-12-18T11:02:07.000Z","updated":"2025-02-10T15:59:08.156Z","comments":true,"path":"2024/12/18/html/blob开头的视频地址/","link":"","permalink":"https://bloodthirsty2b.github.io/2024/12/18/html/blob%E5%BC%80%E5%A4%B4%E7%9A%84%E8%A7%86%E9%A2%91%E5%9C%B0%E5%9D%80/","excerpt":"自从h5提供了video标签后，只需要设置src属性便可以简单的播放视频。早期src直接指向真实视频地址，同时不会通过referrer等方式防盗链，只要获取了地址就可以随便下载视频。而现在视频网站使用了一些小手段： blob:https是什么东西？ 其实这是在js中给video标签的src属性设置了blob对象，浏览器内部进行处理后展示的src属性值。 它有很多好处，包括简单的防盗链、随时改变视频属性（清晰度）等。 一、怎么获取想要的视频？","text":"自从h5提供了video标签后，只需要设置src属性便可以简单的播放视频。早期src直接指向真实视频地址，同时不会通过referrer等方式防盗链，只要获取了地址就可以随便下载视频。而现在视频网站使用了一些小手段： blob:https是什么东西？ 其实这是在js中给video标签的src属性设置了blob对象，浏览器内部进行处理后展示的src属性值。 它有很多好处，包括简单的防盗链、随时改变视频属性（清晰度）等。 一、怎么获取想要的视频？ 目前blob视频基本都是通过先请求一个包含各个视频片段地址的文件，然后分别下载这些视频片段，再连续播放。这个包含视频片段地址的索引文件有mpd、m3u8等格式，代表MPEG DASH和HLS技术。所以一般方法如下： 先获取这个索引文件（）。 解析后分别进行请求获取m4s或ts视频片段（注意要将请求的responseType设置为arraybuffer），将其放在一个数组内。 通过new Blob(fileList, &#123; type: &#39;video/MP2T&#39; &#125;)方法整合为一个视频文件。 使用URL.createObjectUrl方法将二进制视频转化为blob链接。 使用a标签的download属性将其变成下载用的标签（目前只有chrome和firefox浏览器支持），调用click事件实现自动下载。 对于m3u8类型的索引文件，这里有一个便捷工具：m3u8下载器 二、怎么自己设置blob对象？ 首先要后台支持返回二进制视频 在发送请求的时候设置xhr.responseType = &#39;blob&#39; 请求成功后设置oVideo.src = &#39;URL.createObjectURL(res.videoFile)&#39; 12345678910var xhr = new XMLHttpRequest()xhr.open(&#x27;POST&#x27;, url, true)xhr.responseType = &#x27;blob&#x27;xhr.onload = function () &#123; if (xhr.status === 200) &#123; var res = xhr.response document.querySelector(&#x27;#videoTest&#x27;).src = URL.createObjectURL(res.videoFile) &#125;&#125;xhr.send()","categories":[{"name":"html","slug":"html","permalink":"https://bloodthirsty2b.github.io/categories/html/"}],"tags":[{"name":"html","slug":"html","permalink":"https://bloodthirsty2b.github.io/tags/html/"}]},{"title":"正则进阶","slug":"js/正则进阶","date":"2024-08-13T04:39:01.000Z","updated":"2024-12-20T16:02:42.711Z","comments":true,"path":"2024/08/13/js/正则进阶/","link":"","permalink":"https://bloodthirsty2b.github.io/2024/08/13/js/%E6%AD%A3%E5%88%99%E8%BF%9B%E9%98%B6/","excerpt":"正则进阶零宽断言先行断言 语法：/reg1(?=reg2)/ 含义：/(?=reg2)/本身在正则中不占位，它所在的位置的后面要有reg2 作用：匹配reg1，同时后面要有reg2 举例： 1/[a-z]*(?=t)/.exec(&#x27;got it&#x27;) // [&quot;go&quot;, index: 0, input: &quot;got it&quot;, groups: undefined]","text":"正则进阶零宽断言先行断言 语法：/reg1(?=reg2)/ 含义：/(?=reg2)/本身在正则中不占位，它所在的位置的后面要有reg2 作用：匹配reg1，同时后面要有reg2 举例： 1/[a-z]*(?=t)/.exec(&#x27;got it&#x27;) // [&quot;go&quot;, index: 0, input: &quot;got it&quot;, groups: undefined] 后发断言 语法：/(?&lt;=reg2)reg1/ 含义：/(?=reg2)/本身在正则中不占位，它所在的位置的前面要有reg2 作用：匹配reg1，同时前面要有reg2 举例： 1/(?&lt;=o)[a-z]&#123;5&#125;/.exec(&#x27;do youself&#x27;) // [&quot;uself&quot;, index: 5, input: &quot;do youself&quot;, groups: undefined] 负向零宽断言负向零宽先行断言 语法：/reg1(?!reg2)/ 含义：/(?!reg2)/本身在正则中不占位，它所在的位置的后面不能有reg2 作用：匹配reg1，同时后面不能有reg2 举例： 1/[a-z]*(?!a)/.exec(&#x27;ayiayaiya&#x27;) // [&quot;go&quot;, index: 0, input: &quot;got it&quot;, groups: undefined] 负向零宽后发断言 语法：/(?&lt;!reg2)reg1/ 含义：/(?&lt;!reg2)/本身在正则中不占位，它所在的位置的前面不能有reg2 作用：匹配reg1，同时前面不能有reg2 举例： 1/[a-z]*(?&lt;!ing)/.exec(&#x27;aing ain ai a&#x27;) // [&quot;ain&quot;, index: 0, input: &quot;aing ain ai a&quot;, groups: undefined]","categories":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/categories/js/"},{"name":"RegExp","slug":"js/RegExp","permalink":"https://bloodthirsty2b.github.io/categories/js/RegExp/"}],"tags":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/tags/js/"},{"name":"RegExp","slug":"RegExp","permalink":"https://bloodthirsty2b.github.io/tags/RegExp/"}]},{"title":"try catch finally","slug":"js/try-catch-finally","date":"2024-07-11T11:27:37.000Z","updated":"2021-12-20T15:42:29.252Z","comments":true,"path":"2024/07/11/js/try-catch-finally/","link":"","permalink":"https://bloodthirsty2b.github.io/2024/07/11/js/try-catch-finally/","excerpt":"try catch finally用法","text":"try catch finally用法 12345678910111213try &#123; try_statements&#125;[catch (exception_var_1 if condition_1) &#123; // non-standard catch_statements_1&#125;]...[catch (exception_var_2) &#123; catch_statements_2&#125;][finally &#123; finally_statements&#125;] try_statements &#x3D;&gt; 需要被执行的语句。 catch_statements_1, catch_statements_2 &#x3D;&gt; 如果在 try 块里有异常被抛出时执行的语句。 exception_var_1, exception_var_2 &#x3D;&gt; 用于保存关联 catch 子句的异常对象的标识符。 condition_1 &#x3D;&gt; 一个条件表达式。 finally_statements &#x3D;&gt; 在 try 语句块之后执行的语句块。无论是否有异常抛出或捕获这些语句都将执行。 说明try语句包含了由一个或者多个语句组成的try块, 和至少一个catch块或者一个finally块的其中一个，或者两个兼有， 下面是三种形式的try声明： try...catch try...finally try...catch...finally catch子句包含try块中抛出异常时要执行的语句。也就是，你想让try语句中的内容成功， 如果没成功，你想控制接下来发生的事情，这时你可以在catch语句中实现。 如果在try块中有任何一个语句（或者从try块中调用的函数）抛出异常，控制立即转向catch子句。如果在try块中没有异常抛出，会跳过catch子句。 finally子句在try块和catch块之后执行但是在下一个try声明之前执行。无论是否有异常抛出或捕获它总是执行。 可以嵌套一个或者更多的try语句。如果内部的try语句没有catch子句，那么将会进入包裹它的try语句的catch子句。 无条件 catch无条件catch块就是单个子句的try..catch抛出的异常都会被catch捕获，例如，当在下面的代码中发生异常时，控制转移到catch子句。 1234567try &#123; nonExistentFunction() // 不存在的函数&#125; catch (error) &#123; console.error(error) // 控制台打印: ReferenceError: nonExistentFunction is not defined // 被catch捕获错误。&#125; 打印出来的错误时可以自定义的。catch块指定一个标识符，该标识符保存由throw语句指定的值。catch块是唯一的，因为当输入catch块时，JavaScript 会创建此标识符，并将其添加到当前作用域；标识符仅在catch块执行时存在；catch块执行完成后，标识符不再可用。 123456789101112try &#123; throw &quot;自定义一些文字错误&quot;; // generates an exception&#125;catch (e) &#123; console.log(e); // 控制台打印：自定义一些文字错误&#125;try &#123; throw &#123;name: &#x27;张三&#x27;&#125;; // 自定义&#125;catch (e) &#123; console.log(e); // 打印: &#123;name: &#x27;张三&#x27;&#125;&#125; try块中的抛出一个异常时，exception_var（如catch (e)中的e）用来保存被抛出声明指定的值。你可以用这个标识符来获取关于被抛出异常的信息。 这个标识符是catch子语句内部的。换言之，当进入catch子语句时标识符创建，catch子语句执行完毕后，这个标识符将不再可用。 finallyfinally块包含的语句在try块和catch之后，try..catch..finally块后的语句之前执行。请注意，无论是否抛出异常finally子句都会执行。此外，如果抛出异常，即使没有catch子句处理异常，finally子句中的语句也会执行。 12345678openMyFile()try &#123; // tie up a resource writeMyFile(theData);&#125;finally &#123; closeMyFile(); // always close the resource&#125; 嵌套try例1： 123456789101112131415try &#123; try &#123; throw new Error(&quot;oops&quot;); // 抛出oops错误对象 &#125; finally &#123; console.log(&quot;finally&quot;); // 必须执行的 &#125;&#125;catch (ex) &#123; console.error(&quot;outer&quot;, ex.message);&#125;// 结果:// &quot;finally&quot;// &quot;outer&quot; &quot;oops&quot; 例2：如果已经在 try 语句中，通过增加一个 catch 语句块捕获了异常 123456789101112131415161718try &#123; try &#123; throw new Error(&quot;oops&quot;); // 抛出异常 &#125; catch (ex) &#123; console.error(&quot;inner&quot;, ex.message); // 被捕获到了 &#125; finally &#123; console.log(&quot;finally&quot;); // 怎么样都会执行 &#125;&#125;catch (ex) &#123; console.error(&quot;outer&quot;, ex.message); // 属于这个try catch 没有异常抛出&#125;// 结果:// &quot;inner&quot; &quot;oops&quot;// &quot;finally&quot; 例3：在新增的catch里不干正事继续抛错误 1234567891011121314151617181920try &#123; try &#123; throw new Error(&quot;oops&quot;); // 异常 &#125; catch (ex) &#123; console.error(&quot;inner&quot;, ex.message); // 捕获到异常 throw ex; // 不干正事的抛出异常 但是还是会先执行finally内的内容 &#125; finally &#123; console.log(&quot;finally&quot;); // try 和 catch 执行完就执行。不管别人 &#125;&#125;catch (ex) &#123; console.error(&quot;outer&quot;, ex.message); // 捕获到属于这个try -catch 的异常&#125;// 结果:// &quot;inner&quot; &quot;oops&quot;// &quot;finally&quot;// &quot;outer&quot; &quot;oops&quot; 例4： 1234567891011121314151617181920212223function setName () &#123; try &#123; try &#123; throw new Error(&quot;oops&quot;); &#125; catch (ex) &#123; console.error(&quot;inner&quot;, ex.message); throw ex; &#125; finally &#123; console.log(&quot;finally&quot;); return; &#125; &#125; catch (ex) &#123; console.error(&quot;outer&quot;, ex.message); &#125; // 注: 此 try catch 语句需要在 function 中运行才能作为函数的返回值, 否则直接运行会报语法错误 // 结果: // &quot;inner&quot; &quot;oops&quot; // &quot;finally&quot;&#125; 如果从finally块中返回一个值，那么这个值将会成为整个try-catch-finally的返回值，无论是否有return语句在try和catch中。这包括在catch块里抛出的异常。因为 finally 块里的 return 语句，&quot;oops&quot; 没有抛出到外层，从 catch 块返回的值同样适用。","categories":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/tags/js/"}]},{"title":"PureComponent缺点（其一）","slug":"React/PureComponent缺点（其一）","date":"2024-05-18T13:56:35.000Z","updated":"2021-12-20T15:41:24.251Z","comments":true,"path":"2024/05/18/React/PureComponent缺点（其一）/","link":"","permalink":"https://bloodthirsty2b.github.io/2024/05/18/React/PureComponent%E7%BC%BA%E7%82%B9%EF%BC%88%E5%85%B6%E4%B8%80%EF%BC%89/","excerpt":"PureComponent 中使用函数式 Props 导致的问题随着使用 PureComponent 的增多，原本在 Component 中能避免重复渲染的使用方法变得不再适用，例如：","text":"PureComponent 中使用函数式 Props 导致的问题随着使用 PureComponent 的增多，原本在 Component 中能避免重复渲染的使用方法变得不再适用，例如： 在 PureComponent 传递了函数式 Props 导致重复渲染问题问题描述采用 PureComponent 代替原先的 Component，可以避免根组件的重新渲染，以及带动所有子节点数的重新渲染。而对于 PureComponent 来说，机制是在原有的 Component 基础上，通过 shallowEqual 浅比较，也就是 shouldComponentUpdate 的判断，来避免在 props 和 state 不变的情况下，重复调用 render 函数而导致性能下降。通常情况下使用 PureComponent 代替 Component 是没问题的，内部只需要将浅层的 props 传递即可。但如果遇到函数式的 prop 传递（如下方所示），则每次传递的引用都会改变，shallowEqual 在判断的时候，就会判定为 false，导致前功尽弃。 1234// 父组件render () &#123; return &lt;ChildComponent onCallback=&#123;() =&gt; &#123; console.log(&#x27;do sth.&#x27;) &#125;&#125;&gt;&#125; 1234// 或者这种情况render () &#123; return &lt;ChildComponent onCallback=&#123;() =&gt; &#123; this.doSth.bind(this) &#125;&#125;&gt;&#125; 这两种情况可以通过在构造函数绑定 this，或者使用箭头函数提升作用域的方式解决： 1234567// 父组件onCallback = () =&gt;&#123; // do sth.&#125;render () &#123; return &lt;ChildComponent onCallback=&#123; this.onCallback &#125; /&gt;&#125; 或者 123456789constructor () &#123; this.onCallback = this.onCallback.bind(this);&#125;onCallback () &#123; // do sth.&#125;render () &#123; return &lt;ChildComponent onCallback=&#123; this.onCallback &#125; /&gt;&#125; 但是当出现如下这种情况：该 callback，需要在触发时候，依赖某些上层的数据来进行处理。如何不使用闭包函数进行处理？ 12345678doSomeThingWith (dependence) &#123; // use dependence to do sth.&#125;render () &#123; const someAnycMethods = (dependence) =&gt; &#123; return &lt;ChildComponent onCallback = &#123;()=&gt;&#123; this.doSthWith(dependence) &#125;&#125;/&gt; &#125;&#125; 解决方案通常情况下，我们可以自己维护 pureComponent，避免上面那两种情况，但是其他的同事可能未必知道你的规则。他们可能不小心传递了一个闭包箭头函数或者使用 bind，破坏了这个 pureComponent。考虑到项目中几乎没有传递函数不同会影响子组件内 dom 渲染的情况，比如 renderProps 这种设计模式就不适用。那如果我们假设传递回调函数的不同，对渲染的结果不造成影响，我们是否可以将函数类型的 props 忽略不计呢？ shallowEqual 源码： 12345678910111213141516171819202122232425262728293031323334353637383940function is(x, y) &#123; if (x === y) &#123; return x !== 0 || y !== 0 || 1 / x === 1 / y &#125; else &#123; return x !== x &amp;&amp; y !== y &#125;&#125;const shallowEqual = (objA, objB) =&gt; &#123; if (is(objA, objB)) &#123; return true &#125; if ( typeof objA !== &quot;object&quot; || objA === null || typeof objB !== &quot;object&quot; || objB === null ) &#123; return false &#125; const keysA = Object.keys(objA) const keysB = Object.keys(objB) if (keysA.length !== keysB.length) &#123; return false &#125; for (let i = 0; i &lt; keysA.length; i++) &#123; if ( !hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]]) ) &#123; return false &#125; &#125; return true&#125;export default shallowEqual 这里我的做法是，修改 shouldCompoentUpdate 中依赖的 shallowEqual 判断逻辑，添加函数式 props 例外： 123456789function is(x, y) &#123; if (x === y) &#123; return x !== 0 || y !== 0 || 1 / x === 1 / y &#125; else &#123; //--添加函数式props例外 if (typeof x === &quot;function&quot; &amp;&amp; typeof y === &quot;function&quot;) return true return x !== x &amp;&amp; y !== y &#125;&#125; 最后包装一个 UnsafePureComponent 如下 12345678910import &#123; Component &#125; from &quot;react&quot;import shallowEqual from &quot;../util/shallow-equal-pached&quot;export default class UnsafePureComponent extends Component &#123; shouldComponentUpdate(nextProps, nextState) &#123; return ( !shallowEqual(this.props, nextProps) || !shallowEqual(this.state, nextState) ) &#125;&#125; 当使用 reactHooks 的时候当我们使用 react Hooks 的时候，我们完全可以通过使用 useCallback 这一 hooks 来保持回调函数引用不变。这样我们可以在传递到子组件的时候 shouldComponentUpadate 在判断引用的时候就不变了。 123456const [count, setCount] = useState(1)const [val, setVal] = useState(1)const callBack = useCallback(() =&gt; &#123; return count&#125;, [count]) 上面代码中我们 hook 了 2 个 state，并且 hook 了一个 useCallback，useCallback 的依赖项数值只有 count 而没有 val，那么只有当 count 变化后 callBack 就会是一个新的方法，否则和之前的引用一直。 当我们调用 setVal 后，假设之前的 callBack 为 c1，setVal 后的 callBack 为 c2，那么 c1 &#x3D;&#x3D;&#x3D; c2，将返回 true，而如果我们调用了 setCount，那么 c1 &#x3D;&#x3D;&#x3D; c2 将会返回 false，正如官网文档中所说：把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 shouldComponentUpdate）的子组件时，它将非常有用。","categories":[{"name":"React","slug":"React","permalink":"https://bloodthirsty2b.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://bloodthirsty2b.github.io/tags/React/"}]},{"title":"父子组件生命周期执行顺序","slug":"React/父子组件生命周期执行顺序","date":"2024-03-27T09:04:15.000Z","updated":"2021-12-20T15:42:02.861Z","comments":true,"path":"2024/03/27/React/父子组件生命周期执行顺序/","link":"","permalink":"https://bloodthirsty2b.github.io/2024/03/27/React/%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/","excerpt":"React父子组件生命周期执行顺序 首次加载：parent-constructor &#x3D;&gt; parent-getDerivedStateFromProps &#x3D;&gt; parent-render &#x3D;&gt; child-constructor &#x3D;&gt; child-getDerivedStateFromProps &#x3D;&gt; child-render &#x3D;&gt; child-componentDidMount &#x3D;&gt; parent-componentDidMount 更新组件：parent-getDerivedStateFromProps &#x3D;&gt; parent-shouldComponentUpdate &#x3D;&gt; parent-render &#x3D;&gt; child-getDerivedStateFromProps &#x3D;&gt; child-shouldComponentUpdate &#x3D;&gt; child-render &#x3D;&gt; child-componentDidUpdate &#x3D;&gt; parent-componentDidUpdate 销毁组件：parent-componentWillUnmount &#x3D;&gt; child-componentWillUnmount 生命周期详情：","text":"React父子组件生命周期执行顺序 首次加载：parent-constructor &#x3D;&gt; parent-getDerivedStateFromProps &#x3D;&gt; parent-render &#x3D;&gt; child-constructor &#x3D;&gt; child-getDerivedStateFromProps &#x3D;&gt; child-render &#x3D;&gt; child-componentDidMount &#x3D;&gt; parent-componentDidMount 更新组件：parent-getDerivedStateFromProps &#x3D;&gt; parent-shouldComponentUpdate &#x3D;&gt; parent-render &#x3D;&gt; child-getDerivedStateFromProps &#x3D;&gt; child-shouldComponentUpdate &#x3D;&gt; child-render &#x3D;&gt; child-componentDidUpdate &#x3D;&gt; parent-componentDidUpdate 销毁组件：parent-componentWillUnmount &#x3D;&gt; child-componentWillUnmount 生命周期详情： 挂载：constructor()、static getDerivedStateFromProps()、render()、componentDidMount() 更新：static getDerivedStateFromProps()、shouldComponentUpdate()、render()、getSnapshotBeforeUpdate()、componentDidUpdate() 错误处理：static getDerivedStateFromError()、componentDidCatch() 卸载：componentWillUnmount() 各个函数用途： constructor()：组件构造函数，在组件挂载之前调用；仅用于初始化内部state以及为事件处理函数绑定实例； static getDerivedStateFromProps()：会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用，此方法适用于state 的值在任何时候都取决于 props； render()：是 class 组件中唯一必须实现的方法； componentDidMount()：会在组件挂载后（插入 DOM 树中）立即调用； shouldComponentUpdate()：根据该函数的返回值，来确定组件是否重新渲染； getSnapshotBeforeUpdate()：在最近一次渲染输出（提交到 DOM 节点）之前调用；此生命周期方法的任何返回值将作为参数传递给 componentDidUpdate()； componentDidUpdate()：会在更新后会被立即调用，首次渲染不会执行此方法； componentWillUnmount()：会在组件卸载及销毁之前直接调用； static getDerivedStateFromError()：此生命周期会在后代组件抛出错误后被调用。 它将抛出的错误作为参数，并返回一个值以更新 state；它会在渲染阶段调用，因此不允许出现副作用 componentDidCatch()：此生命周期在后代组件抛出错误后被调用，会在“提交”阶段被调用，因此允许执行副作用。","categories":[{"name":"React","slug":"React","permalink":"https://bloodthirsty2b.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://bloodthirsty2b.github.io/tags/React/"}]},{"title":"使用useRef跨渲染周期保存数据","slug":"React/使用useRef跨渲染周期保存数据","date":"2023-12-22T10:19:15.000Z","updated":"2021-12-20T15:41:00.543Z","comments":true,"path":"2023/12/22/React/使用useRef跨渲染周期保存数据/","link":"","permalink":"https://bloodthirsty2b.github.io/2023/12/22/React/%E4%BD%BF%E7%94%A8useRef%E8%B7%A8%E6%B8%B2%E6%9F%93%E5%91%A8%E6%9C%9F%E4%BF%9D%E5%AD%98%E6%95%B0%E6%8D%AE/","excerpt":"useRef 可以用来获取组件实例对象或者是 DOM 对象，而它还有跨渲染周期保存数据的作用。","text":"useRef 可以用来获取组件实例对象或者是 DOM 对象，而它还有跨渲染周期保存数据的作用。 通常用法：123456789101112131415161718192021import React, &#123; useState, useEffect, useMemo, useRef &#125; from &#x27;react&#x27;;export default functionApp (props) &#123; const [count, setCount] = useState(0); const doubleCount = useMemo(() =&gt; &#123; return 2* count; &#125;, [count]); const couterRef = useRef(); useEffect(() =&gt; &#123; document.title = `The value is $&#123;count&#125;` ; console.log(couterRef.current); &#125;, [count]); return ( &lt;&gt; &lt;button ref=&#123;couterRef&#125; onClick=&#123;() =&gt; &#123;setCount(count + 1)&#125;&#125;&gt;Count: &#123;count&#125;, double: &#123;doubleCount&#125;&lt;/button&gt; &lt;/&gt; );&#125; 代码中用useRef创建了couterRef对象，并将其赋给了button的ref属性。这样，通过访问couterRef.current就可以访问到button对应的DOM对象。 使用useRef保存数据在一个组件中有什么东西可以跨渲染周期，也就是在组件被多次渲染之后依旧不变的属性？没错，是state。一个组件的 state 可以在多次渲染之后依旧不变。但是，state的问题在于一旦修改了它就会造成组件的重新渲染。那么这个时候就可以使用 useRef 来跨越渲染周期存储数据，而且对它修改也不会引起组件渲染。 1234567891011121314151617181920212223242526272829importReact, &#123; useState, useEffect, useMemo, useRef &#125; from&#x27;react&#x27;;export default functionApp (props) &#123; const [count, setCount] = useState(0); const doubleCount = useMemo(() =&gt; &#123; return 2* count; &#125;, [count]); const timerID = useRef(); useEffect(() =&gt; &#123; timerID.current = setInterval(() =&gt; &#123; setCount(count =&gt; count + 1); &#125;, 1000); &#125;, []); useEffect(() =&gt; &#123; if(count &gt; 10)&#123; clearInterval(timerID.current); &#125; &#125;); return ( &lt;&gt; &lt;button ref= &#123;couterRef&#125; onClick=&#123;() =&gt; &#123;setCount(count + 1)&#125;&#125;&gt;Count: &#123;count&#125;, double: &#123;doubleCount&#125;&lt;/button&gt; &lt;/&gt; );&#125; 在上面的例子中，使用了ref对象的current属性来存储定时器的ID，这样便可以在多次渲染之后依旧保存定时器ID，从而能正常清除定时器。","categories":[{"name":"React","slug":"React","permalink":"https://bloodthirsty2b.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://bloodthirsty2b.github.io/tags/React/"}]},{"title":"additional chunk assetsFATAL ERROR","slug":"webpack/additional-chunk-assetsFATAL-ERROR","date":"2023-07-15T12:45:26.000Z","updated":"2021-12-20T15:49:01.537Z","comments":true,"path":"2023/07/15/webpack/additional-chunk-assetsFATAL-ERROR/","link":"","permalink":"https://bloodthirsty2b.github.io/2023/07/15/webpack/additional-chunk-assetsFATAL-ERROR/","excerpt":"webpack 打包时内存溢出报错信息：chunk assetsFATAL ERROR: Ineffective mark-compacts near heap limit Allocation failed - JavaScript heap out of memory","text":"webpack 打包时内存溢出报错信息：chunk assetsFATAL ERROR: Ineffective mark-compacts near heap limit Allocation failed - JavaScript heap out of memory 翻译过来就是JavaScript堆内存不足，而这里的 JavaScript 其实就是 Node。在其他的后端开发语言中，在内存的使用上没有什么限制。而Node不同，查了资料后发现：由于Node是基于 V8 引擎，在Node中通过JavaScript使用内存时只能使用部分内存（64 位系统下约为 1.4 GB，32 位系统下约为 0.7 GB），这就是编译项目时为什么会出现内存泄露了。项目如果非常的庞大，webpack编译时就会占用很多的系统资源，如果超出了 V8 对Node默认的内存限制大小就会出现刚刚内存溢出的错误。事实上 V8 依然提供了选项来允许使用更多的内存。Node在启动时可以传递--max-old-space-size或--max-new-space-size来调整内存大小的使用限制。如果遇到Node无法分配足够内存给JavaScript的情况，可以用这个办法来放宽 V8 默认的内存限制，避免在执行过程中稍微多用了一些内存就出现崩溃的情况。 有两种解决方案： 打开 node_modules.bin\\webpack-dev-server.cmd 文件，添加--max_old_space_size=32768 1234567@IF EXIST &quot;%~dp0\\node.exe&quot; ( &quot;%~dp0\\node.exe&quot; &quot;--max_old_space_size=4096&quot; &quot;%~dp0\\..\\webpack-dev-server\\bin\\webpack-dev-server.js&quot; %*) ELSE ( @SETLOCAL @SET PATHEXT=%PATHEXT:;.JS;=;% node &quot;--max_old_space_size=4096&quot; &quot;%~dp0\\..\\webpack-dev-server\\bin\\webpack-dev-server.js&quot; %*) 在 package.json 中给 build 命令增加参数（修改后需要 npm i）： 123&quot;scripts&quot;: &#123; &quot;build&quot;: &quot;node --max_old_space_size=32768 build/build.js&quot;&#125;","categories":[{"name":"webpack","slug":"webpack","permalink":"https://bloodthirsty2b.github.io/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://bloodthirsty2b.github.io/tags/webpack/"}]},{"title":"JavaScript风格指南","slug":"js/用更合理的方式写JavaScript","date":"2023-05-10T09:12:53.000Z","updated":"2021-12-20T15:42:44.722Z","comments":true,"path":"2023/05/10/js/用更合理的方式写JavaScript/","link":"","permalink":"https://bloodthirsty2b.github.io/2023/05/10/js/%E7%94%A8%E6%9B%B4%E5%90%88%E7%90%86%E7%9A%84%E6%96%B9%E5%BC%8F%E5%86%99JavaScript/","excerpt":"","text":"github","categories":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/tags/js/"}]},{"title":"antd中this.formRef.current为空的问题","slug":"React/antd中this-formRef-current为空的问题","date":"2023-03-22T11:46:36.000Z","updated":"2021-12-20T15:41:43.014Z","comments":true,"path":"2023/03/22/React/antd中this-formRef-current为空的问题/","link":"","permalink":"https://bloodthirsty2b.github.io/2023/03/22/React/antd%E4%B8%ADthis-formRef-current%E4%B8%BA%E7%A9%BA%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"react+antd的开发过程中经常会用到Modal+Form的组合来实现新增、编辑的功能。使用过程中常会遇到this.formRef.current为空的问题。","text":"react+antd的开发过程中经常会用到Modal+Form的组合来实现新增、编辑的功能。使用过程中常会遇到this.formRef.current为空的问题。 查阅资料后了解到这是由于Modal组件在visible为false时，内部组件不会渲染导致的。例如： 12345678910111213141516171819202122232425262728class Test extends Component&#123; constructor(props) &#123; super(props); this.formRef = React.createRef() this.state = &#123; show: false&#125; console.log(&#x27;Test.constructor&#x27;) &#125; render() &#123; return ( &lt;Modal visible=&#123;this.state.show&#125;&gt; &lt;Home/&gt; &lt;Form ref=&#123;this.formRef&#125;&gt; &lt;/Form&gt; &lt;/Modal&gt;) &#125;&#125;class Home extends Component&#123; constructor(props) &#123; super(props); console.log(&#x27;Home.constructor&#x27;) &#125; render() &#123; return ( &lt;div&gt;hello world!&lt;/div&gt;) &#125; &#125;&#125; 该代码首次渲染时只会打印Test.constructor，意味着Home组件没有被渲染出来。而展示Modal组件后，就会打印Home.constructor。所以在Modal组件不可见时，是获取不到this.formRef.current的。进而导致很多时候需要在componentWillReceiveProps中对 Form 表单进行操作，例如重置表单默认数据时，因为this.formRef.current还没有被初始化而导致异常。 解决方案在setState()的回调函数中去操作。setState 的回调函数是在 render 完成后调用的，所以这时this.formRef.current肯定是有内容的。 12345678910componentWillReceiveProps(nextProps) &#123; this.setState(&#123; show: nextProps.show, value: nextProps.value &#125;, () =&gt; &#123; if(this.formRef.current) &#123; this.formRef.current.resetFields(); &#125; &#125;)&#125;","categories":[{"name":"React","slug":"React","permalink":"https://bloodthirsty2b.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://bloodthirsty2b.github.io/tags/React/"}]},{"title":"react的css局部作用域","slug":"React/react的css局部作用域","date":"2023-02-20T12:00:44.000Z","updated":"2021-12-20T15:41:53.915Z","comments":true,"path":"2023/02/20/React/react的css局部作用域/","link":"","permalink":"https://bloodthirsty2b.github.io/2023/02/20/React/react%E7%9A%84css%E5%B1%80%E9%83%A8%E4%BD%9C%E7%94%A8%E5%9F%9F/","excerpt":"vue中防止样式污染可以在style中设置scoped来处理，而react中没有直接对应的功能。查阅资料后得知，webpack中包含了CSS modules这个工具来解决该问题。","text":"vue中防止样式污染可以在style中设置scoped来处理，而react中没有直接对应的功能。查阅资料后得知，webpack中包含了CSS modules这个工具来解决该问题。 CSS modules是默认开启的，所以只需要将原先的.less或.css文件名称改为.module.less和.module.css即可。 1234// index.module.less.header&#123; padding: 10px 0;&#125; 12// jsx中引入import styles from &#x27;./index.module.less&#x27; 使用样式： 1&lt;header className=&#123;styles.header&#125;&gt;header&lt;/header&gt; 此时该类名会变为类名--hash值的形式，以产生css局部作用域的效果。","categories":[{"name":"React","slug":"React","permalink":"https://bloodthirsty2b.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://bloodthirsty2b.github.io/tags/React/"}]},{"title":"canvas2d像素操作","slug":"canvas/canvas2d像素操作","date":"2023-01-01T11:01:41.000Z","updated":"2021-12-20T15:55:16.761Z","comments":true,"path":"2023/01/01/canvas/canvas2d像素操作/","link":"","permalink":"https://bloodthirsty2b.github.io/2023/01/01/canvas/canvas2d%E5%83%8F%E7%B4%A0%E6%93%8D%E4%BD%9C/","excerpt":"canvas支持直接获取和修改画布中每一个像素点的信息，这些信息全部被存放在ImageData对象中。 一、ImageData对象ImageData对象中存储着canvas对象真实的像素数据，它包含以下几个只读属性： width：图片宽度，单位是像素。 height：图片高度，单位是像素。 data：图片所有像素点信息，是一个一维数组，元素类型是Uint8ClampedArray。储存像素信息的方式是自图片的左上角开始，从左往右、由上自下依次存入每个像素点的RGBA四个值。这个数组包含高度 × 宽度 × 4 bytes数据，索引值从0到(高度×宽度×4)-1。","text":"canvas支持直接获取和修改画布中每一个像素点的信息，这些信息全部被存放在ImageData对象中。 一、ImageData对象ImageData对象中存储着canvas对象真实的像素数据，它包含以下几个只读属性： width：图片宽度，单位是像素。 height：图片高度，单位是像素。 data：图片所有像素点信息，是一个一维数组，元素类型是Uint8ClampedArray。储存像素信息的方式是自图片的左上角开始，从左往右、由上自下依次存入每个像素点的RGBA四个值。这个数组包含高度 × 宽度 × 4 bytes数据，索引值从0到(高度×宽度×4)-1。 二、新建ImageData对象可以使用ctx.createImageData方法来新建一个所有像素都为rgba(0, 0, 0, 0)的ImageData对象： 1234// 新建具体尺寸的ImageData对象const ImageData = ctx.createImageData(width, height)// 新建一个被anotherImageData对象指定的相同像素的ImageData对象，并非复制图片数据const ImageData2 = ctx.createImageData(anotherImageData) 三、获取图片像素数据通过ctx.getImageData方法来获取图片的数据： 12// 获取一个以(x, y)为左上角，宽高分别为width和height的矩形的像素数据，如果范围超出了canvas，将会得到rgba(0, 0, 0, 0)const ImageData = ctx.getImageData(x, y, width, height) 四、写入图片像素数据可以用putImageData方法去对场景进行像素数据的写入 12// 以(x, y)为左上角在canvas上绘制newImageDatactx.putImageData(newImageData, x, y) 五、保存图片canvas对象提供了toDataURL方法来保存当前图片，分辨率是96dpi： canvas.toDataURL(&#39;image/png&#39;, quality)：可以创建一个png格式的图片，quality代表图片质量，取值从0到1，1最好。 canvas.toBlob(callback, type, encoderOptions)：通过canvas创建一个blob对象。 以上两种方法创建的对象都可以用于任何img标签，也可以通过具有download属性的元素来下载（例如在chrome中给a标签设置download属性，这样在点击时就不会跳转页面而是直接下载）。","categories":[{"name":"canvas","slug":"canvas","permalink":"https://bloodthirsty2b.github.io/categories/canvas/"}],"tags":[{"name":"canvas","slug":"canvas","permalink":"https://bloodthirsty2b.github.io/tags/canvas/"}]},{"title":"canvas2d动画、优化","slug":"canvas/canvas2d动画、优化","date":"2022-12-20T11:56:43.000Z","updated":"2021-12-20T15:55:01.384Z","comments":true,"path":"2022/12/20/canvas/canvas2d动画、优化/","link":"","permalink":"https://bloodthirsty2b.github.io/2022/12/20/canvas/canvas2d%E5%8A%A8%E7%94%BB%E3%80%81%E4%BC%98%E5%8C%96/","excerpt":"一、动画动画通过每帧放出不同的画面来实现，而每帧的需要的操作如下： 清空上一帧绘制的内容。 如果需要保存当前canvas状态（笔刷样式、变形）的话就将其保存一下。 绘制这一帧需要画的内容。 如果之后需要恢复之前保存的状态的话就恢复一下。 由于动画需要按时切换显示的内容，所以会使用到和时间相关的函数： setInterval(callback, delay) setTimeout(callback, delay) requestAnimationFrame(callback) 由于setTimeout和setInterval有可能被其他语句耽误，通常使用requestAnimationFrame方法。 本博客banner的动画也是使用这个方法制作的，大致步骤如下：","text":"一、动画动画通过每帧放出不同的画面来实现，而每帧的需要的操作如下： 清空上一帧绘制的内容。 如果需要保存当前canvas状态（笔刷样式、变形）的话就将其保存一下。 绘制这一帧需要画的内容。 如果之后需要恢复之前保存的状态的话就恢复一下。 由于动画需要按时切换显示的内容，所以会使用到和时间相关的函数： setInterval(callback, delay) setTimeout(callback, delay) requestAnimationFrame(callback) 由于setTimeout和setInterval有可能被其他语句耽误，通常使用requestAnimationFrame方法。 本博客banner的动画也是使用这个方法制作的，大致步骤如下： 123456789101112131415let length // 精灵图长度let ctx // canvas.getContext(&#x27;2d&#x27;)ctx.renderIndex = 0let img // 精灵图function render () &#123; while (ctx.renderIndex &lt; length) &#123; // 清空上一帧内容 ctx.clearRect(0, 0, canvas.width, canvas.height) // 精灵图内在竖直方向存放了帧动画，通过修改drawImage的绘图位置便可以简单绘制该帧 ctx.drawImage(img, 0, ctx.renderIndex * canvas.height) ctx.renderIndex = ctx.renderIndex &lt; length ? ctx.renderIndex + 1 : 0 &#125; requestAnimationFrame(render)&#125;requestAnimationFrame(render) 商业中会使用Adobe Animate或Spine来绘制并导出canvas格式的动画，然后只要导入到页面中即可展示动画。 二、优化 双缓冲 在游戏内会经常使用双缓冲来提高性能，简单地说就是预先在另外一个离屏的canvas上绘制好大量复杂内容，然后在需要的时候直接把离屏canvas渲染到当前canvas中。 123456789let canvas // 当前canvasctx = canvas.getContext(&#x27;2d&#x27;)let _canvas // 离屏canvas_canvas = document.createElement(&#x27;canvas&#x27;)_canvas.width = canvas.width_canvas.height = canvas.heightconst _ctx = _canvas.getContext(&#x27;2d&#x27;)ctx.drawImage(_canvas, x, y, w, h) 避免浮点数坐标 12// 当画一个没有整数坐标点的对象时会发生子像素渲染，浏览器为了达到抗锯齿的效果会做额外的运算。使用前请对坐标取整。ctx.drawImage(myImage, 0.3, 0.5) 在离屏canvas中缓存图片的不同尺寸，而不要用drawImage()去缩放。 对于具有不相关动画效果的内容，用多个canvas来展示： 比如很多游戏的角色游戏层、背景图、UI这三个内容分别有完全无关的动画效果，这时候可以配置三个canvas，只在这个图层需要的时候重绘。对于静态背景，甚至可以直接使用img标签或background代替。 用CSS的transform缩放画布： transform使用GPU，因此速度更快。 最好的情况是不直接缩放画布，或者具有较小的画布并按比例放大，而不是较大的画布并按比例缩小。 关闭透明度： 如果不需要背景透明的画布，那么当使用 canvas.getContext时把 alpha 选项设置为 false 。这个选项可以帮助浏览器进行内部优化。 1const ctx = canvas.getContext(&#x27;2d&#x27;, &#123; alpha: false &#125;) 其他： 将画布的函数调用集合到一起（例如，画一条折线，而不要画多条分开的直线）。 避免不必要的画布状态改变。 渲染画布中的不同点，而非整个新状态。 尽可能避免 shadowBlur特性。 尽可能避免text rendering。 尝试不同的方法来清除画布(clearRect() vs. fillRect() vs. 调整canvas大小)。 动画请使用window.requestAnimationFrame() 而非window.setInterval()。 谨慎使用大型物理库。","categories":[{"name":"canvas","slug":"canvas","permalink":"https://bloodthirsty2b.github.io/categories/canvas/"}],"tags":[{"name":"canvas","slug":"canvas","permalink":"https://bloodthirsty2b.github.io/tags/canvas/"}]},{"title":"canvas2d状态保存&恢复、变形、合成、裁剪","slug":"canvas/canvas2d变形、合成、裁剪","date":"2022-12-12T10:43:13.000Z","updated":"2021-12-20T15:54:48.664Z","comments":true,"path":"2022/12/12/canvas/canvas2d变形、合成、裁剪/","link":"","permalink":"https://bloodthirsty2b.github.io/2022/12/12/canvas/canvas2d%E5%8F%98%E5%BD%A2%E3%80%81%E5%90%88%E6%88%90%E3%80%81%E8%A3%81%E5%89%AA/","excerpt":"一、状态保存&amp;恢复在对画布进行变形前，最好使用save将初始状态保存起来。把画布和坐标回到初始状态有利于之后的绘制。 ctx.save()将canvas的所有状态保存在栈中，包括 当前应用的变形 这些属性：strokeStyle, fillStyle, globalAlpha, lineWidth, lineCap, lineJoin, miterLimit, lineDashOffset, shadowOffsetX, shadowOffsetY, shadowBlur, shadowColor, globalCompositeOperation, font, textAlign, textBaseline, direction, imageSmoothingEnabled 当前的裁切路径 ctx.restore()将最后保存的状态弹出","text":"一、状态保存&amp;恢复在对画布进行变形前，最好使用save将初始状态保存起来。把画布和坐标回到初始状态有利于之后的绘制。 ctx.save()将canvas的所有状态保存在栈中，包括 当前应用的变形 这些属性：strokeStyle, fillStyle, globalAlpha, lineWidth, lineCap, lineJoin, miterLimit, lineDashOffset, shadowOffsetX, shadowOffsetY, shadowBlur, shadowColor, globalCompositeOperation, font, textAlign, textBaseline, direction, imageSmoothingEnabled 当前的裁切路径 ctx.restore()将最后保存的状态弹出 二、移动ctx.translate(a, b)：将canvas画布和原点向x轴方向移动a距离，向y轴方向移动b距离。 这个方法很适合在使用前将初始状态保存起来，使用restore总比进行逆向移动要方便。 三、旋转ctx.rotate(angle)：将canvas画布以原点为中心顺时针方向旋转angle度(弧度制)。 四、缩放ctx.scale(a, b)：将canvas画布以原点为中心向x轴方向缩放a倍，y轴方向缩放b倍。a和b为负数的时候则是将画布以原点为中心向x轴方向、y轴方向翻转。 五、变形 transform(a, b, c, d, e, f) 这个方法是将当前的变形矩阵乘上一个基于自身参数的矩阵，如下面的矩阵所示：\\left[ \\begin{array}{ccc} a &amp; c &amp; e \\ b &amp; d &amp; f \\ 0 &amp; 0 &amp; 1 \\end{array} \\right] 如果任意一个参数是Infinity，变形矩阵也必须被标记为无限大，否则会抛出异常。 这个函数的参数各自代表如下： a (m11)：水平方向的缩放 b(m12)：竖直方向的倾斜偏移 c(m21)：水平方向的倾斜偏移 d(m22)：竖直方向的缩放 e(dx)：水平方向的移动 f(dy)：竖直方向的移动 setTransform(a, b, c, d, e, f) 这个方法会将当前的变形矩阵重置为单位矩阵，然后用相同的参数调用 transform 方法。如果任意一个参数是无限大，那么变形矩阵也必须被标记为无限大，否则会抛出异常。从根本上来说，该方法是取消了当前变形,然后设置为指定的变形,一步完成。 resetTransform() 重置当前变形为单位矩阵，它和调用ctx.setTransform(1, 0, 0, 1, 0, 0)是一样的 六、组合globalCompositeOperation默认状态下新绘制的图像会覆盖旧图像，由于canvas没有图层概念，所以提供了globalCompositeOperation = type这个属性来代替。共有以下值（在photoshop中测试了一下，破折号后面是PS cs6的叫法。顺便吐槽MDN里后面的基本都是机翻&amp;yy…）： source-over：默认设置，在现有画布之上覆盖新图形。 source-in：将旧图形作为新图形的遮罩层。 source-out：将旧图形透明度取反，作为新图形的遮罩层。 source-atop：锁定旧图形不透明度。 destination-over：旧图形会覆盖在新图形上。 destination-in：将新图形作为旧图形的遮罩层。 destination-out：将新图形透明度取反，作为旧图形的遮罩层。 destination-atop：锁定新图形不透明度，将旧图形绘制在上面。 lighter：两个重叠图形的颜色是通过颜色值相加来确定的。——浅色 copy：删除旧图形，绘制新图形。 xor：异或运算。图像中，那些重叠和正常绘制之外的其他地方是透明的。 multiply：将顶层像素与底层相应像素相乘，结果是一幅更黑暗的图片。——正片叠底 screen：像素被倒转，相乘，再倒转，结果是一幅更明亮的图片。——滤色 overlay：multiply和screen的结合，原本暗的地方更暗，原本亮的地方更亮。——叠加 darken：保留两个图层中最暗的像素。——变暗 lighten：保留两个图层中最亮的像素。——变亮 color-dodge：将底层除以顶层的反置。——颜色减淡 color-burn：将反置的底层除以顶层，然后将结果反过来。——颜色加深 hard-light：屏幕相乘，类似于叠加，但上下图层互换了。——强光 soft-light：用顶层减去底层或者相反来得到一个正值。——柔光 difference：根据上下两边颜色的亮度分布，对上下像素的颜色值进行相减处理。——差异模式，差值 exclusion：和difference相似，但对比度较低。——排除 hue：决定生成颜色的参数包括：底层颜色的明度与饱和度，上层颜色的色调。——色调模式，色相 saturation：决定生成颜色的参数包括：底层颜色的明度与色调，上层颜色的饱和度。按这种模式与饱和度为0的颜色混合（灰色）不产生任何变化。——饱和度 color：决定生成颜色的参数包括：底层颜色的明度，上层颜色的色调与饱和度。这种模式能保留原有图像的灰度细节。这种模式能用来对黑白或者是不饱和的图像上色。——颜色 luminosity：决定生成颜色的参数包括：底层颜色的色调与饱和度，上层颜色的明度。该模式产生的效果与Color模式刚好相反，它根据上层颜色的明度分布来与下层颜色混合。——明度 七、裁切路径裁切路径和普通的 canvas 图形差不多，不同的是它的作用是遮罩，用来隐藏不需要的部分。它可以实现与 source-in 和 source-atop差不多的效果。最重要的区别是裁切路径不会在 canvas 上绘制东西，而且它永远不受新图形的影响。这些特性使得它在特定区域里绘制图形时相当好用。 clip()：将当前正在构建的路径转换为裁剪路径。 使用 clip()方法可以创建一个新的裁切路径。默认情况下，canvas 有一个与它自身一样大的裁切路径（也就是没有裁切效果）。","categories":[{"name":"canvas","slug":"canvas","permalink":"https://bloodthirsty2b.github.io/categories/canvas/"}],"tags":[{"name":"canvas","slug":"canvas","permalink":"https://bloodthirsty2b.github.io/tags/canvas/"}]},{"title":"canvas2d系统和基本绘制","slug":"canvas/canvas2d基本使用","date":"2022-12-11T11:50:51.000Z","updated":"2021-12-20T15:55:09.667Z","comments":true,"path":"2022/12/11/canvas/canvas2d基本使用/","link":"","permalink":"https://bloodthirsty2b.github.io/2022/12/11/canvas/canvas2d%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","excerpt":"简单地说：初始状态的canvas是一张透明的画布，我们能用不同方法在canvas上画图。 1&lt;canvas width=&quot;1440&quot; height=&quot;720&quot;&gt;&lt;/canvas&gt; canvas标签的特性只有宽和高可以设置。css中也可以改变它的宽高，但是默认保持原始宽高比。如果在css中强行同时设置宽高的话canvas标签和里面的画面会被拉伸，所以建议使用特性设置宽高。另外，虽然绘制过程中可以作出矢量图，但在浏览器渲染结束以后得到的是位图，这时通过样式放大的图将不会再具有矢量图的特性，马赛克严重。 兼容性：目前canvas基本得到了所有较新版本主流浏览器的支持，详见Can I Use Canvas? ，如果遇到了不兼容的浏览器的话，这里也有解决方案： 1234&lt;canvas width=&quot;1440&quot; height=&quot;720&quot;&gt; &lt;div&gt;被canvas标签包裹的内容只有当浏览器不支持canvas时会显示，其余时候自动隐藏。&lt;/div&gt; &lt;div&gt;可以使用一张静态图片代替&lt;/div&gt;&lt;/canvas&gt; **&lt;/canvas&gt;**是必须的：如果没有写结束标签，那么&lt;canvas&gt;之后的所有内容都会被当做替代内容隐藏。","text":"简单地说：初始状态的canvas是一张透明的画布，我们能用不同方法在canvas上画图。 1&lt;canvas width=&quot;1440&quot; height=&quot;720&quot;&gt;&lt;/canvas&gt; canvas标签的特性只有宽和高可以设置。css中也可以改变它的宽高，但是默认保持原始宽高比。如果在css中强行同时设置宽高的话canvas标签和里面的画面会被拉伸，所以建议使用特性设置宽高。另外，虽然绘制过程中可以作出矢量图，但在浏览器渲染结束以后得到的是位图，这时通过样式放大的图将不会再具有矢量图的特性，马赛克严重。 兼容性：目前canvas基本得到了所有较新版本主流浏览器的支持，详见Can I Use Canvas? ，如果遇到了不兼容的浏览器的话，这里也有解决方案： 1234&lt;canvas width=&quot;1440&quot; height=&quot;720&quot;&gt; &lt;div&gt;被canvas标签包裹的内容只有当浏览器不支持canvas时会显示，其余时候自动隐藏。&lt;/div&gt; &lt;div&gt;可以使用一张静态图片代替&lt;/div&gt;&lt;/canvas&gt; **&lt;/canvas&gt;**是必须的：如果没有写结束标签，那么&lt;canvas&gt;之后的所有内容都会被当做替代内容隐藏。 canvas也可以用来渲染3d内容，比如使用WebGL。 一、使用步骤 在html中插入canvas标签，设置id（比如tutorial）； 在js中找到canvas标签：const canvas = document.getElementById(&#39;tutorial&#39;)； 检查支持性：if (!canvas.getContext) return； 获取canvas2d画布：const ctx = canvas.getContext(&#39;2d&#39;)； 使用canvas自带的方法作画。 二、栅格系统&amp;形状绘制1. 栅格系统​ 和绝大部分其他元素一样，默认canvas左上角为原点，向右为x轴正方向，向下为y轴正方向，单位是像素。原点可以用其他方法移动，网格也可以旋转和缩放。 ​ 2. 形状绘制 矩形一共有三个方法可以对矩形范围内的像素进行操作： fillRect(x, y, width, height)画一个填充了颜色的矩形，x和y代表矩形左上角，下同； strokeRect(x, y, width, height)画一个指定矩形的外边框； clearRect(x, y, width, height)清除指定矩形内所有像素。 路径canvas只能画矩形和路径，也就是说除了矩形其他所有形状都要先建立路径再画。路径本身是透明的，必须要描边和填充才能在画面上显示出来。 通过路径画画的步骤： 用beginPath方法新建一条路径，相当于把笔拿起来； 用moveTo(x, y)方法决定路径起始点(x, y)，相当于把笔尖放到点(x, y)；路径默认是连续的，想停笔再从新位置开始画就一定要使用moveTo； 用各种方法拖动路径，相当于在画面上规定想画的线； 如果是用stroke画闭合线条，那么需要手动或者用closePath方法闭合路径；fill画闭合填充不需要； 重复步骤234直到想画的线条&#x2F;想填充的区域已经规划好了，用stroke()或fill()方法描边&#x2F;填充。 可以绘制的所有路径如下： 线段：用lineTo(x, y)方法绘制一条从上一个路径的终点&#x2F;moveTo方法的决定点到(x, y)的路径 弧线：用arc(x, y, r, 开始角度, 结束角度, 是否为逆时针)绘制一条从点(x, y)、以r为半径的弧线。角度使用的是弧度制。 贝赛尔曲线：因为缺少视觉反馈，一般会结合辅助工具一起使用。 用quadraticCurveTo(cp1x, cp1y, x, y)绘制二次贝赛尔曲线。(cp1x, cp1y)为控制点，(x, y)为结束点； 用bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)绘制三次贝赛尔曲线。(cp1x, cp1y)为控制点1，(cp2x, cp2y)为控制点2，(x, y)为结束点； 矩形：除了直接画矩形以外，也可以先通过rect(x, y, width, height)绘制路径再进行描边&#x2F;填充。这个方法在绘制前会自动执行moveTo(x, y)，最后路径会停在(x, y)。 构造函数Path2D（IE不支持） Path2D的实例可以将之前对路径的描述储存为一个路径对象，然后再把它作为stroke和fill的参数使用描边&#x2F;填充。这样可以让每个路径独立出来，可读性更强： 1234567const circle = new Path2D()circle.arc(50, 50, 25, 0, Math.PI * 2)ctx.stroke(circle)const rectangle = new Path2D()rectangle.rect(20, 20, 10, 20) // 由于rect自动重置起始点所以不用moveToctx.fill(rectangle) 可以使用new Path2D(path)克隆一个新的路径实例 path1.addPath(path2[, transform])可以将path2添加到path1中（只能添加一个），之后统一进行处理。transform则可以用来进行矩阵变换。 实例化的时候可以用SVG的路径数据来创建路径实例： 1234567// M20 10：移动到点(20, 10)// h 70：水平方向正向移动70// v 80：垂直方向正向移动80// h -80：垂直方向逆向移动80// Z：回到起点处var p = new Path2D(&quot;M20 10 h 70 v 80 h -80 Z&quot;)ctx.stroke(p) // 会画出一个斜边在左的直角梯形 三、色彩 canvas中可以通过设置strokeStyle和fillStyle的值来分别给描边和填充上色。注意一旦设置了新颜色，这个颜色就是之后所有描边和填充的默认颜色了。想换颜色就再次设置吧。 设置颜色时要使用css3标准的有效字符串 透明度： 通过改变globalAlpha的值来设置之后所有颜色的透明度，不透明是1.0(默认)，完全透明是0.0； 单个描边&#x2F;填充设置颜色的时候就在赋值的时候使用rgba就好，这个透明度会和globalAlpha的值以乘法叠加。一般只使用这个方法就好。 四、线条线条有一系列属性可以修改样式： lineWidth = value：设置线条宽度。默认为1.0。 线宽是指给定路径的中心到两边的粗细。 换句话说就是在路径的两边各绘制线宽的一半。因为画布的坐标并不和像素直接对应，当需要获得精确的水平或垂直线的时候要特别注意。 lineCap = type：设置线条两端的样式； 有三种样式可以选择： butt(默认) round square lineJoin = type：设置两线段结合处的样式； 样式有三种： round bevel miter(默认) miterLimit = value：限制当两条线相交时交接处最大长度； 所谓交接处长度（斜接长度）是指线条交接处内角顶点到外角顶点的长度。 两线相交时，线段的外侧边缘会被延伸交汇于一点上。线段之间夹角比较大时，交点不会太远，但随着夹角变小，交点距离会呈指数级增大。所以需要限制这个距离，如果交点距离大于设定值，连接效果就会变成 bevel。 setLineDash([a, b])：设置当前虚线样式。接受一个数组[a, b]：a表示实线长度，b表示间隔长度。 lineDashOffset：设置虚线样式的起始偏移量。动画里可以通过不断改变其大小来实线虚线移动的效果。 getLineDash()：返回一个包含当前虚线样式，长度为非负偶数的数组。 五、渐变色使用步骤： 通过ctx的createLinearGradient或createRadialGradient方法创建一个渐变对象。 createLinearGradient(x1, y1, x2, y2)创建一个从(x1, y1)到(x2, y2)的渐变，方向从第一个点到第二个点。 createRadialGradient(x1, y1, r1, x2, y2, r2)创建一个从圆(x1, y1, r1)到圆(x2, y2, r2)的渐变。注意第二个圆一定要完整覆盖住第一个圆。第一个圆内完全是范围0的颜色，第二个圆外完全是范围1的颜色。 使用渐变对象的addColorStop方法在自己想要的地方添加基色(范围0.0 ~ 1.0)。 如果两个颜色位置重复了，那么顺序会决定渐变颜色(比如：0处为black、0.5处为white、0.5处为red、1处为blue，那么00.5的地方是黑色到白色渐变，然后0.51的地方是红色到蓝色渐变，白色和红色之间不会有渐变)。 设置ctx的fillStyle或strokeStyle属性的值为渐变对象。 使用各种描边和填充方法图上渐变色。 12345678910111213141516171819// 创建渐变对象const linGrad = ctx.createLinearGradient(0, 0, 10, 20)const radGrad = ctx.createRadialGradient(100, 100, 0, 110, 110, 14.15)// 第二个圆的半径要大于10√2// 给线性渐变对象添加一个0.1处为&#x27;#f91&#x27;、0.9处为&#x27;#19f&#x27;的渐变linGrad.addColorStop(.1, &#x27;#f91&#x27;)linGrad.addColorStop(.9, &#x27;#19f&#x27;)// 给辐射渐变对象添加0处为白色、0.7处为黑色的渐变radGrad.addColorStop(0, &#x27;#fff&#x27;)radGrad.addColorStop(.7, &#x27;#000&#x27;)// 改变笔刷颜色ctx.strokeStyle = linGradctx.fillStyle = radGrad// 给需要的地方上色ctx.fillRect(90, 90, 130, 130)ctx.strokeRect(0, 0, 15, 25) 六、图案-pattern canvas支持用重复图案填充，使用的方法为createPattern(image, type)： image：可以是Image对象或者另一个canvas画布对象。使用Image实例时要确定图像已经加载完毕，一般将语句放在load事件内。 type：取值为repeat、repeat-x、repeat-y、no-repeat 使用方法： 获取img对象或者其他canvas对象。 使用ctx.createPattern方法创建一个图案对象。 将fillStyle或strokeStyle属性赋值为图案对象 描边或填充 七、阴影和css中类似，需要设置四个值： shadowOffsetX和shadowOffsetY：取值为浮点数，设定阴影延伸距离，正方向分别为→和↓。 shadowBlur：取值为浮点数，设定模糊程度。 shadowColor：取值为标准css颜色值，默认为rgba(0, 0, 0, 0) 八、填充规则当用到 fill（或者 clip和isPointinPath ）时可以选择一个填充规则。该填充规则根据某处在路径的外面或者里面来决定该处是否被填充，这对于自己与自己路径相交或者路径被嵌套的时候是有用的。 1234ctx.beginPath()ctx.arc(50, 50, 30, 0, Math.PI*2, true)ctx.arc(50, 50, 15, 0, Math.PI*2, true)ctx.fill(&quot;evenodd&quot;)// 这样被填充的是两个路径之间的内容 九、文本canvas支持绘制文本或者文本的外轮廓： ctx.fillText(text, x, y [, maxWidth])：从(x, y)处绘制一个内容是text(，最大宽度为maxWidth)的文本 ctx.strokeText(text, x, y [, maxWidth])：和上面的方法类似，不同的是绘制的是文本的外轮廓（类似华文彩云） canvas支持修改文本样式： ctx.font：和css相同，可以修改是否斜体、文字粗细、文字大小、文字字体 ctx.textAlign：和css相同 ctxtextBaseline：基线对齐选项。可选的值包括：top, hanging, middle, alphabetic, ideographic, bottom。默认值是 alphabetic。 ctx.direction：文本方向。可能的值包括：ltr, rtl, inherit。默认值是 inherit。 十、图片canvas中可以使用外链的图片来作图： 获取图片&#x2F;其他canvas元素作为图源。 使用drawImage方法把图片绘制到canvas中。 图源： 同一页面内的图片：如果需要用页面内已经读取的img元素内的图片，canvas可以直接使用其dom对象。 使用其他域名内的图片：通过跨域，canvas可以加载其他域名内的图片。但如果服务器不允许跨域访问，那么有污染canvas的风险。 使用其他canvas元素：drawImage方法支持使用其他canvas的dom对象，该方法常用于缩略图和双缓冲中。 读取新图片：可以使用Image构造函数获取一张新图片。不过需要把回调函数放到load事件中，否则要么什么都不会发生，要么会报错。 使用data:url获取图片：使用base64编码的字符串来定义图片。缺点是图片无法缓存，同时图片太大会导致html文件过大。 使用视频帧截图：canvas支持使用video标签的视频帧，将当前视频播放的画面渲染到canvas上。 绘图：drawImage方法有三种使用手段： ctx.drawImage(image, x, y)：最基础的使用方法，以ctx的点(x, y)为左上角，绘制image图源，大小和图源相同。 ctx.drawImage(image, x, y, width, height)：可以缩放图源的方法，通过width和height来控制绘制在canvas上的宽高。 ctx.drawImage(image, x0, y0, width0, height0, x, y, width, height)：终极方法，可以截取图源image的内容。从以点(x0, y0)为左上角，以width0和height0为宽高把需要的内容截取出来，然后绘制在canvas上，绘制方法和第二条一样。常用于精灵图的展示。 是否在图像缩放时平滑处理：图源在被过度缩放时会产生模糊或像素化，canvas默认会将平滑处理功能打开。根据需要也可以关闭这个功能： ctx.imageSmoothimgEnabled = boolean：默认值为true。","categories":[{"name":"canvas","slug":"canvas","permalink":"https://bloodthirsty2b.github.io/categories/canvas/"}],"tags":[{"name":"canvas","slug":"canvas","permalink":"https://bloodthirsty2b.github.io/tags/canvas/"}]},{"title":"支付流程","slug":"miniProgram/支付流程","date":"2022-07-05T02:51:20.000Z","updated":"2021-12-20T15:54:18.647Z","comments":true,"path":"2022/07/05/miniProgram/支付流程/","link":"","permalink":"https://bloodthirsty2b.github.io/2022/07/05/miniProgram/%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B/","excerpt":"一、创建订单 判断缓存中有没有token 没有的话跳转到授权页面获取 有token再创建订单，获取订单编号 流程：获取用户信息(getUserInfo) → 获取用户登录信息(wx.login) → 获取token → 获取订单编号 二、准备预支付","text":"一、创建订单 判断缓存中有没有token 没有的话跳转到授权页面获取 有token再创建订单，获取订单编号 流程：获取用户信息(getUserInfo) → 获取用户登录信息(wx.login) → 获取token → 获取订单编号 二、准备预支付 通过获取的token和订单编号，发送请求获取预支付需要的数据，包括timeStamp | nonceStr | package | singType | paySign 三、发起微信支付 使用wx.requestPayment方法发送支付请求 支付成功后可以通过对应的查询订单的接口查看支付是否成功 支付成功后需要在缓存的订单列表中删除对应的订单","categories":[{"name":"miniProgram","slug":"miniProgram","permalink":"https://bloodthirsty2b.github.io/categories/miniProgram/"}],"tags":[{"name":"miniProgram","slug":"miniProgram","permalink":"https://bloodthirsty2b.github.io/tags/miniProgram/"}]},{"title":"注意事项","slug":"miniProgram/注意事项","date":"2022-06-28T07:48:04.000Z","updated":"2021-12-20T15:54:35.113Z","comments":true,"path":"2022/06/28/miniProgram/注意事项/","link":"","permalink":"https://bloodthirsty2b.github.io/2022/06/28/miniProgram/%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","excerpt":"微信小程序和原生web语法不同的地方&amp;小技巧一、wxml swiper 标签存在默认宽高（100% * 150px）。 image 标签也存在默认宽高（320px * 240px），可以进行设置全局的样式width: 100%;和特性mode=&quot;widthFix&quot;来当作普通img标签使用。 二、wxss 不支持通配符选择器（*） wxss支持变量，语法（设置主题颜色）： 定义：--themeColor: #eb4450; 使用：color: var(--themeColor); 如果使用了less，并且使用了类似calc(100vh - 70rpx)的语句的话，自动生成的wxss会计算错误，变成calc(30vh)。想要原来的代码的话应该使用字符串：~&#39;calc( 100vh - 70rpx )&#39; 三、wxs相当于页面js中分出来的模块文件 需要使用module.exports导出模块中的数据，然后在引入wxs的wxml中使用module特性定义引入的对象名：","text":"微信小程序和原生web语法不同的地方&amp;小技巧一、wxml swiper 标签存在默认宽高（100% * 150px）。 image 标签也存在默认宽高（320px * 240px），可以进行设置全局的样式width: 100%;和特性mode=&quot;widthFix&quot;来当作普通img标签使用。 二、wxss 不支持通配符选择器（*） wxss支持变量，语法（设置主题颜色）： 定义：--themeColor: #eb4450; 使用：color: var(--themeColor); 如果使用了less，并且使用了类似calc(100vh - 70rpx)的语句的话，自动生成的wxss会计算错误，变成calc(30vh)。想要原来的代码的话应该使用字符串：~&#39;calc( 100vh - 70rpx )&#39; 三、wxs相当于页面js中分出来的模块文件 需要使用module.exports导出模块中的数据，然后在引入wxs的wxml中使用module特性定义引入的对象名： 1234567891011// /pages/tools.wxsvar foo = &quot;&#x27;hello world&#x27; from tools.wxs&quot;;var bar = function (d) &#123; return d;&#125;module.exports = &#123; FOO: foo, bar: bar,&#125;;module.exports.msg = &quot;some msg&quot;; 12345&lt;!-- page/index/index.wxml --&gt;&lt;wxs src=&quot;./../tools.wxs&quot; module=&quot;tools&quot; /&gt;&lt;view&gt; &#123;&#123;tools.msg&#125;&#125; &lt;/view&gt;&lt;view&gt; &#123;&#123;tools.bar(tools.FOO)&#125;&#125; &lt;/view&gt; 四、将后台域名添加到小程序后台 点击微信小程序开发者中心 左侧开发Tab 服务器域名 修改【request合法域名】 扫码 添加域名 五、js 在wx:for中，使用字符串*this可以指代循环中的item本身。当数组内都是简单类型时，可以使用*this作为wx:key的值。 小程序中本地存储通过wx:getStorageSync(key)同步方法获取，通过wx:setStorageSync(key，value)设置。注意：web中会调用toString方法转换成字符串储存，所以复杂类型需要手动调用JSON.stringify方法；而小程序中没有转换需要，存进去什么数据，取出来就是什么数据。 下拉刷新请求成功后可以通过wx.stopPullDownRefresh方法关闭加载动画 data属性中的成员（如各种list）尽量只包含wxml中使用到的数据，存放太多会导致性能稍微下降。 模拟计算属性：可以写一个方法，形参为计算属性依赖的数据，方法中计算出需要的数据，然后setData input标签内的bindinput绑定的方法不能设置异步，否则搜索框内会固定显示[object Promise] 六、小程序开发工具 编译模式：可以设置小程序启动&#x2F;重启时打开的第一个页面。每增加一个编译模式，都可以设置不同的启动页。 可以通过wx.chooseAddress 等方法获取用户权限，但是如果第一次获取权限被拒绝的话，之后就不能再次获取了。 此时需要通过wx.getSetting方法返回的结果中scope属性的成员来查看权限状态（用户授权了值为true，用户拒绝授权值为false，用户从未授权则值为undefined）。 如果用户拒绝过授权的话，再次授权前要先调用wx.openSetting方法打开专门的授权页面让用户再次授权。然后再在success中重新调用wx.chooseAddress等方法。 1234567891011121314151617181920212223242526Page(&#123; handleChooseAddress () &#123; // 1. 尝试直接获取权限 wx.getSetting(&#123; success (res) &#123; // 2.如果属性名有可能是undefined，就开始使用中括号语法，防止从undefined上获取数据而报错 const scopeAddress = res.authSetting[&#x27;scope.address&#x27;] if (scopeAddress || scopeAddress === undefined) &#123; wx.chooseAddress(&#123; success (res2) &#123; console.log(res2) &#125; &#125;) &#125; else &#123; // 3. 用户拒绝过授权，需要先让用户重新授权 wx.openSetting(&#123; success (res3) &#123; const res2 = await wx.chooseAddress() console.log(res2) &#125; &#125;) &#125; &#125; &#125;) &#125;&#125;) // 要使用async await的话需要自行封装并返回promise 注意：状态是存放在缓存中的，测试时需要先清空缓存。 项目上线： 上线之前一定要把不校验合法域名功能关闭，请求接口全部添加到小程序后台信任列表中。 项目大小不能超过2M，超过的话需要进行分模块处理（此时不能超过16M），具体信息可以在详情 → 项目配置中看到。 不会将小程序用不到的文件上传（比如less文件）。 上传完成后能在小程序后台 → 管理 → 版本管理中看到，需要将开发版本进行审核，审核通过后才能上线。","categories":[{"name":"miniProgram","slug":"miniProgram","permalink":"https://bloodthirsty2b.github.io/categories/miniProgram/"}],"tags":[{"name":"miniProgram","slug":"miniProgram","permalink":"https://bloodthirsty2b.github.io/tags/miniProgram/"}]},{"title":"页面、应用生命周期","slug":"miniProgram/页面、应用生命周期","date":"2022-06-28T04:29:35.000Z","updated":"2021-12-20T15:54:27.537Z","comments":true,"path":"2022/06/28/miniProgram/页面、应用生命周期/","link":"","permalink":"https://bloodthirsty2b.github.io/2022/06/28/miniProgram/%E9%A1%B5%E9%9D%A2%E3%80%81%E5%BA%94%E7%94%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"一、应用钩子函数 在app.js中App方法中编写 onLaunch 在页面第一次启动时触发，只会触发一次，可用来获取用户信息等数据。 onShow 在页面切换到前台时触发，一定会在onLaunch后触发。可以重置数据或页面效果。 onHide 在页面隐藏到后台时触发。可以取消设置的定时器等。 onError 当应用报错时触发。可以从方法中获取错误参数。 onPageNotFound 当应用第一次启动，找不到入口页面时触发。可以在发生事件时跳转到其他页面（比如404）。 二、页面钩子函数","text":"一、应用钩子函数 在app.js中App方法中编写 onLaunch 在页面第一次启动时触发，只会触发一次，可用来获取用户信息等数据。 onShow 在页面切换到前台时触发，一定会在onLaunch后触发。可以重置数据或页面效果。 onHide 在页面隐藏到后台时触发。可以取消设置的定时器等。 onError 当应用报错时触发。可以从方法中获取错误参数。 onPageNotFound 当应用第一次启动，找不到入口页面时触发。可以在发生事件时跳转到其他页面（比如404）。 二、页面钩子函数 生命周期钩子函数 onLoad 页面刚刚加载完成时触发。第一个触发。可以在函数中获得options参数，代表路由的参数。 onShow 页面切换到前台时触发。第二个触发。无法通过options获取路由参数，需要通过页面栈（长度&lt;&#x3D;10）获取： 12const pages = getCurrentPages() // pages就是页面栈了，可以从最后一个对象中获取当前页面的options。 console.log(pages) onReady 页面刚刚渲染完毕时触发。第三个触发。 onHide 页面隐藏到后台时触发。 onUnload 页面卸载时（关闭当前页面）触发。 常用功能性钩子函数 onPullDownRefresh 下拉刷新时触发。 onReachBottom 滚动触底时触发。 onShareAppMessage 用户转发小程序后触发。 onPageScroll 页面发生滚动时触发。 onResize 页面大小发生改变时触发（从竖屏到横屏也会触发，App.json或页面.json需要启动横竖屏切换功能：微信小程序开发文档：在手机上启用屏幕旋转功能）。 onTabItemTap 当前是Tab页面，再点击同一个Tab时触发（可以用来刷新页面数据等）。","categories":[{"name":"miniProgram","slug":"miniProgram","permalink":"https://bloodthirsty2b.github.io/categories/miniProgram/"}],"tags":[{"name":"miniProgram","slug":"miniProgram","permalink":"https://bloodthirsty2b.github.io/tags/miniProgram/"}]},{"title":"自定义组件","slug":"miniProgram/自定义组件","date":"2022-06-27T10:22:53.000Z","updated":"2021-12-20T15:54:02.989Z","comments":true,"path":"2022/06/27/miniProgram/自定义组件/","link":"","permalink":"https://bloodthirsty2b.github.io/2022/06/27/miniProgram/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6/","excerpt":"自定义组件文档：https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/ 一、创建自定义组件 在根目录中新建文件夹components/组件名/ 创建好文件夹后可以在微信开发者工具中快速新建组件需要的各个文件。 在需要引入该组件的页面的文件夹中打开对应json，引入需要的组件(这里是Tabs组件)： 12345&#123; &quot;usingComponents&quot;: &#123; &quot;Tabs&quot;: &quot;../../components/Tabs/Tabs&quot; &#125;&#125; 在页面的wxml中使用组件： 1&lt;Tabs&gt;&lt;/Tabs&gt;","text":"自定义组件文档：https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/ 一、创建自定义组件 在根目录中新建文件夹components/组件名/ 创建好文件夹后可以在微信开发者工具中快速新建组件需要的各个文件。 在需要引入该组件的页面的文件夹中打开对应json，引入需要的组件(这里是Tabs组件)： 12345&#123; &quot;usingComponents&quot;: &#123; &quot;Tabs&quot;: &quot;../../components/Tabs/Tabs&quot; &#125;&#125; 在页面的wxml中使用组件： 1&lt;Tabs&gt;&lt;/Tabs&gt; 二、组件的特点组件与普通页面方法编写的位置差别： 在普通页面中方法书写的位置与data、onload等成员同层级 而在组件中，方法必须写在methods对象中 三、数据父传子父组件向子组件传递数据：父组件通过标签的attributes写入数据，子组件通过properties接收数据。12&lt;!-- 父组件.wxml --&gt;&lt;Tabs str=&quot;这是一个字符串&quot;&gt;&lt;/Tabs&gt; 1234567891011121314// 子组件.jsComponent(&#123; properties: &#123; str: &#123; type: String, // 这里要写清楚数据类型 value: &#x27;这里还没有数据&#x27; // 默认值，没有传入数据的话使用这个值 &#125; &#125;, methods: &#123; handleEventSon () &#123; console.log(this.data.str) // 数据会直接复制一份到data中，改变数据不会影响父组件 &#125; &#125;&#125;) wxml中使用数据的时候直接写变量名就好： 12&lt;!-- 子组件.wxml --&gt;&lt;view bindtap=&quot;handleEventSon&quot;&gt;&#123;&#123;str&#125;&#125;&lt;/view&gt; 注意：在子组件中用setData方法改变父组件传入的properties数据不会影响到父组件中的数据！！！需要通过子传父把数据返回给父组件。 四、数据子传父子组件向父组件传递数据：子组件触发父组件中给子组件标签上注册的自定义事件，并传入需要传递的数据子组件通过this.triggerEvent方法来触发自定义事件 12&lt;!-- 子组件.wxml --&gt;&lt;view data-newstr=&quot;新字符串&quot; bindtap=&quot;handleEventSon&quot;&gt;&#123;&#123;str&#125;&#125;&lt;/view&gt; 12345678910// 子组件.jsComponent(&#123; data: &#123;&#125;, methods: &#123; handleEventSon (e) &#123; const &#123;newStr&#125; = e.currentTarget.dataset this.triggerEvent(&#x27;eventdad&#x27;, newStr) &#125; &#125;&#125;) 12&lt;!-- 父组件.wxml --&gt;&lt;Tabs str=&quot;&#123;&#123;str&#125;&#125;&quot; bindeventdad=&quot;handleEventDad&quot;&gt;&lt;/Tabs&gt; 123456789101112// 父组件.jspage(&#123; data: &#123; str: &#x27;这是一个字符串&#x27; &#125;, handleEventDad (e) &#123; const newStr = e.detail this.setData(&#123; str: newStr &#125;) &#125;&#125;) 五、插槽父组件使用了子组件后，可以在双标签中编写其他内容，这些内容最后会替换掉子组件中的slot标签 12345678910111213&lt;!-- 父组件.wxml 这里使用了block标签来包裹内容，相当于templete标签 --&gt;&lt;Tabs&gt; &lt;block&gt; &lt;view&gt;这是插槽内容，将会替换子组件中的slot标签&lt;/view&gt; &lt;/block&gt;&lt;/Tabs&gt;&lt;!-- 子组件.wxml --&gt;&lt;view&gt; &lt;view&gt;这是子组件中其他内容&lt;/view&gt; &lt;slot&gt;&lt;/slot&gt; &lt;view&gt;这是子组件中其他内容&lt;/view&gt;&lt;/view&gt; 六、组件Component函数常用参数属性： properties: 组件接收的数据 data: 组件自身数据 observers: 里面的方法可以用来监听数据(组件独有属性，页面中不存在) methods: 组件自身的方法 生命周期钩子函数： created: 组件刚刚被创建时执行，此时不能调用setData方法 attached: 组件插入页面节点树时执行，这时才能调用setData方法 ready: 组件布局完成后执行 moved: 组件被移动到节点树其他位置时执行 detached: 组件被从节点树中移除时执行","categories":[{"name":"miniProgram","slug":"miniProgram","permalink":"https://bloodthirsty2b.github.io/categories/miniProgram/"}],"tags":[{"name":"miniProgram","slug":"miniProgram","permalink":"https://bloodthirsty2b.github.io/tags/miniProgram/"}]},{"title":"微信小程序标签","slug":"miniProgram/微信小程序标签unfin","date":"2022-06-26T12:13:06.000Z","updated":"2021-12-20T15:54:11.261Z","comments":true,"path":"2022/06/26/miniProgram/微信小程序标签unfin/","link":"","permalink":"https://bloodthirsty2b.github.io/2022/06/26/miniProgram/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%A0%87%E7%AD%BEunfin/","excerpt":"微信小程序常见标签使用一、view标签&amp;text标签view标签： 长按展示不同样式： &lt;view hover-class=&quot;classhover&quot;&gt;&lt;/view&gt; 阻止冒泡：&lt;view hover-stop-propagation=&quot;true&quot;&gt;&lt;/view&gt; 文档：https://developers.weixin.qq.com/miniprogram/dev/component/view.html text标签： 长按使文字能被复制： &lt;text selectable&gt;&lt;/text&gt;; 对文本内容进行解码（例如识别$nbsp;）：&lt;text decode&gt;&lt;/text&gt; 文档：https://developers.weixin.qq.com/miniprogram/dev/component/text.html","text":"微信小程序常见标签使用一、view标签&amp;text标签view标签： 长按展示不同样式： &lt;view hover-class=&quot;classhover&quot;&gt;&lt;/view&gt; 阻止冒泡：&lt;view hover-stop-propagation=&quot;true&quot;&gt;&lt;/view&gt; 文档：https://developers.weixin.qq.com/miniprogram/dev/component/view.html text标签： 长按使文字能被复制： &lt;text selectable&gt;&lt;/text&gt;; 对文本内容进行解码（例如识别$nbsp;）：&lt;text decode&gt;&lt;/text&gt; 文档：https://developers.weixin.qq.com/miniprogram/dev/component/text.html 二、image标签因为项目大小不能超过2M，image一般引用网上文件，image标签有默认的宽高320 * 240，按需要手动调整 src 指定要加载的图片路径 mode 决定图片的宽高模式(图片默认宽高居中显示) scaleToFill 不保持纵横比缩放图片，使图片的宽高完全撑满image标签 aspectFit 保持纵横比，保证图片长边能完全放在容器中，不一定撑满image标签 aspectFill 保持纵横比，保证图片短边能完全放在容器中，图片很可能显示不完全 widthFix 保持纵横比，image宽度指定后高度自适应(直接无视css设置的高度) top、buttom、left … 不缩放图片，放在image标签中的指定位置 lazy-load 小程序中默认支持懒加载(image标签若判断自己处于视口上下3屏高度内就开始加载) 文档：https://developers.weixin.qq.com/miniprogram/dev/component/image.html 三、swiper标签 轮播图外层容器为&lt;swiper&gt;&lt;/swiper&gt; ，内层装的图片容器为&lt;swiper-item&gt;&lt;/swiper-item&gt; 默认样式：宽100%，高150px。 image标签默认宽高无法自适应swiper-item，且无法撑开swiper-item 一般通过原图宽高计算，给swiper定高度→swiper宽高比 &#x3D; 原图宽高比(可使用css中calc方法) 常用attributes： indicator-dots 是否显示轮播指示点 indicator-color=&quot;rgb(0, 0, 0, .3)&quot; 指示点颜色(支持16进制) indicator-active-color=&quot;#000&quot; 当前选中指示点颜色 autoplay 自动轮播 interval=&quot;5000&quot; 自动循环时间间隔 circular 是否循环轮播 文档：https://developers.weixin.qq.com/miniprogram/dev/component/swiper.html 四、navigator标签​ 类似于a标签，但是是块级元素，独占一行。 常用attributes： url 路径(相当于href) target=&quot;miniProgram&quot; 跳转的目标(可以是当前小程序的页面，也可以是其他小程序的，默认值是self) open-type=&quot;navigate&quot; 跳转方式，有如下值可用： navigate 保留当前页面(左上角会保留返回按钮)，跳转到应用内某页面，但是不能跳转到tabBar页面(点击什么都不会发生) redirect 关闭当前页面，跳转到应用内某页面，也不能跳转到tabBar页面 switchTab 跳转到tabBar页面，并关闭其他所有非tabBar页面(左上角不会有返回按钮) reLaunch 跳转到目标页面，并关闭所有页面 navigateBack 返回跳转前的页面 exit 退出其他小程序(一般配合target使用) 文档：https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html 五、rich-text标签 用来支持和显示html代码 attributes： nodes 接受一个标签字符串或对象数组 标签字符串：&lt;div&gt;啦啦啦&lt;/div&gt; 对象数组： 123456789101112html: [ &#123; name: &quot;div&quot;,// 标签名，支持大部分标签 attrs: &#123; class: &quot;my_div&quot;, style: &quot;color:red;&quot; &#125;,// 各种attributes children: [ &#123;&#125;// 里面可以再放类似的节点信息 ] &#125;] space 用来显示连续空格 tips: nodes尽量用array，使用string的话性能会稍微下降。 标签内屏蔽所有节点事件。 attrs内不支持id，支持class。 img标签只支持网络图片，且部分ios系统不支持webp格式。 若自定义组件中使用rich-text，wxss会对rich-text内部出现的class生效。 ios系统下rich-text中出现的图片可以长按提示操作，然后所有其他tap事件都会失效。解决方法是：添加-webkit-touch-callout: none;样式。 文档：https://developers.weixin.qq.com/miniprogram/dev/component/rich-text.html 六、button标签可以自定义按钮样式，下面是默认按钮 外观attributes： size 按钮大小，取值有 default 和 mini type 按钮样式类型，取值有 default 灰色、 primary 绿色 、 warn 红色 plain 按钮是否镂空 disabled 是否禁用 loading 是否在名称前加loading图标 功能attributes: contact 打开客服对话，需要在小程序后台配置(需要真机) 使用自己的appID加载小程序开发软件 登录微信小程序用户官网，在功能tab中点击客服，添加客服账号(可以是自己的另外一个账号) share 转发当前小程序到微信朋友中，不能转发到朋友圈 getPhoneNumber 配合bindgetphonenumber事件，在回调函数的参数中获取当前用户的手机号码加密信息(在后台解密)，非企业小程序账号没有权限获取用户手机号 getUserInfo 获取当前用户的个人信息，和上面一样需要bindgetuserinfo事件配合(未加密) launchApp 在小程序中打开某个app，需要先在app中通过链接打开小程序，才能反过来打开app(京东app可试验) openSetting 打开小程序内置的授权页面，只有用户曾经允许的授权信息(例如3、4中的手机号和个人信息) feedback 打开意见反馈页面(需要真机) 七、icon标签​ 图标标签 常用attributes： type 图标类型，取值(不完全)：success|success_no_circle|circle(文档未注明)|info|warn|waiting|cancel|download|search|clear size 图标大小，取值为number&#x2F;string，默认值23 color 图标颜色，取值同css的color 八、radio标签 类似于原生radio标签 选中后的默认绿色可以通过color特性修改 需要搭配 父级标签 radio-group标签 使用 12345&lt;radio-group bindchange=&quot;changeGender&quot;&gt; &lt;radio value=&quot;male&quot;&gt;男&lt;/radio&gt; &lt;radio value=&quot;female&quot;&gt;女&lt;/radio&gt;&lt;/radio-group&gt;&lt;view&gt;选中了&#123;&#123;gender&#125;&#125;性&lt;/view&gt; 1234567891011Page(&#123; data: &#123; gender: &#x27;&#x27; &#125;, changeGender (e) &#123; let gender = e.detail.value this.setData(&#123; gender &#125;) &#125;&#125;) 九、checkbox标签 类似于原生checkbox标签 同样可以通过color特性改变选中颜色 同样需要父级标签checkbox-group配合使用 十、scroll-view标签 可滚动标签 scroll-top=&quot;变量&quot;显示竖直方向滚动条所在的位置，需要重置到顶部时可以将变量重置为0。 scroll-left=&quot;变量&quot;显示水平方向滚动条所在位置，同上。 十一、rich-text标签 用来支持和显示html代码 attributes: nodes 可选值：array | string ；分别用来支持节点列表和字符串html，默认是array。 array内成员： name 标签名，只支持受信任的标签 attrs 属性 children 子节点列表","categories":[{"name":"miniProgram","slug":"miniProgram","permalink":"https://bloodthirsty2b.github.io/categories/miniProgram/"}],"tags":[{"name":"miniProgram","slug":"miniProgram","permalink":"https://bloodthirsty2b.github.io/tags/miniProgram/"}]},{"title":"从反色文字到mix-blend-mode","slug":"css/从反色文字到mix-blend-mode","date":"2022-06-09T11:00:32.000Z","updated":"2021-12-20T15:55:51.184Z","comments":true,"path":"2022/06/09/css/从反色文字到mix-blend-mode/","link":"","permalink":"https://bloodthirsty2b.github.io/2022/06/09/css/%E4%BB%8E%E5%8F%8D%E8%89%B2%E6%96%87%E5%AD%97%E5%88%B0mix-blend-mode/","excerpt":"最近有一个需求，意思大概是这样： 也就是将字体颜色设置为背景色的反色。 搜索了一下，决定使用css3提供的新属性：mix-blend-mode(混合模式)","text":"最近有一个需求，意思大概是这样： 也就是将字体颜色设置为背景色的反色。 搜索了一下，决定使用css3提供的新属性：mix-blend-mode(混合模式) 用过ps的都应该理解混合模式是一个强大的图层调色功能，和大神对各种混合特效的信手拈来不同，我对这个功能的理解非常短浅，所以也只是初步了解一下这个功能。 一、实现反色文字首先解决一下开头的问题： 123&lt;div class=&quot;background&quot;&gt; &lt;div class=&quot;text&quot;&gt;反色文字&lt;/div&gt;&lt;/div&gt; 123456789101112131415.background &#123; position: relative; width: 400px; height: 150px; background: linear-gradient(90deg, #f00, #ff0, #0f0, #0ff, #00f, #f0f);&#125;.text &#123; position: absolute; left: 0; top: 0; font-size: 100px; mix-blend-mode: difference; /* 由于字体色是纯色，这里也可以使用exclusion */ text-shadow: 1px 1px 0 #000; color: white; /* 配合白色底色实现与背景颜色值相反 */&#125; 取字体色和背景色三通道的差的绝对值作为结果，也就是： 最终通道值 = | 对应字体色通道值 - 对应背景色通道值 | (mix-blend-mode: difference;原理) 二、mix-blend-mode属性值12345678910111213141516171819202122div &#123; mix-blend-mode: normal; /* 正常 */ mix-blend-mode: multiply; /* 正片叠底 */ mix-blend-mode: screen; /* 滤色 */ mix-blend-mode: overlay; /* 叠加 */ mix-blend-mode: darken; /* 变暗 */ mix-blend-mode: lighten; /* 变亮 */ mix-blend-mode: color-dodge; /* 颜色减淡 */ mix-blend-mode: color-burn; /* 颜色加深 */ mix-blend-mode: hard-light; /* 强光 */ mix-blend-mode: soft-light; /* 柔光 */ mix-blend-mode: difference; /* 差值 */ mix-blend-mode: exclusion; /* 排除 */ mix-blend-mode: hue; /* 色相 */ mix-blend-mode: saturation; /* 饱和度 */ mix-blend-mode: color; /* 颜色 */ mix-blend-mode: luminosity; /* 亮度 */ mix-blend-mode: initial; /* 初始 */ mix-blend-mode: inherit; /* 继承 */ mix-blend-mode: unset; /* 复原 */&#125; 至于他们能生成什么奇妙的效果呢，可以去参观一下这个大佬的作品：https://www.cnblogs.com/coco1s/p/6829372.html","categories":[{"name":"css","slug":"css","permalink":"https://bloodthirsty2b.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://bloodthirsty2b.github.io/tags/css/"}]},{"title":"css隐藏滚动条","slug":"css/css隐藏滚动条","date":"2022-06-08T10:15:42.000Z","updated":"2021-12-20T15:55:35.255Z","comments":true,"path":"2022/06/08/css/css隐藏滚动条/","link":"","permalink":"https://bloodthirsty2b.github.io/2022/06/08/css/css%E9%9A%90%E8%97%8F%E6%BB%9A%E5%8A%A8%E6%9D%A1/","excerpt":"有的时候我们需要在一个宽度较小的情况下实现滚动，但是由于电脑端滚动条自身会占据一定的宽度，实际可视范围很可能非常小，这时就需要隐藏滚动条了。","text":"有的时候我们需要在一个宽度较小的情况下实现滚动，但是由于电脑端滚动条自身会占据一定的宽度，实际可视范围很可能非常小，这时就需要隐藏滚动条了。 1. 使用::-webkit-scrollbar隐藏(Chrome&amp;Safari限定)对于Chrome和Safari浏览器，可以直接调整元素滚动条的样式： 123.scrollBox::-webkit-scrollbar &#123; display: none;&#125; 2. 通用隐藏滚动条方法那对于其他浏览器有没有应用方法呢？有的，只要在滚动的盒子外再套一个限制宽高的溢出隐藏盒子就好。 123456&lt;div class=&quot;wrap&quot;&gt; &lt;ul class=&quot;scrollBox&quot;&gt; &lt;li&gt;...&lt;/li&gt; &lt;li&gt;...&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 12345678910111213141516171819.wrap &#123; position: relative; width: 100px; height: 200px; overflow: hidden;&#125;.scrollBox &#123; position: absolute; left: 0; top: 0; width: 117px; /* 滚动条的宽度大约是17px */ height: 200px; overflow: auto;&#125;li &#123; width: 100px; height: 500px;&#125;","categories":[{"name":"css","slug":"css","permalink":"https://bloodthirsty2b.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://bloodthirsty2b.github.io/tags/css/"}]},{"title":"元素css层叠等级","slug":"css/元素css层叠等级","date":"2022-01-08T10:38:56.000Z","updated":"2021-12-20T15:55:59.421Z","comments":true,"path":"2022/01/08/css/元素css层叠等级/","link":"","permalink":"https://bloodthirsty2b.github.io/2022/01/08/css/%E5%85%83%E7%B4%A0css%E5%B1%82%E5%8F%A0%E7%AD%89%E7%BA%A7/","excerpt":"","text":"z-index为正值 &gt; z-index: 0/auto;/没有设置z-index &gt; 行内元素 &gt; 浮动元素 &gt; 块级元素 &gt; z-index为负值 &gt; background/border","categories":[{"name":"css","slug":"css","permalink":"https://bloodthirsty2b.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://bloodthirsty2b.github.io/tags/css/"}]},{"title":"JQuery部分源码解读","slug":"JQuery/JQuery部分源码解读","date":"2021-12-22T02:48:04.000Z","updated":"2021-12-20T15:51:46.894Z","comments":true,"path":"2021/12/22/JQuery/JQuery部分源码解读/","link":"","permalink":"https://bloodthirsty2b.github.io/2021/12/22/JQuery/JQuery%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/","excerpt":"jQuery框架封装","text":"jQuery框架封装 沙箱模式沙箱其实就是一个独立的环境，这个环境中任何的改变，都不会对外部环境产生影响。 函数自调用一样，在自调用函数内部的变量是不会影响到外部的，因此函数自调用模式也叫沙箱模式。 123(function(window)&#123; &#125;)(window); jq的基本架构12345678(function(window)&#123; var jQuery = function()&#123; &#125; // 把jQuery函数暴露到全局中 window.jQuery = window.$ = jQuery;&#125;)(window); jq的选择器123456789101112131415(function(window)&#123; var jQuery = function(selector)&#123; // 根据选择器来获取元素 var ele = document.querySelectorAll(selector); // 把获取到的元素遍历添加到jq实例对象上 for(var i = 0; i &lt; ele.length; i++)&#123; this[i] = ele[i]; &#125; // 手动维护length属性为获取元素的个数 this.length = ele.length; &#125; window.jQuery = window.$ = jQuery;&#125;)(window); 原型添加方法12345678910111213141516171819(function(window)&#123; var jQuery = function(selector)&#123; // ... &#125; // 原型替换，给jq原型中添加成员 jQuery.prototype = &#123; constructor: jQuery, css: function()&#123; // css 操作样式功能... &#125;, html: function()&#123; // html 操作文本内容功能... &#125;, //... &#125;; window.jQuery = window.$ = jQuery;&#125;)(window); 省去new的操作使用工厂函数来省去new可以得到实例对象，方便得到实例对象，不用自己手动new 改变构造函数init的原型得到的实例对象访问不到jq原型中的成员，改变init构造函数的原型，使其init的实例对象可以访问的到jq原型中的成员。","categories":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/categories/js/"},{"name":"JQuery","slug":"js/JQuery","permalink":"https://bloodthirsty2b.github.io/categories/js/JQuery/"}],"tags":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/tags/js/"},{"name":"JQuery","slug":"JQuery","permalink":"https://bloodthirsty2b.github.io/tags/JQuery/"}]},{"title":"Vue.use,Vuex,反向代理","slug":"Vue/Vue.use-Vuex-反向代理","date":"2021-11-23T06:40:17.000Z","updated":"2021-12-20T15:50:53.338Z","comments":true,"path":"2021/11/23/Vue/Vue.use-Vuex-反向代理/","link":"","permalink":"https://bloodthirsty2b.github.io/2021/11/23/Vue/Vue.use-Vuex-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/","excerpt":"Vue.use所有vue后缀文件都是组件，需要在main.js中引入(import)并注册组件","text":"Vue.use所有vue后缀文件都是组件，需要在main.js中引入(import)并注册组件 自定义插件： 12345678910// 自定义插件对象const plugin = &#123; // install方法会在Vue.use调用时被自动调用 install () &#123; // 这样一来只要Vue.use就会自动注册组件了 vue.component(&#x27;my-button&#x27;, &#123;...&#125;) &#125;&#125;export default plugin main.js 123import Vue from &#x27;../Vue.js&#x27;import plugin from &#x27;../plugin.js&#x27;Vue.use(plugin) 打包优化vue-cli语法：yarn build 优化： js文件夹中的map后缀文件是用来做浏览器兼容调试的，不需要可以删 ventors作为第三方包的汇总会很大 CDN优化：CDN是部署于世界各地的服务器，服务器内有大部分常用的第三方包(将包部署于CDN需要收费，很贵，一般不会把项目部署到CDN中)，引入时其实只要写上包的地址即可，不需要放在项目中 配置方法(以Vue举例)： 12&lt;!-- 在打包后的index.html中引入 --&gt;&lt;script src=&quot;cdn中Vue的地址&quot;&gt;&lt;/script&gt; 12345678// 在vue.config.js中配置webpack忽视node_modulesconfigurWebpack: &#123; // 配置打包的排除项，从外部引入 externals: &#123; // 这样就会忽视node_modules，去导入全局的vue了 vue: &#x27;Vue&#x27; // 这个值需要去对应的cdn地址的文件中找export的变量名 &#125;&#125; 自己的js也打包到一个文件内了，项目页面多了会很大 vue异步组件：需要什么加载什么 第一步优化： 1234567// router.js// 将import需要的路径放到一个返回该路径的回调函数中，不调用该函数不会加载组件// import Login from &#x27;./components/Login.vue&#x27;const Login = () =&gt; import(&#x27;./components/Login.vue&#x27;)// 问题：请求次数变多了 第二步优化： 1234// 将引入的模块分类const Login = () =&gt; import(/* webpackChunkName: &#x27;模块分类名&#x27; */&#x27;./components/Login.vue&#x27;)// 这样打包后会将同一个分类的模块打包到一起去，访问其中一个会请求所有的模块 上线前需要把main.js中配置的axios默认路径前缀修改为线上服务器路径。 Vuexvuex时vue的状态管理工具，用于管理vue中的数据，所有组件都能访问到其中的数据，和localStorage类似。 和localStoragede区别： localStorage中只能存字符串，而vuex可以存任意类型 vuex会增加项目复杂度 使用方法： 下载&amp;引入 用Vue.use()使用vuex 创建仓库store 123456const store = new Vuex.Store(&#123; // 状态即数据 state: &#123; msg: &#x27;hoho&#x27; &#125;&#125;) 和vue实例建立关联 1234567const vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; msg: &#x27;lala&#x27; &#125;, store&#125;) 访问vuex中的数据： js中 store.state.msg this.$store.state.msg vm.$store.state.msg 组件中 $store.state.msg 写起来很麻烦，通常使用计算属性返回 修改vuex中的值直接修改vuex的值不会报错，需要采用严格模式（原理为深度监听，上线后需要取消）： 1234567const store = new Vuex.Store(&#123; state: &#123; msg: &#x27;hoho&#x27; &#125;, // 开启严格模式 strict: true&#125;) 应该遵守vuex到项目的单向数据流，修改数据应该使用mutation方法 1234567891011121314151617181920212223242526const store = new Vuex.Store(&#123; state: &#123; msg: &#x27;hoho&#x27; &#125;, // strict: true, mutations: &#123; change2(state, obj) &#123; // mutations中所有的方法第一个参数都是state state.msg = obj.msg2 &#125; &#125;&#125;)const vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; msg: &#x27;lala&#x27; &#125;, methods: &#123; change () &#123; // 修改vuex中的数据需要提交，可以传参(只能传一个参数，有多个参数就使用对象) this.$store.commit(&#x27;change2&#x27;, &#123; msg2: &#x27;haha&#x27; &#125;) &#125; &#125; store&#125;) 基于vuex的派生属性(相当于计算属性的getter)1234567891011121314151617const store = new Vuex.Store(&#123; state: &#123; msg: &#x27;hoho&#x27; &#125;, // strict: true, mutations: &#123; change2(state, obj) &#123; state.msg = obj.msg2 &#125; &#125;, getters: &#123; getter1 (state) &#123; // 第一个参数也是state return state.msg &#125; &#125;&#125;) vuex辅助函数的使用（语法糖） mapGetters：是一个函数，将vuex中的getters直接映射给组件，相当于在computed中设置属性返回getters 123456789101112// 组件中import &#123; mapGetters &#125; from &#x27;vuex&#x27;// 精确导入export default &#123; computed: &#123; // 为了写自己的计算属性，使用展开运算符 ...mapGetters([getters中的属性名]), // 使用对象可以自定义属性名 ...mapGetters(&#123; 自定义属性名: getters中的属性名 &#125;) &#125;&#125; mapState：用法和mapGetters一样 mapMutations：不好用，因为只有只进行了提交操作的mutations能使用 vuex-actions由于异步函数是由window调用的，所以mutiation中使用异步函数会报错。事实上所有回调函数的调用都无法被追踪，所以需要用到actions 123456789101112// vuex中const store = new Vuex.Store(&#123; // actions中不能直接操作state，只能提交mutations来操作 actions = &#123; // 所有actions中的第一个参数，都是context(上下文)，也就是store change (context) &#123; setTimeout(() =&gt; &#123; context.commit(mutations方法, 参数) &#125;) &#125; &#125;&#125;) 12345678910111213// 组件中const vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; msg: &#x27;lala&#x27; &#125;, methods: &#123; change () &#123; this.$store.dispatch(actions属性名) &#125; &#125; store&#125;) module在需要多个仓库里使用module来分模块 vue反向代理浏览器同源策略会使浏览器与服务器之间产生跨域问题，但是服务器与服务器之间没有跨域问题，所以在vue中采用代理服务器就可以解决这一问题。 使用webpack中的配置可以进行配置(平常更多使用的是ngnix)，开发的时候常会遇到跨域问题，使用的较为频繁 配置devServer.proxy 12345678910111213// vue.config.js中export default &#123; devServer: &#123; proxy: &#123; // 只要请求的路径中包含/api就会被代理成 http://需要被代理的路径/api/... 。 &quot;/api&quot;: &#123; target: &quot;需要被代理的路径&quot;, // 路径中多了个/api，需要重写 pathRewrite: &#123;&quot;^/api&quot;: &quot;&quot;&#125; &#125; &#125; &#125;&#125; 之后再发送请求，表面上是向页面所在服务器请求，实际上则是由代理服务器向后台发送了请求，并返回了数据。","categories":[{"name":"Vue","slug":"Vue","permalink":"https://bloodthirsty2b.github.io/categories/Vue/"},{"name":"Vuex","slug":"Vue/Vuex","permalink":"https://bloodthirsty2b.github.io/categories/Vue/Vuex/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://bloodthirsty2b.github.io/tags/Vue/"},{"name":"Vuex","slug":"Vuex","permalink":"https://bloodthirsty2b.github.io/tags/Vuex/"}]},{"title":"Element-ui使用心得","slug":"Vue/Element-ui使用心得","date":"2021-11-21T02:56:47.000Z","updated":"2021-12-20T15:50:46.160Z","comments":true,"path":"2021/11/21/Vue/Element-ui使用心得/","link":"","permalink":"https://bloodthirsty2b.github.io/2021/11/21/Vue/Element-ui%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/","excerpt":"Element-ui使用心得el-form el-form数据:model，校验数据:rules，表单标签宽度label-width el-form-item表单标签label，校验数据prop 内部表单组件数据v-model 修改数据： 数据回显： 若在dialog中则在关闭之后通过this.$refs获取el-form实例上的resetFields方法重置表单数据（重置表单一定要给el-form-item加prop属性） 数据上传： 通过this.$refs获取el-form实例上的validate方法，使用try&amp;catch进行表单校验，校验成功后发送ajax上传表单数据","text":"Element-ui使用心得el-form el-form数据:model，校验数据:rules，表单标签宽度label-width el-form-item表单标签label，校验数据prop 内部表单组件数据v-model 修改数据： 数据回显： 若在dialog中则在关闭之后通过this.$refs获取el-form实例上的resetFields方法重置表单数据（重置表单一定要给el-form-item加prop属性） 数据上传： 通过this.$refs获取el-form实例上的validate方法，使用try&amp;catch进行表单校验，校验成功后发送ajax上传表单数据 el-pagination当前页码:current-page 当前页码改变@current-change 每页显示数量 :page-size 每页显示数量可选项:page-sizes 每页显示数量改变@size-change 布局layout=&quot;total, sizes, prev, pager, next, jumper&quot; 项目总数:total el-dialog对话框标题title 是否显示:visible.sync 关闭时触发事件@close 关闭后触发事件@closed 把传入插槽的组件放到对话框的右下角： 123&lt;template v-slot:footer&gt; &lt;p&gt;啦啦啦&lt;/p&gt;&lt;/template&gt; el-select选择器 el-select（选中哪个option，它的value就是那个option的value） 选择的optionv-model（对应option的value） el-option（需要使用v-for和:key遍历） 显示的标签名:label 内部的value值:value el-menu导航菜单 el-menu整个菜单 唯一选中unique-opened 将el-submenu和el-menu-item的index特性值当作路径使用router 默认打开项:default-active （可以配合计算属性和this.$route.path使用） el-submenu可展开的菜单（配合v-for使用） 唯一标识（防止点击一项展开所有项）:index 菜单标题： 123&lt;template v-slot:title&gt; &lt;span&gt;菜单标题&lt;/span&gt;&lt;/template&gt; el-menu-item最小子菜单（配合v-for使用） 唯一标识:index（可配合el-menu的router特性作为路径使用） el-breadcrumb面包屑分隔符separator-class（图标采用类名使用方法） el-breadcrumb-item面包屑导航项 导航路径:to=&quot;&#123; path: &#39;/index&#39; &#125;&quot; el-tree树形表 输入的数据:data：数据中每个子节点必须包含用于展示的标签属性、用于识别的key属性 设置标签属性和key属性在数据中的属性名:props=&quot;&#123;label: &#39;标签属性名&#39;, children: &#39;子列表项属性名&#39;&#125;&quot; 展示节点选择框show-checkbox 默认展开全部节点default-expand-all 设置节点的唯一标识node-key=&quot;id&quot;： 其中id是每个节点数据中必须要有的属性，值在该树中唯一 默认被选中的项:default-checked-keys=&quot;Array&quot; ：Array是一个包含所有被选中节点的key的数组","categories":[{"name":"Vue","slug":"Vue","permalink":"https://bloodthirsty2b.github.io/categories/Vue/"},{"name":"Element-ui","slug":"Vue/Element-ui","permalink":"https://bloodthirsty2b.github.io/categories/Vue/Element-ui/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://bloodthirsty2b.github.io/tags/Vue/"},{"name":"Element-ui","slug":"Element-ui","permalink":"https://bloodthirsty2b.github.io/tags/Element-ui/"}]},{"title":"Vue脚手架：vue-cli","slug":"Vue/10- Vue脚手架：vue-cli","date":"2021-11-12T14:11:35.000Z","updated":"2021-12-20T15:50:39.159Z","comments":true,"path":"2021/11/12/Vue/10- Vue脚手架：vue-cli/","link":"","permalink":"https://bloodthirsty2b.github.io/2021/11/12/Vue/10-%20Vue%E8%84%9A%E6%89%8B%E6%9E%B6%EF%BC%9Avue-cli/","excerpt":"vue脚手架的使用脚手架的意义 脚手架是开发现代web应用的必备 充分利用webpack，babel，eslint等工具辅助项目开发 开箱即用，零配置，无需手动配置繁琐的工具即可使用 vue脚手架还提供了配套的图形管理界面，用于创建，开发和管理你的项目","text":"vue脚手架的使用脚手架的意义 脚手架是开发现代web应用的必备 充分利用webpack，babel，eslint等工具辅助项目开发 开箱即用，零配置，无需手动配置繁琐的工具即可使用 vue脚手架还提供了配套的图形管理界面，用于创建，开发和管理你的项目 vue脚手架使用 初始化命令 1234# 全局安装 vue命令yarn global add @vue/cli# 初始化项目vue create hello-world 选择预设 选择项目的功能 按空格进行选择，按回车进行下一步 选择路由的风格 选择css预处理语言 选择代码规范 选择校验规则 配置文件的生成方式 保存配置 给预设起名字 启动项目（项目根目录下） 1yarn serve webpack配置vue已经提供了webpack的默认配置，也可以通过在根目录中创建vue.config.js文件添加自己的配置 1234567// 自动打开浏览器module.exports = &#123; devServer: &#123; open: true, port: 9000 &#125;&#125; 项目目录说明 .editorcofnig 需要给vscode安装要给插件EditorConfig eslintrceslint的配置文件，一般不用手动配置 .gitignore git的忽视文件 单文件组件基本概念 single-file components(单文件组件) ，文件扩展名为 .vue 的文件 单文件组件文档 优势： 完整语法高亮 CommonJS 模块 组件作用域的 CSS 单文件组件的结构说明 1234567891011121314151617181920212223&lt;template&gt; &lt;div&gt; &lt;h1&gt;这是单文件组件的模板内容&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 这是组件的js代码export default &#123; data () &#123; return &#123; msg: &#x27;hello vue&#x27; &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;/* 这是单文件组件的样式 */h1 &#123; color: red;&#125;&lt;/style&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://bloodthirsty2b.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://bloodthirsty2b.github.io/tags/Vue/"}]},{"title":"Vue动画：transition组件","slug":"Vue/09- Vue动画：transition组件","date":"2021-11-11T14:08:51.000Z","updated":"2021-12-20T15:50:31.846Z","comments":true,"path":"2021/11/11/Vue/09- Vue动画：transition组件/","link":"","permalink":"https://bloodthirsty2b.github.io/2021/11/11/Vue/09-%20Vue%E5%8A%A8%E7%94%BB%EF%BC%9Atransition%E7%BB%84%E4%BB%B6/","excerpt":"Vue动画：transition组件 Vue中新增的动画语法，一般用于实现转场动画 基本使用Vue 提供了 transition 的封装组件，在v-if 和 v-show中，可以给任何元素和组件添加进入&#x2F;离开过渡（会在动画过程中依次给组件中的元素切换6个类名）","text":"Vue动画：transition组件 Vue中新增的动画语法，一般用于实现转场动画 基本使用Vue 提供了 transition 的封装组件，在v-if 和 v-show中，可以给任何元素和组件添加进入&#x2F;离开过渡（会在动画过程中依次给组件中的元素切换6个类名） 12345678910&lt;div id=&quot;demo&quot;&gt; &lt;button v-on:click=&quot;show = !show&quot;&gt; Toggle &lt;/button&gt; &lt;transition&gt; &lt;p v-show=&quot;show&quot;&gt;hello&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; 123456new Vue(&#123; el: &#x27;#demo&#x27;, data: &#123; show: true &#125;&#125;) 六个类名的处理 123456789101112.v-enter-active,.v-leave-active &#123; transition: opacity 0.5s;&#125;.v-enter,.v-leave-to &#123; opacity: 0;&#125;.v-leave,.v-enter-to &#123; opacity: 1;&#125; 自定义类名前缀 如果有多个动画，可以指定name属性 123&lt;transition name=&quot;fade&quot;&gt; &lt;p v-show=&quot;show&quot;&gt;hello&lt;/p&gt;&lt;/transition&gt; 样式 123456789101112.fade-enter-active,.fade-leave-active &#123; transition: opacity 0.5s;&#125;.fade-enter,.fade-leave-to &#123; opacity: 0;&#125;.fade-leave,.fade-enter-to &#123; opacity: 1;&#125; 结合动画使用结构 123456789&lt;!-- 实现一个h1标签的入场和离场的动画 --&gt;&lt;div id=&quot;app&quot;&gt; &lt;button @click=&quot;show = !show&quot;&gt;切换&lt;/button&gt; &lt;transition name=&quot;fade&quot;&gt; &lt;h1 v-show=&quot;show&quot;&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;/transition&gt; &lt;/div&gt; 样式 123456789101112131415161718/* @keyframs自带开始和结束，所以不用设置v-enter、v-enter-to等 */.fade-enter-active &#123; animation: bounce-in 0.5s;&#125;.fade-leave-active &#123; animation: bounce-in 0.5s reverse;&#125;@keyframes bounce-in &#123; 0% &#123; transform: scale(0); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(1); &#125;&#125; 自定义过渡的类名通过给以下attribute赋值，可以自定义过渡类名： enter-class enter-active-class enter-to-class leave-class leave-active-class leave-to-class 123&lt;transition enter-active-class=&quot;in&quot; leave-active-class=&quot;out&quot;&gt; &lt;h1 v-show=&quot;show&quot;&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt;&lt;/transition&gt; 1234567891011121314151617.in &#123; animation: bounce-in 0.5s;&#125;.out &#123; animation: bounce-in 0.5s reverse;&#125;@keyframes bounce-in &#123; 0% &#123; transform: scale(0); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(1); &#125;&#125; 配合animate.css使用 通常不自己写动画，而是采用其他人写好的动画，例如animate.css 12345678910111213141516&lt;link href=&quot;https://cdn.jsdelivr.net/npm/animate.css@3.5.1&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;&lt;div id=&quot;example-3&quot;&gt; &lt;button @click=&quot;show = !show&quot;&gt; Toggle render &lt;/button&gt; &lt;!-- animated 是基础类名，必须写 --&gt; &lt;transition enter-active-class=&quot;animated tada&quot; leave-active-class=&quot;animated bounceOutRight&quot; &gt; &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://bloodthirsty2b.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://bloodthirsty2b.github.io/tags/Vue/"}]},{"title":"Vue自定义指令","slug":"Vue/08- Vue自定义指令","date":"2021-11-10T14:07:39.000Z","updated":"2021-12-20T15:50:24.606Z","comments":true,"path":"2021/11/10/Vue/08- Vue自定义指令/","link":"","permalink":"https://bloodthirsty2b.github.io/2021/11/10/Vue/08-%20Vue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/","excerpt":"Vue自定义指令 某些情况仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。 比如：获取文本框的焦点（autofocus有兼容性问题，vue中默认无法使用，需要用到表单的focus方法，vue推荐将此方法封装成自定义指令）","text":"Vue自定义指令 某些情况仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。 比如：获取文本框的焦点（autofocus有兼容性问题，vue中默认无法使用，需要用到表单的focus方法，vue推荐将此方法封装成自定义指令） 自定义指令 定义一个全局的指令 1234567891011// 语法：Vue.directive(参数1, 参数2)// 参数1：指令的名称// 参数2：指令的配置项（钩子函数）Vue.directive(&#x27;focus&#x27;, &#123; // 当被绑定的元素插入到 DOM 中时… // el: 当前绑定的元素 inserted: function (el) &#123; // 聚焦元素 el.focus() &#125;&#125;) 使用自定义指令 12&lt;!-- 使用时需要添加v-前缀，起名时不要和默认的14个指令冲突 --&gt;&lt;input v-focus&gt; 全局指令与局部指令 定义全局指令 12345Vue.directive(&#x27;focus&#x27;, &#123; inserted(el) &#123; el.focus() &#125;&#125;) 定义局部指令 123456789const vm = new Vue(&#123; directives: &#123; focus: &#123; inserted(el) &#123; el.focus() &#125; &#125; &#125;&#125;) 指令的钩子函数 bind: 只会调用一次，当指令绑定到当前元素上时调用 inserted: 被绑定元素插入父节点时调用 update: 指令的值发生改变的时候 componentUpdated: 指令所在的组件中所有的DOM都更新完成的时候 unbind：只调用一次，指令与元素解绑时调用。 1234567891011121314151617181920212223Vue.directive(&#x27;focus&#x27;, &#123; // 只会调用一次，当指令绑定到当前元素上时调用，可以理解为在内存中绑定。可以用来模拟指令的修饰符 bind (el) &#123; &#125;, // 当前元素被插入到父节点的时候调用(渲染时)，此时可以操作dom inserted (el) &#123; el.focus() &#125;, // 当指令对应的数据发生改变的时候调用，可以用来模拟v-model update () &#123; &#125;, // 会等待当前组件以及子组件的vue内部节点都更新完成后调用 componentUpdated () &#123; &#125;, // 指令与元素解绑的时候调用，例如vue实例执行$destroy方法时 unbind () &#123; &#125;&#125;) 钩子函数的参数所有的钩子函数两个参数el和binding 指令的组成 12v-指令名:指令参数.指令修饰符.指令修饰符 = &quot;指令的值&quot;v-on:click.enter.prevent = &quot;clickFn&quot; 指令的参数 12345678el: 当前元素binding：一个对象，包含以下属性： name：指令名，不包括 v- 前缀。 value：指令的绑定值，例如：v-my-directive=&quot;1 + 1&quot; 中，绑定值为 2。 oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression：字符串形式的指令表达式。例如 v-my-directive=&quot;1 + 1&quot; 中，表达式为 &quot;1 + 1&quot;。 arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 &quot;foo&quot;。 modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 &#123; foo: true, bar: true &#125;。 指令的简写如果配置的钩子函数 bind 和 update 的逻辑是一模一样的，可以这样简写:Vue.directive(指令名, 函数) 123Vue.directive(&#x27;bgcolor&#x27;, function (el, binding) &#123; el.style.backgroundColor = binding.value&#125;)","categories":[{"name":"Vue","slug":"Vue","permalink":"https://bloodthirsty2b.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://bloodthirsty2b.github.io/tags/Vue/"}]},{"title":"Vue-Router的使用","slug":"Vue/07- Vue-Router的使用","date":"2021-11-09T13:52:18.000Z","updated":"2021-12-20T15:50:17.043Z","comments":true,"path":"2021/11/09/Vue/07- Vue-Router的使用/","link":"","permalink":"https://bloodthirsty2b.github.io/2021/11/09/Vue/07-%20Vue-Router%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"Vue-Router的使用SPA - 单页应用程序 SPA： Single Page Application 单页面应用程序 MPA : Multiple Page Application 多页面应用程序 SPA SPA-sample：网易云音乐","text":"Vue-Router的使用SPA - 单页应用程序 SPA： Single Page Application 单页面应用程序 MPA : Multiple Page Application 多页面应用程序 SPA SPA-sample：网易云音乐 优势 传统的多页面应用程序，每次请求服务器返回的都是一整个完整的页面 单页面应用程序只有第一次会加载完整的页面 以后每次请求仅仅获取必要的数据，减少了请求体积，加快页面响应速度，降低了对服务器的压力 SPA更好的用户体验，运行更加流畅 缺点 开发成本高 (需要学习路由) 不利于 SEO 搜索引擎优化 ssr: server side rendering : 服务端渲染 大前端 nodejs 路由介绍 路由 : 是浏览器 URL 中的哈希值( # hash) 与 展示视图内容(组件) 之间的对应规则 简单来说,路由就是一套映射规则(一对一的对应规则), 由开发人员制定规则.- 当 URL 中的哈希值( # hash) 发生改变后,路由会根据制定好的规则, 展示对应的视图内容(组件) 路由的由来 渐进式 &#x3D;&gt;vue &#x3D;&gt; vuer-router (管理组件之间的跳转) 在 web App 中, 经常会出现通过一个页面来展示和管理整个应用的功能. SPA 往往是功能复杂的应用,为了有效管理所有视图内容,前端路由应运而生. vue 中的路由 : 是 hash 和 component 的对应关系, 一个哈希值对应一个组件 vue-router（官方提供）基本使用 安装 1yarn add vue-router 引入路由 文件 12&lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;vue-router.js&quot;&gt;&lt;/script&gt; 创建路由并且挂载到vue实例 123456789const router = new VueRouter()const vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; msg: &#x27;hello vue&#x27; &#125;, router // 从此刻开始，网页路径最后会加上#/&#125;) 具体步骤实现vue的具体步骤 在VueRouter构造函数中配置路由规则（ hash值和组件的映射规则） 提供对应组件 配置路由的显示出口，确定匹配到的组件显示的位置 配置路由规则 12345678910111213141516const router = new VueRouter(&#123; // 配置路由的规则 routes: [ &#123; path: &#x27;/one&#x27;, component: One &#125;, &#123; path: &#x27;/two&#x27;, component: Two &#125;, &#123; path: &#x27;/three&#x27;, component: Three, // 嵌套路由 children: [ &#123; path: &#x27;first&#x27;, component: &#x27;First&#x27;&#125;, &#123; path: &#x27;second&#x27;, component: &#x27;Second&#x27;&#125;, ] &#125; ]&#125;) 提供对应组件（注意在路由中的使用与全局、局部注册的区别） 12345678910111213141516171819const One = &#123; template: ` &lt;div&gt; 子组件 one &lt;/div&gt; `&#125;const Two = &#123; template: ` &lt;div&gt; 子组件 two &lt;/div&gt; `&#125;const Three = &#123; template: ` &lt;div&gt; 子组件 three &lt;/div&gt; &lt;router-link to=&quot;/three/first&quot;&gt;Go to Three.First&lt;/router-link&gt; &lt;router-link to=&quot;/three/second&quot;&gt;Go to Three.Second&lt;/router-link&gt; `&#125;const First = &#123; template: ` &lt;div&gt; 子子组件 first &lt;/div&gt; `&#125;const Second = &#123; template: ` &lt;div&gt; 子子组件 second &lt;/div&gt; `&#125; 配置路由的出口，显示位置 1234&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt; 路由导航12345&lt;!-- 使用 router-link 组件来导航 --&gt;&lt;!-- 通过传入 to 属性指定链接 --&gt;&lt;!-- &lt;router-link&gt; 默认会被渲染成一个 &lt;a&gt; 标签 --&gt;&lt;router-link to=&quot;/one&quot;&gt;Go to One&lt;/router-link&gt;&lt;router-link to=&quot;/two&quot;&gt;Go to Two&lt;/router-link&gt; 导航高亮 点击导航后会给元素添加两个类router-link-exact-active router-link-active 12&lt;a href=&quot;#/one&quot; class=&quot;router-link-exact-active router-link-active&quot;&gt;One&lt;/a&gt;&lt;a href=&quot;#/two&quot; class=&quot;&quot;&gt;Two&lt;/a&gt; 修改方式1 : 直接修改类的样式 12345.router-link-exact-active,.router-link-active &#123; color: red; font-size: 50px;&#125; 修改方式2 : 使用已有类名替换router-link-exact-active和router-link-active 1234567const router = new VueRouter(&#123; routes: [], // 修改默认高亮的a标签的类名 // red 是已经存在过的 linkActiveClass: &#x27;red&#x27; // linkExactActiveClass: &#x27;red&#x27;&#125;) 精确匹配和模糊匹配 精确匹配 : router-link-exact-active 类名 : 只有当 浏览器地址栏中的哈希值 与 router-link 的 to 属性值,完全匹配对,才会添加该类 模糊匹配: router-link-active 类名 : 只要 浏览器地址栏中的哈希值 以 router-link 的 to 属性值开头，就会添加该类名 解决办法 : 加个 exact 123&lt;router-link to=&quot;/&quot; exact&gt; One&lt;/router-link&gt; 注意 : 精确匹配和模糊匹配，只对添加类名这个机制有效，与路由的匹配规则无关！ 路由重定向 解释：将 / 重定向到 /home 1&#123; path: &#x27;/&#x27;, redirect: &#x27;/home&#x27; &#125; 编程式导航 除了使用 &lt;router-link&gt; 创建 a 标签来定义导航链接，我们还可以借助 router 的实例方法，通过编写代码来实现路由的跳转 比如：登录成功了，需要跳转到首页 声明式导航1&lt;router-link to=&quot;/index&quot;&gt;&lt;/router-link&gt; 编程式导航在任意Vue实例内部，都可以通过 $router 访问路由实例。因此可以调用 this.$router.push方法来切换路由。 12345methods: &#123; login() &#123; this.$router.push(&#x27;/index&#x27;) &#125;&#125; 动态路由匹配 有时会需要把某种模式匹配到的所有路由，全都映射到同个组件。比如：文章列表的展示，文章的id不同，展示的文章内容就不同，但是组件是同一个 &#x2F;product&#x2F;1 Product &#x2F;product&#x2F;2 Product &#x2F;product&#x2F;10086 Product 动态路由参数的使用 123456789101112131415const Article = &#123; template: &#x27;&lt;div&gt;文章内容&lt;/div&gt;&#x27;&#125;const router = new VueRouter(&#123; routes: [ // 动态路径参数 以冒号开头 // /article/:路由参数 可以匹配: /article/1 /article/2 /article/xxx // /article/:id1/:id2 可以匹配: /article/1/2 /article/3/4 /article/xxx1/xxx2 &#123; path: &#x27;/article/:路由参数&#x27;, component: Article &#125;， // 如果在动态的路由参数中使用了?,表示该路由参数可选 // 可以匹配 /article /article/1 /article/2 &#123; path: &#x27;/article/:id?&#x27;, component: Article &#125;， ]&#125;) 动态路由参数的获取 123456const User = &#123; template: &#x27;&lt;div&gt;User &#123;&#123; $route.params.路由参数 &#125;&#125;&lt;/div&gt;&#x27;, created() &#123; console.log(this.$route) &#125;&#125; this.$route 内可以获取的内容： fullpath：完整路径 params：动态路由参数 path：不包含查询参数的路径,get请求时为请求内容 query：查询参数","categories":[{"name":"Vue","slug":"Vue","permalink":"https://bloodthirsty2b.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://bloodthirsty2b.github.io/tags/Vue/"}]},{"title":"组件通讯-非父子,slot插槽","slug":"Vue/06- 组件通讯-非父子-slot插槽","date":"2021-11-08T13:51:03.000Z","updated":"2021-12-20T15:50:09.041Z","comments":true,"path":"2021/11/08/Vue/06- 组件通讯-非父子-slot插槽/","link":"","permalink":"https://bloodthirsty2b.github.io/2021/11/08/Vue/06-%20%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF-%E9%9D%9E%E7%88%B6%E5%AD%90-slot%E6%8F%92%E6%A7%BD/","excerpt":"组件通讯-非父子,slot插槽组件通讯-非父子 非父子组件之间通过一个空的Vue实例来传递数据。 1const bus = new Vue(); //bus:公交车 事件总线 核心逻辑 12345组件A给组件B传值：1. 创建一个bus对象2. 组件a触发事件，给组件b发送数据3. 组件b给bus对象注册事件4. 组件b提供函数，用于接收数据","text":"组件通讯-非父子,slot插槽组件通讯-非父子 非父子组件之间通过一个空的Vue实例来传递数据。 1const bus = new Vue(); //bus:公交车 事件总线 核心逻辑 12345组件A给组件B传值：1. 创建一个bus对象2. 组件a触发事件，给组件b发送数据3. 组件b给bus对象注册事件4. 组件b提供函数，用于接收数据 组件A触发bus的事件 1234567&lt;button @click=&quot;send&quot;&gt;表白&lt;/button&gt;methods: &#123; send() &#123; bus.$emit(&quot;get&quot;, this.msg); &#125;&#125; 组件B给bus注册事件 1234567 //rose在组件创建的时候，给bus注册了一个事件created () &#123; bus.$on(&quot;get&quot;, (msg)=&gt;&#123; console.log(&quot;这是rose注册的事件&quot;, msg); this.msg = msg; &#125;);&#125; 组件B通过事件处理程序可以获取到传递的值 1234bus.$on(&quot;get&quot;, (msg)=&gt;&#123; console.log(&quot;这是rose注册的事件&quot;, msg); this.msg = msg;&#125;); 注意点：1. 传递和接受数据的事件必须在同一个总线上 2. 注册的事件和触发的事件必须保持一致 bus是一种通用的组件通讯方案现在有三种组件通讯的方案 12341. 父传子2. 子传父3. 非父子（bus）其实bus方案也适用于父传子和子传父的方案 slot插槽 当组件中某一项需要单独定义，那么就应该使用slot Vue 实现了一套内容分发的 API，将 &lt;slot&gt;元素作为承载分发内容的出口。 匿名插槽slot 除非子组件模板包含至少一个 &lt;slot&gt; 插口，否则父组件的内容将会被丢弃 ,当子组件模板只有一个没有属性的 slot 时，父组件整个内容片段将插入到 slot 所在的 DOM 位置，并替换掉 slot 标签本身。 在组件的模版中定义slot插槽 1234567891011Vue.component(&quot;modal&quot;, &#123; template: ` &lt;div class=&quot;modal&quot;&gt; &lt;p&gt;温馨提示&lt;/p&gt; &lt;div&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; &lt;button&gt;关闭&lt;/button&gt; &lt;/div&gt;`,&#125;); 父组件传值 1234&lt;modal&gt; &lt;h3&gt;你确定要退出系统吗？&lt;/h3&gt;&lt;/modal&gt;&lt;modal&gt;你确定要删除这个内容吗？&lt;/modal&gt; 具名插槽 如果一个组件中想使用多个slot那么此时就应该使用具名插槽。 使用方法 给插槽添加name属性 给插入内容添加slot属性，属性值和插槽的name属性值相同 123456789Vue.component(&quot;modal&quot;, &#123; template: ` &lt;div class=&quot;modal&quot;&gt; &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt; &lt;slot name=&quot;content&quot;&gt;&lt;/slot&gt; &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt; &lt;/div&gt; `,&#125;); 1234567891011&lt;modal&gt; &lt;template v-slot:header&gt; 温馨提示 &lt;/template&gt; &lt;template v-slot:content&gt; 你要删除内容吗 &lt;/template&gt; &lt;template v-slot:footer&gt; &lt;button&gt;关闭&lt;/button&gt; &lt;/template&gt;&lt;/modal&gt; 作用域插槽 在分发内容时，如果需要用到子组件内的数据，需要用到作用域插槽 作用域插槽的使用 给插槽添加name属性和自定义属性 将插入内容用template标签包裹起来，给template标签添加v-slot: 属性值=&quot;obj&quot;，属性值和插槽的name属性值相同。（template只用来分块，不会渲染，具名插槽也可以使用） 自定义属性和属性值会自动添加到一个对象中，这个对象可以通过上面的obj取到 123456789Vue.component(&#x27;modal&#x27;, &#123; template: ` &lt;div&gt; &lt;h3&gt;&lt;slot name=&quot;title&quot;&gt;&lt;/slot&gt;&lt;/h3&gt; &lt;p&gt;&lt;slot name=&quot;content&quot;&gt;&lt;/slot&gt;&lt;/p&gt; &lt;slot name=&quot;confirm&quot; value=&quot;确定&quot;&gt;&lt;/slot&gt; &lt;/div&gt; `&#125;) 1234567891011&lt;modal&gt; &lt;template v-slot:title&gt;温馨提示&lt;/template&gt; &lt;template v-slot:content&gt;你确定也要退出了&lt;/template&gt; &lt;template v-slot:confirm=&quot;scope&quot;&gt; &lt;!-- 若没有传参，那么这个scope会取父组件内的数据 --&gt; &lt;button href=&quot;#&quot;&gt;&#123;&#123;scope.value&#125;&#125;&lt;/button&gt; &lt;/template&gt; &lt;template v-slot:cancel=&quot;scope&quot;&gt; &lt;button href=&quot;#&quot;&gt;&#123;&#123;scope.value&#125;&#125;&lt;/button&gt; &lt;/template&gt;&lt;/modal&gt; 没有指定v-slot的内容会给匿名插槽或v-slot: default","categories":[{"name":"Vue","slug":"Vue","permalink":"https://bloodthirsty2b.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://bloodthirsty2b.github.io/tags/Vue/"}]},{"title":"响应式数据,组件通讯-父传子,子传父","slug":"Vue/05-组件通讯-父传子-子传父","date":"2021-11-07T13:59:47.000Z","updated":"2021-12-20T15:50:00.206Z","comments":true,"path":"2021/11/07/Vue/05-组件通讯-父传子-子传父/","link":"","permalink":"https://bloodthirsty2b.github.io/2021/11/07/Vue/05-%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF-%E7%88%B6%E4%BC%A0%E5%AD%90-%E5%AD%90%E4%BC%A0%E7%88%B6/","excerpt":"响应式数据的说明 响应式数据: 把data中的数据挂到vm身上，vm身上的这个数据其实就是响应式的 一旦数据发生了改变，页面中的内容也会跟着改变","text":"响应式数据的说明 响应式数据: 把data中的数据挂到vm身上，vm身上的这个数据其实就是响应式的 一旦数据发生了改变，页面中的内容也会跟着改变 $set的使用 data中的数据一定要先声明，再使用，动态给对象添加的属性不是响应式的 123456789101112131415161718192021&lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123;person.name&#125;&#125;---&#123;&#123;person.age&#125;&#125;---&#123;&#123;person.gender&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; person: &#123; name: &#x27;zs&#x27;, age: 18 &#125; &#125; &#125;)&lt;/script&gt;// 动态给data中添加的数据是无效的// 在vue实例创建的时候，会把data中的数据绑定到vm上，所以data中的数据是响应的// 但是动态绑定的数据不是响应是的。vm.person.gender = &#x27;男&#x27; 如果想要动态绑定数据，并且是响应式的,需要使用vm.$set方法 1this.$set(this.person, &#x27;gender&#x27;, &#x27;男&#x27;) 结论： 如果是对象，动态给对象添加或者删除一个属性，vue是检测不到的，所以不是响应的，如果想用动态添加的数据是响应式，需要使用Vue.set(obj, key, value) vm.$set(obj, key ,value) 如果是数组，通过数组的下标或者是数组的长度，vue也是检测不到，所以操作也不是响应式的 使用Vue.set方法 数组的变异的方法，这个方法会改变原数组，能够触发vue的更新。 异步DOM更新以及$nextTick的说明在vue中数据发生了改变，DOM中的数据也会跟着发生改变，但是这个过程是异步的 vue的数据发生改变之后，DOM不会立即更新，会等到下一次渲染工作执行的时候才会更新DOM 目的：为了提高渲染的性能 123456789101112clickFn () &#123; // 数据变化了， view中的内容也要跟着变 this.msg = &#x27;你好啊，vue1&#x27; this.msg = &#x27;你好啊，vue2&#x27; this.msg = &#x27;你好啊，vue3&#x27; this.msg = &#x27;你好啊，vue4&#x27; this.msg = &#x27;你好啊，vue5&#x27; // 为什么：DOM操作是非常消耗性能的，如果每次操作数据，都立即更新DOM，无疑性能会非常的低，所以vue中会等待数据都修改完成 let result = document.querySelector(&#x27;p&#x27;).innerHTML console.log(result)&#125; $nextTick方法会在DOM更新之后执行 1234567// 在实际开发中，有可能需要在数据改变之后，获取到更新之后的DOM数据// 这个时候可以使用 $nextTick函数// 当vue更新完DOM后，会自动调用$nextTick函数，确保在这个函数中可以获取到DOM结构是最新的this.$nextTick(function() &#123; let result = document.querySelector(&#x27;p&#x27;).innerHTML console.log(result)&#125;) 组件化开发组件的概念 组件 (Component) 是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素，Vue.js 的编译器为它添加特殊功能。 在vue中都是组件化开发的，组件化开发就是把一个完整的页面分割成一个一个的小组件。 组件的优点： 容易维护 复用 123vue组件分为全局组件和局部组件全局组件：在所有的vue实例中都能使用局部组件：只有在当前vue实例中能够使用 全局组件 定义 123456// 要注册一个全局组件，可以使用 Vue.component(tagName, options)。// 注册一个全局的组件// Vue.component(tagName, options)Vue.component(&quot;hello&quot;, &#123; template: &#x27;&lt;h3&gt;我是全局组件！&lt;/h3&gt;&#x27;&#125;); 使用 1234全局组件可以在所有的实例中使用&lt;div id=&quot;app&quot;&gt; &lt;hello&gt;&lt;/hello&gt;&lt;/div&gt; 注意点：组件的模板有且仅有一个根元素 12template: &#x27;&lt;h3&gt;我是全局组件！&lt;/h3&gt;&lt;p&gt;有两个根元素&lt;/p&gt;&#x27;; // 错误的用法template: &#x27;&lt;div&gt;&lt;h3&gt;我是全局组件！&lt;/h3&gt;&lt;p&gt;有两个根元素&lt;/p&gt;&lt;/div&gt;&#x27;; 如果有很多的内容，template可以使用字符串模版 12345678Vue.component(&quot;my-button&quot;, &#123; template: ` &lt;div&gt; &lt;h1&gt;我是一个标题&lt;/h1&gt; &lt;p&gt;我是一个段落&lt;/p&gt; &lt;/div&gt; `&#125;); 局部组件1234567891011// 在vue实例的内部，通过components属性来定义局部组件components: &#123; &quot;my-button&quot;: &#123; template: ` &lt;div&gt; &lt;h1&gt;我是一个标题&lt;/h1&gt; &lt;p&gt;我是一个段落&lt;/p&gt; &lt;/div&gt; ` &#125;&#125; 组件是特殊的vue实例 可以将组件看成是一个vue的实例，因此，在vue实例中能配置的属性，在组件中依旧能够配置。 比如：data,method,watch,computed,钩子函数等 注意：组件中data属性必须是一个函数，返回值才是data的数据 123456789101112131415161718192021// 可以把组件看成一个vue实例Vue.component(&quot;my-button&quot;, &#123; template: ` &lt;div&gt; &lt;h1 @click=&quot;add&quot;&gt;我是一个标题&lt;/h1&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;/div&gt; `, // 组件可以通过data属性提供组件自己的数据，注意，组件的data参数必须是一个函数，不能是用一个对象。 data() &#123; return &#123; msg: &#x27;hello vue&#x27; &#125;; &#125;, methods: &#123; add() &#123; console.log(&quot;哈哈&quot;); &#125; &#125;&#125;); 组件是一个独立封闭的个体，组件之间的数据是无法相互使用的 123456789101112131415161718192021var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; outer: &#x27;我是实例的数据&#x27; &#125;,&#125;);//可以把组件看成一个vue实例Vue.component(&quot;my-button&quot;, &#123; template: ` &lt;div&gt; &lt;p&gt;&#123;&#123;inner&#125;&#125;&lt;/p&gt; // 正确，组件可以使用自己的数据 &lt;p&gt;&#123;&#123;outer&#125;&#125;&lt;/p&gt; // 报错，组件无法使用其他组件的数据 &lt;/div&gt; `, data() &#123; return &#123; inner: &#x27;我是组件的数据&#x27; &#125;; &#125;&#125;); 组件通讯 因为组件是一个独立的个体，组件无法使用到外部的数据 但是在真实开发中，多个组件之间是需要相互使用彼此的数据的，因此需要使用组件通讯的技术，让组件之间能够相互传值。 组件通讯分为三类 父组件传递值给子组件 子组件传递值给父组件 非父子组件之间的传值 组件通讯-父传子 定义两个组件 1234567891011121314151617181920212223242526Vue.component(&quot;parent&quot;, &#123; template: ` &lt;div class=&quot;parent&quot;&gt; &lt;p&gt;这是父组件&lt;/p&gt; &lt;son&gt;&lt;/son&gt; &lt;/div&gt; `, data () &#123; return &#123; car: &#x27;玛莎拉蒂&#x27;, month: 1000000 &#125; &#125;&#125;);Vue.component(&quot;son&quot;, &#123; template: ` &lt;div class=&quot;son&quot;&gt; &lt;p&gt;这是子组件&lt;/p&gt; &lt;/div&gt; `&#125;);&lt;div id=&quot;app&quot;&gt; &lt;parent&gt;&lt;/parent&gt;&lt;/div&gt; 组件的通讯 12345678910111213141. 在父组件的模版中，给子组件增加一个自定义的属性。&lt;son :car=&quot;car&quot;&gt;&lt;/son&gt;2. 子组件通过props属性进行接收// 接收父组件传递过来的值props: [&#x27;car&#x27;]3. 子组件使用父组件传递过来的值template: `&lt;div class=&quot;son&quot;&gt; &lt;p&gt;这是子组件&lt;/p&gt; &lt;p&gt;这是父组件传递过来的值----&#123;&#123;car&#125;&#125;&lt;/p&gt;&lt;/div&gt;`, 注意：props负责获取父组件的传递过来的，props中的值是只读的，不允许修改 组件通讯-子到父 参考链接：https://blog.csdn.net/jsxiaoshu/article/details/79058940 整体思路 121. 父组件给子组件注册一个自定义事件2. 子组件触发这个自定义事件，触发事件时把数据传递给父组件 父组件给子组件注册事件 1234567&lt;son @fn=&#x27;getData&#x27;&gt;&lt;/son&gt;methods: &#123; // 父组件中定义了一个方法，用于获取数据 getData () &#123; console.log(&quot;父组件中提供的方法&quot;); &#125;&#125; 子组件触发自定义事件，并且把要传递的数据作为参数进行传递 12// $emit可以出发当前实例的事件this.$emit(&#x27;getData&#x27;, this.car); 父组件获取值 123456methods: &#123; getData (skill) &#123; console.log(&quot;父组件中提供的方法&quot;, skill); this.skill = skill; &#125;&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://bloodthirsty2b.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://bloodthirsty2b.github.io/tags/Vue/"}]},{"title":"Vue计算属性、监视、生命周期、钩子函数","slug":"Vue/03- Vue计算属性、监视、生命周期、钩子函数","date":"2021-11-06T13:47:45.000Z","updated":"2021-12-20T15:49:52.031Z","comments":true,"path":"2021/11/06/Vue/03- Vue计算属性、监视、生命周期、钩子函数/","link":"","permalink":"https://bloodthirsty2b.github.io/2021/11/06/Vue/03-%20Vue%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E3%80%81%E7%9B%91%E8%A7%86%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%81%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0/","excerpt":"Vue计算属性、监视、生命周期、钩子函数计算属性 将属性计算的过程封装到一个函数中，使用计算属性是会自动调用函数，函数的返回值就是计算属性的值 优点： 可维护性高 计算属性比直接用调用函数来使用性能要高（有缓存） 只有相关的属性发生了变化才会重新计算","text":"Vue计算属性、监视、生命周期、钩子函数计算属性 将属性计算的过程封装到一个函数中，使用计算属性是会自动调用函数，函数的返回值就是计算属性的值 优点： 可维护性高 计算属性比直接用调用函数来使用性能要高（有缓存） 只有相关的属性发生了变化才会重新计算 基本使用1234567891011121314var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; n1:&#x27;&#x27;, n2:&#x27;&#x27; &#125;, //n3依赖与n1和n2的值，当n1 和 n2发生改变的时候，这个函数就会执行。 //返回值就是n3的值 computed: &#123; n3()&#123; return +this.n1 + +this.n2; &#125; &#125; &#125;); 计算属性是基于它们的依赖项进行缓存的 如果页面中需要使用多次计算属性的值，只会计算一次，计算属性只有在它的相关依赖发生改变时才会重新求值。 计算属性不能与data中的属性同名，因为无论是data中的属性还是计算属性，最终都是挂载到vm上的 完整形式123456789101112131415161718// 上面的计算属性只设置了getter而没有setter，所以在赋值时会报错var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; n1:&#x27;&#x27;, n2:&#x27;&#x27; &#125;, computed: &#123; n3: &#123; get() &#123; return +this.n1 + +this.n2; &#125;, set(value) &#123; this.n2 = value - +this.n1; &#125; &#125; &#125; &#125;); watch监视数据的变化 vue实例中提供了一个watch属性，用于监听vue实例中的属性的变化。 watch对应了一个对象，键是观察的属性，值是对应的回调函数。 基本使用 基本使用 123456// watch对象: 用于监视数据的变化watch: &#123; 监视的数据对象: function(当前值, 上一次的值) &#123; dosomething... &#125;&#125; 表单校验效果 1234567891011watch: &#123; // 监视msg，只要msg属性的值发生改变，function就会执行 // value: 当前值 oldValue:上一次的值 msg: function(value) &#123; if (value.length &gt;=3 &amp;&amp; value.length &lt;= 6) &#123; this.tips = &#x27;正确&#x27; &#125; else &#123; this.tips = &#x27;密码格式不正确&#x27; &#125; &#125;&#125; 监视对象 监视对象的时候，需要加上deep: true 为了发现对象内部值的变化，可以在选项参数中指定 deep: true 如果是一个对象，无法监听到对象内部值的变化 1234567891011121314151617181920&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; user: &#123; name:&#x27;zs&#x27;, age: 18 &#125; &#125;, watch: &#123; user: function(newValue, oldValue) &#123; console.log(newValue, oldValue); // 侦听不到 &#125; &#125; &#125;);&lt;/script&gt;&lt;input type=&quot;text&quot; v-model=&quot;user.name&quot;&gt;&lt;input type=&quot;text&quot; v-model=&quot;user.age&quot;&gt; 对象需要加上deep（数组不需要），同时会多消耗一些性能，参考 https://cn.vuejs.org/v2/api/#vm-watch 12345678910watch: &#123; user: &#123; deep: true, handler: function(newValue, oldValue) &#123; // 注意：如果监听的是对象，新值与旧值都是【相同的】，因为指向了同一个对象。 // 获取的newValue是整个对象 console.log(newValue.age, newValue.name); &#125; &#125;&#125; immediate 属性，页面刚加载就执行一次 123456789watch: &#123; user: &#123; deep: true, immediate:true, handler: function(curr, old) &#123; console.log(curr.age, curr.name); &#125; &#125;&#125; 生命周期与钩子函数生命周期介绍 vue生命周期钩子函数 简单说：一个实例从开始到最后消亡所经历的各种状态，就是一个实例的生命周期 实例生命周期函数的定义：从组件被创建，到组件挂载到页面上运行，再到页面关闭组件被卸载，这三个阶段总是伴随着组件各种各样的事件，那么这些事件，统称为组件的生命周期函数 生命周期的钩子函数：框架提供的函数，能够让开发人员的代码，参与到组件的生命周期中。也就是说，通过钩子函数，就可以控制组件的行为 注意：vue在执行过程中会自动调用生命周期钩子函数，我们只需要提供这些钩子函数即可 注意：钩子函数的名称都是固定的 123456789101112131415161718191. vue的初始化阶段①创建vue实例②基本初始化：初始化生命周期和时间③初始化数据：a. 注入：将data中的数据，注入到vm实例身上b. 响应式：利用defineProperty进行数据劫持，实现数据响应④指定视图a. 若指定el，则以el为视图b. 若不指定el，则等待vm.$mount函数的调用指定视图⑤指定模板a. 如果没有配置template，就会将el的outerHTML作为模板b. 如果制定了template，就会无视el将template作为模板⑥将模板和数据相结合，生成结构，用这个结构替换el视图2. vue的数据更新阶段如果数据发生了变化，那么使用虚拟dom进行差异化更新（尽可能复用之前的结构）3. vue实例销毁阶段只要vm.$destroy方法被调用，vue实例就会被销毁。同时释放掉与vue相关的一些资源，事件监听，子组件等。之后data中的数据再变化就不会更新视图了 钩子函数 - beforeCreate() 说明：在实例初始化之后，数据观测 (data observer) 和 event&#x2F;watcher 事件配置之前被调用 注意：此时，无法获取 data中的数据、methods中的方法 钩子函数 - created() 注意：这是一个常用的生命周期，可以调用methods中的方法、改变data中的数据 vue实例生命周期 参考1 vue实例生命周期 参考2 使用场景：发送请求获取数据 钩子函数 - beforeMounted() 说明：在挂载开始之前被调用 钩子函数 - mounted() 说明：此时，vue实例已经挂载到页面中，可以获取到el中的DOM元素，进行DOM操作 钩子函数 - beforeUpdated() 说明：数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。 钩子函数 - updated() 说明：组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。 钩子函数 - beforeDestroy() 说明：实例销毁之前调用。在这一步，实例仍然完全可用。 使用场景：实例销毁之前，执行清理任务，比如：清除定时器等 钩子函数 - destroyed() 说明：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 过滤器 过滤器可以将处理字符串的过程封装，以便将来复用。多用于处理时间戳（moment插件）。 1. 定义过滤器123456Vue.filter(过滤器的名字, function(value) &#123; // 在这里处理字符串 return 返回的结果&#125;)参数一：过滤器的名字参数二：字符串的处理函数，返回的结果作为使用过滤器的结果 2. 使用过滤器1&#123;&#123; msg | 过滤器名字 &#125;&#125; 3. 过滤器可以被传参123456789101112// 使用&#123;&#123; msg | 过滤器名字(param1, param2, ...) &#125;&#125;/* // 参数一：msg，待处理的字符串 // 参数二、三：param1，传入的参数，可以在回调函数中使用*/// 定义Vue.filter(过滤器的名字, 回调函数function(value, param1 = 默认值, ...) &#123; return 返回的结果&#125;) 4. 全局过滤器和局部过滤器 全局过滤器：在全局中使用 Vue.filter(...) 局部过滤器：在创造实例中使用 （和data，methods等相同）12345filters: &#123; filter1(value) &#123; return ... &#125;&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://bloodthirsty2b.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://bloodthirsty2b.github.io/tags/Vue/"}]},{"title":"Vue指令","slug":"Vue/02- Vue指令","date":"2021-11-05T13:46:42.000Z","updated":"2021-12-20T15:49:24.448Z","comments":true,"path":"2021/11/05/Vue/02- Vue指令/","link":"","permalink":"https://bloodthirsty2b.github.io/2021/11/05/Vue/02-%20Vue%E6%8C%87%E4%BB%A4/","excerpt":"vue指令 解释：指令 (Directives) 是带有 v- 前缀的特殊属性，可以在html标签中使用，可以看成特殊的html属性 作用：指令提供了一些特殊的功能，当指向绑定到标签上时，可以给标签增加一些特殊的行为","text":"vue指令 解释：指令 (Directives) 是带有 v- 前缀的特殊属性，可以在html标签中使用，可以看成特殊的html属性 作用：指令提供了一些特殊的功能，当指向绑定到标签上时，可以给标签增加一些特殊的行为 一、v-bind 描述：插值表达式不能用在html的属性上，如果想要动态的设置html元素的属性，需要使用v-bind指令 作用：动态的设置html的属性 语法：v-bind:title=&quot;msg&quot; 简写：:title=&quot;msg&quot; 1234&lt;!-- 完整语法 --&gt;&lt;a v-bind:href=&quot;url&quot;&gt;&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a :href=&quot;url&quot;&gt;&lt;/a&gt; 样式处理-class和style 使用方式：v-bind:class=&quot;表达式&quot; 或 :class=&quot;表达式&quot; 表达式的类型：字符串、数组、对象（重点） 语法： 12345678910111213--- class ---&lt;!-- 1 --&gt;&lt;!-- 常用 --&gt;&lt;div v-bind:class=&quot;&#123; active: true &#125;&quot;&gt;&lt;/div&gt; ===&gt;&lt;div class=&quot;active&quot;&gt;&lt;/div&gt;&lt;!-- 2 --&gt;&lt;div :class=&quot;[&#x27;active&#x27;, &#x27;text-danger&#x27;]&quot;&gt;&lt;/div&gt; ===&gt;&lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt;&lt;!-- 3 --&gt;&lt;div v-bind:class=&quot;[&#123; active: true &#125;, errorClass]&quot;&gt;&lt;/div&gt; ===&gt;&lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt; 1234567--- style ---&lt;!-- 1 --&gt;&lt;div v-bind:style=&quot;&#123; color: activeColor, &#x27;font-size&#x27;: fontSize + &#x27;px&#x27; &#125;&quot;&gt;&lt;/div&gt;&lt;!-- 2 将多个 样式对象 应用到一个元素上--&gt;&lt;!-- baseStyles 和 overridingStyles 都是对象 --&gt;&lt;div v-bind:style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt; 二、v-modelv-model: https://cn.vuejs.org/v2/guide/forms.html 作用：在表单元素上创建双向数据绑定，vue解析时会忽略另外设置的value、checked等初始值 说明：监听用户的输入事件以更新数据 12&lt;input type=&quot;text&quot; v-model=&quot;message&quot; placeholder=&quot;edit me&quot;&gt;&lt;p&gt;Message is: &#123;&#123; message &#125;&#125;&lt;/p&gt; 双向数据绑定 双向数据绑定：将DOM与Vue实例的data数据绑定到一起，彼此之间相互影响 数据的改变会引起DOM的改变 DOM的改变也会引起数据的变化 视图到数据的原理：对于input可以使用input事件（html5） 数据到视图的原理：数据劫持，Object.defineProperty中的get和set方法 getter和setter：访问器 作用：指定读取或设置对象属性值的时候，执行的操作 注意：Object.defineProperty方法是ES5中提供的，IE8浏览器不支持这个方法。因此，Vue不支持IE8及其以下版本浏览器 Vue - 深入响应式原理 MDN - Object.defineProperty() 12345678// 语法var obj = &#123;&#125;Object.defineProperty(obj, &#x27;msg&#x27;, &#123; // 设置 obj.msg 执行的操作 set: function () &#123;&#125;, // 读取 obj.msg 执行的操作 get: function () &#123;&#125;&#125;) Vue双向绑定的极简实现 剖析Vue原理&amp;实现双向绑定MVVM 12345678910111213141516171819202122232425262728&lt;!-- 示例 --&gt;&lt;input type=&quot;text&quot; id=&quot;txt&quot; /&gt;&lt;span id=&quot;msgBox&quot;&gt;&lt;/span&gt;&lt;script&gt;const txt = document.getElementById(&#x27;txt&#x27;)const msgBox = document.getElementById(&#x27;msgBox&#x27;)const obj = &#123;&#125;// 给对象obj添加msg属性，并设置setter访问器Object.defineProperty(obj, &#x27;msg&#x27;, &#123; // 设置 obj.msg 执行的操作 set: function (curVal) &#123; txt.value = curVal msgBox.innerText = curVal // 但是这样不能直接使用this.msg设置msg的值，会造成递归。所以使用一个其他的值来代替msg存取数据 this._msg = curVal &#125;, get: function () &#123; return this._msg &#125;&#125;)// 监听文本框的改变txt.addEventListener(&#x27;input&#x27;, function (event) &#123; obj.msg = this.value&#125;)&lt;/script&gt; 三、v-on 作用：绑定事件 语法：v-on:click=&quot;say&quot; or v-on:click=&quot;say(&#39;参数&#39;, $event)&quot; 简写：@click=&quot;say&quot; 说明：绑定的事件从methods中获取 123456&lt;!-- 完整语法 --&gt;&lt;a v-on:click=&quot;doSomething&quot;&gt;&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a @click=&quot;doSomething&quot;&gt;&lt;/a&gt;&lt;!-- 又要传参又要拿到事件对象，用$event代替事件对象传入 --&gt;&lt;a @click=&quot;doSomething(xxx, $event)&quot;&gt;&lt;/a&gt; 事件修饰符 .stop 阻止冒泡，调用 event.stopPropagation() .prevent 阻止默认行为，调用 event.preventDefault() .capture 添加事件侦听器时使用事件捕获模式 .self 只当事件在该元素本身（比如不是子元素）触发时，才会触发事件 .once 事件只触发一次 按键修饰符在监听键盘事件时，我们经常需要检查常见的键值。Vue 允许为 v-on 在监听键盘事件时添加按键修饰符： .按键码(例如enter为13，也就是.13，不过可读性差且有兼容性问题，不合适) 123456789.enter.tab.delete (捕获“删除”和“退格”键).esc.space.up.down.left.right 自定义： Vue.config.keyCodes.自定义属性名 = 13 （把.自定义属性名当.enter使用） 四、v-text 解释：更新元素的 textContent或innerText。如果要更新部分的 textContent ，应该使用 &#123;&#123; Mustache &#125;&#125; 插值。 1&lt;h1 v-text=&quot;msg&quot;&gt;&lt;/h1&gt; 五、v-html 解释：更新DOM对象的 innerHTML,html标签会生效 1&lt;h1 v-html=&quot;msg&quot;&gt;&lt;/h1&gt; 在网站上动态渲染任意 HTML 是非常危险的，因为容易导致 XSS 攻击。只在可信内容上使用 v-html，永不用在用户提交的内容上。 六、v-if 和 v-show 条件渲染 v-if：根据表达式的值的真假条件，销毁或重建元素 v-show：根据表达式之真假值，切换元素的 display CSS 属性（display属性） 区别： 传值为false时，v-show依然会创建出元素并设置display: none；而v-if完全不会创建元素 如果需要频繁切换盒子的显示和隐藏，那么适合用v-show；如果需要多个盒子而只显示一个，那么适合用v-if 总结：v-if初始性能消耗可能较低，且不适合反复切换；v-show初始性能消耗高，但适合反复切换 七、v-else与v-else-if v-else 和 v-else-if 必须和 v-if 紧挨着使用，中间不能出现其他元素 八、v-for 作用：基于源数据多次渲染元素或模板块（谁需要循环渲染，就给谁加） 12345678910&lt;!-- 1 基础用法 --&gt;&lt;div v-for=&quot;item in items&quot;&gt; &#123;&#123; item.text &#125;&#125;&lt;/div&gt;&lt;!-- item 为当前项，index 为索引 --&gt;&lt;p v-for=&quot;(item, index) in list&quot;&gt;&#123;&#123;item&#125;&#125; -- &#123;&#123;index&#125;&#125;&lt;/p&gt;&lt;!-- item 为值，key 为键，index 为索引 --&gt;&lt;p v-for=&quot;(item, key, index) in obj&quot;&gt;&#123;&#123;item&#125;&#125; -- &#123;&#123;key&#125;&#125;&lt;/p&gt;&lt;p v-for=&quot;item in 10&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/p&gt; key属性 推荐：使用 v-for 的时候提供 key 属性，能够提升列表渲染的性能，也能避免部分bug（例如单选和复选框只复用标签不复用value的常见bug） 说明：使用 key，vue会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。如果不用key的话，例如渲染列表时会在浏览器解析中根据列表元素下标的改变而对应的去视图中修改对应下标列表内容，如图： vue key官网说明 vue key属性的说明 123&lt;div v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt; &lt;!-- 内容 --&gt;&lt;/div&gt; 九、v-pre（提升性能） 说明：跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。（例如展示vue源码以及跳过静态内容解析以提升性能） 1&lt;span v-pre&gt;&#123;&#123; 这部分内容将不会被编译 &#125;&#125;&lt;/span&gt; 十、v-once（提升性能） 说明：只渲染元素和组件一次。随后的重新渲染，元素&#x2F;组件及其所有的子节点将被视为静态内容在解析时 跳过。这可以用于优化更新性能，不过需要修改时会很麻烦（因为不会报错提示）。 1&lt;span v-once&gt;这部分内容将不会被改变: &#123;&#123;msg&#125;&#125;&lt;/span&gt; 十一、v-cloak 作用：用于解决插值表达式的闪烁问题，但由于组件化开发中使用webpack打包编译后会现在内存中先将各个组件渲染完成，最终将所有组件完成展示，不再有这个问题，所以v-cloak用处不大 特点：添加到元素上之后会多一个v-cloak属性，vue完成渲染后该属性会自动被移除 用法：配合其特点使用css选择器 [v-cloak]&#123;display: none;&#125; 隐藏元素","categories":[{"name":"Vue","slug":"Vue","permalink":"https://bloodthirsty2b.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://bloodthirsty2b.github.io/tags/Vue/"}]},{"title":"webpack的基本配置","slug":"webpack/webpack的基本配置","date":"2021-11-04T14:23:23.000Z","updated":"2021-12-20T15:49:11.184Z","comments":true,"path":"2021/11/04/webpack/webpack的基本配置/","link":"","permalink":"https://bloodthirsty2b.github.io/2021/11/04/webpack/webpack%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/","excerpt":"webpack的基本配置 webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler) webpack中文网 webpack官网","text":"webpack的基本配置 webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler) webpack中文网 webpack官网 webpack做了什么 语法转换 less&#x2F;sass转换成css ES6转换成ES5 typescript转换成js html&#x2F;css&#x2F;js代码的压缩与合并（打包） webpack可以在开发期间提供一个开发环境 自动开启浏览器 自动监视文件变化 自动刷新浏览器 项目一般都需要经过webpack打包之后才上线。 webpack模块说明和nodejs不同，webpack会把所有的资源都当成模块 css js 图片 字体图标 webpack给前端开发提供了模块化的开发环境 对于js文件，webpack中支持AMD(seajs)、CMD(requirejs)、commonJS(node)、ES6模块化等语法 有了webpack，我们可以在前端代码中使用任意的模块化语法 可以在浏览器中使用nodejs的模块化语法const $ = require(&#39;jquery&#39;) webpack 4.x 使用步骤1. 创建项目目录 dist 打包后的文件目录 src 项目源代码 2. 项目初始化 123yarn init -y# 或npm init -y 3. 安装 webpack 和 webpack-cli 123yarn add webpack webpack-cli -D# 或者npm i webpack webpack-cli --save-dev save 用来记录到package.json内的dependencies对象中 save-dev 用来记录到package.json内的devDependencies对象中 dependencies和devDependencies的区别在于前者是项目中依赖的包；而后者只是开发中依赖的包，上线后不再需要。如果装错了位置只需要在package.json中移动一下就好。 yarn中不能使用–save-dev 4. 配置package.json中的scripts 123&quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack ./src/index.js -o ./dist/bundle.js --mode=development&quot;&#125;, “scripts” 作用是将bash语句简写成一个自定义脚本命令，执行方法 npm run 命令名 打包语法: webpack 需要打包的文件路径 -o 打包后的文件路径 --mode=development的作用是以未压缩模式打包，压缩模式应该为--mode=production，不过一旦配置的内容复杂起来，就不会在这里写，这里只写webpack。所有配置内容放在当前目录下的webpack.config.js中。 5. 使用命令 123yarn build # 就可以使用webpack进行打包了# 或者npm run build npm中，start和stop命令名可以在执行时省略run yarn中，所有命令都可以省略run 配置文件-webpack.config.js 如果所有的参数都拼接到webpack-dev-server的后面，会非常的麻烦，因此可以提供webpack.config.js来进行配置 在项目的根目录下面新建webpack.config.js文件 123456789101112131415// 这是一个nodejs文件const path = require(&#x27;path&#x27;)module.exports = &#123; // 设置入口文件，打包哪个文件 entry: path.join(__dirname, &#x27;index.js&#x27;), // 设置出口，打包到哪里去 output: &#123; // 设置输出目录，必须是绝对路径 path: path.join(__dirname, &#x27;dist&#x27;), // 输出文件 filename: &#x27;bundle.js&#x27; &#125;&#125; 执行命令 1webpack // webpack会自动读取当前目录下的配置文件 模式的配置 123456module.exports = &#123; // 设置打包的模式 // production // development mode: &#x27;production&#x27;&#125; webpack-插件：html-webpack-plugin webpack 有着丰富的插件接口(rich plugin interface)。webpack 自身的多数功能都使用这个插件接口。这个插件接口使 webpack 变得极其灵活。 html-webpack-plugin插件就是用来处理html文件的 安装 1yarn add html-webpack-plugin -D 引入 1var HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;); 按文档配置 webpack插件 12345678// 插件配置内容module.exports = &#123; plugins: [ new HtmlWebpackPlugin(&#123; template: path.join(__dirname, &#x27;src&#x27;, &#x27;index.html&#x27;) &#125;) ],&#125; webpack-loaders webpack 可以使用 loader 来预处理文件。允许打包除 JavaScript 之外的任何静态资源。这样就可以使用 Node.js 来很简单地编写自己的 loader。 css-loader 处理css文件 安装 1yarn add style-loader css-loader -D 配置 index.js 1require(&#x27;./css/index.css&#x27;) webpack.config.js 12345678910111213module: &#123; // loader的规则 rules: [ &#123; // 正则表达式，用于匹配所有的css文件 test: /\\.css$/, // css-loader只能让webpack解析css文件 // style-loader才能在html中动态创建style标签作用于页面 // loader的使用顺序是从右往左的 use: [&quot;style-loader&quot;, &quot;css-loader&quot;] &#125; ]&#125;, less-loader 处理less文件 安装 less-loader 和 less 1npm install --save-dev less-loader less 配置 123456&#123; // 匹配所有的less文件 test: /\\.less$/, // 注意除了需要less-loader以外，还需要css-loader和style-loader use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;less-loader&quot;]&#125; file-loader 处理图片文件 file-loader可以处理任意文件，当然也可以处理图片。同时最好对每个文件单独配置。 安装 1npm install --save-dev file-loader 配置 12345&#123; // 配置图片加载 test: /\\.(png|jpg|gif)$/, use: &quot;file-loader&quot;&#125; file-loader会以单独文件的形式打包到dist目录，每个图片独立存在，请求次数会变多 url-loader 处理图片文件 url-loader与file-loader一样，也可以处理图片，但是url-loader可以以base64编码的方式处理图片，这样就可以打包到bundle.js中。 安装 1npm install --save-dev url-loader 设置limit参数 注意：设置了url-loader后就不要再设置file-loader了，超过了limit后会自动使用file-loader 12345678910111213&#123; // 配置图片加载 test: /\\.(png|jpg|gif)$/, use: [ &#123; loader: &#x27;url-loader&#x27;, options: &#123; // 限定文件大小，注意：如果文件超出了大小，会自动调用file-loader，所以安装url-loader都要安装file-loader limit: 8192 // 8*1024B &#125; &#125; ]&#125; base64和精灵图的区别： base64：优点是可以减少网络请求，缺点是会增加文件30%的大小，一般只用于小图片的转换 精灵图：同样可以减小网络请求，缺点是不好修改和使用 url-loader 处理字体图标文件 处理字体图标文件与处理图片一模一样 配置 1234567891011121314&#123; // 配置字体图标加载 test: /\\.(woff|woff2|eot|ttf|otf|svg)$/, use: [ &#123; loader: &#x27;url-loader&#x27;, options: &#123; // 限定文件大小 limit: 8192 &#125; &#125; ]&#125; babel-loader 处理高版本的ES语法介绍Babel 是一个 JavaScript 编译器。 官网 中文网 babel可以把最新版本的语法编译成浏览器能够兼容的代码（ES5） 使用 安装（注意webpack版本号） 1npm install -D babel-loader @babel/core @babel/preset-env 配置 12345678&#123; test: /\\.js$/, // 不解析node_modules(npm)文件夹以及bower_components(bower)文件夹内的内容 exclude: /(node_modules|bower_components)/, use: &#123; loader: &#x27;babel-loader&#x27; &#125;&#125; webpack-dev-server的使用 在开发期间，会用到webpack的一个辅助包：webpack-dev-server，它会在内存中打包，并会根据源文件的修改而更新包，内存中读写速度更快而且比手动打包性能消耗更小。 官网 webpack-dev-server 的作用 自动开启http服务 自动打开浏览器 自动监视文件的变化 引入，每次修改代码，都会重新打包 基本使用 安装 1npm install --save-dev webpack-dev-server 配置(package.json) 1234// webpack-dev-server提供了一个简单的服务器，并且能够实时重新加载&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server&quot;&#125; 其他配置(webpack.config.js) 123456devServer: &#123; // 端口号 port: 9999, // 自动打开浏览器 open: true,&#125; 热更新的说明 开启 1234devServer: &#123; // 热更新，差异化更新 hot: true&#125; 热更新有时会出现监视不到文件更新的情况（例如只用插件加载的html），这时需要手动刷新或者： 12345678var webpack = require(&quot;webpack&quot;);plugins: [ new HtmlWebpackPlugin(&#123; template: path.join(__dirname,&quot;src&quot;, &#x27;index.html&#x27;) &#125;), new webpack.HotModuleReplacementPlugin()], 热更新与dev-server模式不会在生产环境下用，生产环境还是需要使用 npm run build","categories":[{"name":"webpack","slug":"webpack","permalink":"https://bloodthirsty2b.github.io/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://bloodthirsty2b.github.io/tags/webpack/"}]},{"title":"NProgress的使用","slug":"plugin/NProgress的使用","date":"2021-11-04T14:21:55.000Z","updated":"2021-12-20T15:59:27.082Z","comments":true,"path":"2021/11/04/plugin/NProgress的使用/","link":"","permalink":"https://bloodthirsty2b.github.io/2021/11/04/plugin/NProgress%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"NProgress插件的使用 nprogress插件是一个适用于ajax应用的轻量级的进度条插件。 使用步骤一、 引入12&lt;link rel=&#x27;stylesheet&#x27; ref=&#x27;nprogress.css&#x27;/&gt;&lt;script src=&#x27;nprogress.js&#x27;&gt;&lt;/script&gt; 二、语法1234567//引入了nprogress.js文件后，就有了一个全局对象NProgress对象//开启进度条NProgress.start();//关闭进度条NProgress.done();// 配置禁用小圆环NProgress.configure(&#123; showSpinner: false &#125;); 和jQuery的配合使用 添加到调用 Ajax 的地方，将它和 jQuery ajaxStart 和 ajaxStop 事件绑定起来 jQ中AJAX的全局事件 ajax提供了6个全局函数，会被页面中所有的ajax请求触发，在不同时间点会触发不同的全局事件。 在页面中会有很多的ajax请求，但是这些ajax请求都有相同的消息机制，比如我们需要在ajax请求发送之前弹出一个提示框，提示”正在读取数据….” ，在ajax请求成功时显示”获取数据成功…”，在ajax结束后隐藏提示框等。如果不使用全局事件，那么需要在每一个ajax的beforeSend、success、complete回调函数中都加上相同的代码。 jquery的全局事件需要给document注册（固定写法） 123$(document).ajaxStart(function () &#123; console.log(&quot;ajaxStart，这是在开始一个ajax请求时触发的事件&quot;);&#125;); 全局事件的执行时机 1234561. ajaxStart 在开始一个ajax请求时触发2. ajaxSend 在beforeSend回调函数之后触发3. ajaxSuccess 在success回调函数之后触发4. ajaxError 在error回调函数之后触发5. ajaxComplete 在complete回调函数之后触发6. ajaxStop 在ajax请求结束时触发 官网：http://ricostacruz.com/nprogress/ github地址：https://github.com/rstacruz/nprogress 参考文档：http://blog.csdn.net/joyhen/article/details/24458427","categories":[{"name":"plugin","slug":"plugin","permalink":"https://bloodthirsty2b.github.io/categories/plugin/"}],"tags":[{"name":"plugin","slug":"plugin","permalink":"https://bloodthirsty2b.github.io/tags/plugin/"}]},{"title":"json-server的使用","slug":"plugin/json-server的使用","date":"2021-11-04T14:20:39.000Z","updated":"2021-12-20T15:59:17.655Z","comments":true,"path":"2021/11/04/plugin/json-server的使用/","link":"","permalink":"https://bloodthirsty2b.github.io/2021/11/04/plugin/json-server%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"json-server的使用使用方法： npm i -g json-server 新建一个 JSON 文件，写入数据（一定要写id） 启动接口 json-server json文件名，一旦启动就可以生成一套基于 restful风格的一套api 增删改查： ① get请求（查询）： http://localhost:3000/json数据对象名 获取全部数据 http://localhost:3000/json数据对象名/数据id值 获取指定id的数据 ② post请求（只用于添加，可使用postman方便发送请求）： http://localhost:3000/json数据对象名 在请求体中写入数据 ③ delete请求（只用于删除）： http://localhost:3000/json数据对象名/数据id值 删除指定id的数据 ④ put请求（全量修改）： http://localhost:3000/json数据对象名/数据id值 在请求体中写入数据，覆盖指定id的所有数据 ⑤ patch请求（局部修改）： http://localhost:3000/json数据对象名/数据id值 在请求体中写入数据，修改指定id数据的某一项","categories":[{"name":"plugin","slug":"plugin","permalink":"https://bloodthirsty2b.github.io/categories/plugin/"}],"tags":[{"name":"plugin","slug":"plugin","permalink":"https://bloodthirsty2b.github.io/tags/plugin/"}]},{"title":"jquery-fileupload的使用","slug":"plugin/jquery-fileupload的使用","date":"2021-11-04T14:19:56.000Z","updated":"2021-12-20T15:59:10.434Z","comments":true,"path":"2021/11/04/plugin/jquery-fileupload的使用/","link":"","permalink":"https://bloodthirsty2b.github.io/2021/11/04/plugin/jquery-fileupload%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"jquery-fileupload的使用使用步骤github地址：https://github.com/blueimp/jQuery-File-Upload 中文文档：http://www.jq22.com/jquery-info230 引包12345678&lt;!-- jquery-fileupload依赖与jquery --&gt;&lt;script src=&quot;//ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;!-- jquery ui小部件，上传插件依赖了jquery ui的小部件 --&gt;&lt;script src=&quot;js/vendor/jquery.ui.widget.js&quot;&gt;&lt;/script&gt;&lt;!-- 如果上传图片需要跨域，那么需要引入这个js文件，如果不跨域，则不需要引入 --&gt;&lt;script src=&quot;js/jquery.iframe-transport.js&quot;&gt;&lt;/script&gt;&lt;!-- jquery上传插件 --&gt;&lt;script src=&quot;js/jquery.fileupload.js&quot;&gt;&lt;/script&gt; html结构1234&lt;!-- name指定图片上传时的name属性 --&gt;&lt;!-- data-url指定图片上传时的接口地址 --&gt;&lt;!-- multiple指定多文件上传 --&gt;&lt;input id=&quot;fileupload&quot; type=&quot;file&quot; name=&quot;files&quot; data-url=&quot;server/php/&quot; multiple&gt; js代码12345678$(&quot;#fileupload&quot;).fileupload(&#123; dataType:&quot;json&quot;, //e：事件对象 //data：图片上传后的对象，通过data.result.picAddr可以获取上传后的图片地址 done:function (e, data) &#123; console.log(data); &#125;&#125;);","categories":[{"name":"plugin","slug":"plugin","permalink":"https://bloodthirsty2b.github.io/categories/plugin/"}],"tags":[{"name":"plugin","slug":"plugin","permalink":"https://bloodthirsty2b.github.io/tags/plugin/"}]},{"title":"前端校验插件bootstrap-validator ","slug":"plugin/前端校验插件bootstrap-validator","date":"2021-11-04T14:19:01.000Z","updated":"2021-12-20T15:59:36.917Z","comments":true,"path":"2021/11/04/plugin/前端校验插件bootstrap-validator/","link":"","permalink":"https://bloodthirsty2b.github.io/2021/11/04/plugin/%E5%89%8D%E7%AB%AF%E6%A0%A1%E9%AA%8C%E6%8F%92%E4%BB%B6bootstrap-validator/","excerpt":"前端校验插件bootstrap-validator一、引包 引入bootstrap-validator的css文件。由于bootstrap-validator是bootstrap插件，因此需要先引入bootstrap。 12&lt;link rel=&quot;stylesheet&quot; href=&quot;lib/bootstrap/css/bootstrap.css&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;lib/bootstrap-validator/css/bootstrapValidator.css&quot;&gt; 引入bootstrap-validator的js文件 123&lt;script src=&quot;lib/jquery/jquery.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;lib/bootstrap/js/bootstrap.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;lib/bootstrap-validator/js/bootstrapValidator.js&quot;&gt;&lt;/script&gt;","text":"前端校验插件bootstrap-validator一、引包 引入bootstrap-validator的css文件。由于bootstrap-validator是bootstrap插件，因此需要先引入bootstrap。 12&lt;link rel=&quot;stylesheet&quot; href=&quot;lib/bootstrap/css/bootstrap.css&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;lib/bootstrap-validator/css/bootstrapValidator.css&quot;&gt; 引入bootstrap-validator的js文件 123&lt;script src=&quot;lib/jquery/jquery.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;lib/bootstrap/js/bootstrap.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;lib/bootstrap-validator/js/bootstrapValidator.js&quot;&gt;&lt;/script&gt; 二、初始化表单校验插件 bootstrap-validator插件会在表单提交的时候进行校验，如果校验失败了，就会阻止表单的提交。 12345678910111213141516171819202122232425262728293031323334353637// 使用表单校验插件$(form表单选择器).bootstrapValidator(&#123; // 1. 指定不校验的类型，默认为[&#x27;:disabled&#x27;, &#x27;:hidden&#x27;, &#x27;:not(:visible)&#x27;],可以不设置 excluded: [&#x27;:disabled&#x27;, &#x27;:hidden&#x27;, &#x27;:not(:visible)&#x27;], // 2. 指定校验时的图标显示，默认是bootstrap风格 feedbackIcons: &#123; valid: &#x27;glyphicon glyphicon-ok&#x27;, invalid: &#x27;glyphicon glyphicon-remove&#x27;, validating: &#x27;glyphicon glyphicon-refresh&#x27; &#125;, // 3. 指定校验字段 fields: &#123; // 校验用户名，对应name表单的name属性 username: &#123; validators: &#123; // 不能为空 notEmpty: &#123; message: &#x27;用户名不能为空&#x27; &#125;, // 长度校验 stringLength: &#123; min: 6, max: 30, message: &#x27;用户名长度必须在6到30之间&#x27; &#125;, // 正则校验 regexp: &#123; regexp: /^[a-zA-Z0-9_\\.]+$/, message: &#x27;用户名由数字字母下划线和.组成&#x27; &#125; &#125; &#125;, &#125;&#125;); 三、注册表单验证成功事件如果校验成功了，就会触发success.form.bv事件，此时会提交表单，这时候，通常我们需要禁止表单的自动提交，使用ajax进行表单的提交。 12345$(form表单选择器).on(&#x27;success.form.bv&#x27;, function (e) &#123; // 阻止type=&quot;submit&quot;的表单标签的默认提交事件 e.preventDefault(); // 使用ajax提交逻辑&#125;); 四、获取validator实例(对象)表单校验插件初始化完成后，可以通过以下方法来完成功能。 12345// 获取表单校验的validator实例const validator = $(form表单选择器).data(&#x27;bootstrapValidator&#x27;); // 使用表单校验实例来调用一些常用的方法validator.methodName(parameters); 1. 重置表单由于表单标签的原生reset方法无法影响bootstrap-validator中的额外内容，所以需要用内置的方法重置表单中设置过校验的内容，隐藏所有错误提示和图标。 12// 重置表单，并且会隐藏所有的错误提示和图标$(form表单选择器).validator.resetForm(); 2. 更新字段的状态BootstrapValidator在用户输入内容的时候，会做校验，当调用bootstrap的插件的方法可以手动改变字段值的状态。可以使用$(form表单选择器).updateStatus(field, status, validatorName)方法更新字段的状态 field为需要更新的表单的name属性 status的值有： ① NOT_VALIDATED：未校验的 ② VALIDATING：校验中的 ③ INVALID ：校验失败的 ④ VALID：校验成功的 validatorName为校验器的名字（notEmpty、stringLength等）。 ① 对于校验失败的情况，通常写一个callback来执行，如果不传入参数就会将所有校验器更新为status的状态 ② 对于校验成功的情况就不需要写了 五、参考文档 http://blog.csdn.net/nazhidao/article/details/51542508 http://blog.csdn.net/u013938465/article/details/53507109 http://www.cnblogs.com/v-weiwang/p/4834672.html?ptvd http://bootstrapvalidator.votintsev.ru/api/","categories":[{"name":"plugin","slug":"plugin","permalink":"https://bloodthirsty2b.github.io/categories/plugin/"}],"tags":[{"name":"plugin","slug":"plugin","permalink":"https://bloodthirsty2b.github.io/tags/plugin/"}]},{"title":"Axios的使用","slug":"plugin/Axios的使用","date":"2021-11-04T14:17:56.000Z","updated":"2021-12-20T15:59:00.959Z","comments":true,"path":"2021/11/04/plugin/Axios的使用/","link":"","permalink":"https://bloodthirsty2b.github.io/2021/11/04/plugin/Axios%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"Axios Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。 vue自身没有提供发送ajax请求的工具 Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。 Promise based HTTP client for the browser and node.js 以Promise为基础的HTTP客户端，适用于：浏览器和node.js 封装ajax，用来发送请求，异步获取数据 安装：npm i -S axios axios github 使用方法：","text":"Axios Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。 vue自身没有提供发送ajax请求的工具 Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。 Promise based HTTP client for the browser and node.js 以Promise为基础的HTTP客户端，适用于：浏览器和node.js 封装ajax，用来发送请求，异步获取数据 安装：npm i -S axios axios github 使用方法： 1234567891011121314axios(&#123; method: 请求方式, url: 请求地址, data: 请求体中的请求参数, params: 请求行中的请求参数,&#125;).then(function(response) &#123; // 在这里获得请求成功后的响应内容 console.log(response) // 这里this指向window，在vue中应该使用箭头函数 console.log(this)&#125;).catch(function(error) &#123; // 在这里获得请求失败的错误信息 console.log(error)&#125;)","categories":[{"name":"plugin","slug":"plugin","permalink":"https://bloodthirsty2b.github.io/categories/plugin/"}],"tags":[{"name":"plugin","slug":"plugin","permalink":"https://bloodthirsty2b.github.io/tags/plugin/"}]},{"title":"Git","slug":"test/Git的使用","date":"2021-11-04T14:15:44.000Z","updated":"2021-12-20T15:59:53.160Z","comments":true,"path":"2021/11/04/test/Git的使用/","link":"","permalink":"https://bloodthirsty2b.github.io/2021/11/04/test/Git%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"git基础 Git是一款免费、开源的分布式 版本控制系统 ，用于敏捷高效地处理任何或小或大的项目。 git的安装下载地址 注意： 不要安装在中文目录 不要使用桌面管理软件 git三个区要对某个项目使用git进行管理，需要使用git init命令初始化git仓库git init会在当前目录生成一个隐藏文件夹 .git 不要去修改这个文件夹下的任意东西。 git仓库会分成三个区（暂存区和仓库区地使用就是.git文件夹的作用） 工作区：我们书写代码的地方，工作的目录就叫工作区。 暂存区：暂时存储的区域，在git中，代码无法直接从工作区提交到仓库区，而是需要先从工作区添加到暂存区，然后才能从暂存区提交到仓库区。暂存区的目的是避免误操作。 本地仓库区：将保存在暂存区域的内容永久转储到 Git 仓库中，生成版本号。生成版本号之后，就可以任何的回退到某一个具体的版本。","text":"git基础 Git是一款免费、开源的分布式 版本控制系统 ，用于敏捷高效地处理任何或小或大的项目。 git的安装下载地址 注意： 不要安装在中文目录 不要使用桌面管理软件 git三个区要对某个项目使用git进行管理，需要使用git init命令初始化git仓库git init会在当前目录生成一个隐藏文件夹 .git 不要去修改这个文件夹下的任意东西。 git仓库会分成三个区（暂存区和仓库区地使用就是.git文件夹的作用） 工作区：我们书写代码的地方，工作的目录就叫工作区。 暂存区：暂时存储的区域，在git中，代码无法直接从工作区提交到仓库区，而是需要先从工作区添加到暂存区，然后才能从暂存区提交到仓库区。暂存区的目的是避免误操作。 本地仓库区：将保存在暂存区域的内容永久转储到 Git 仓库中，生成版本号。生成版本号之后，就可以任何的回退到某一个具体的版本。 git基本命令git init 作用：初始化git仓库，想要使用git对某个项目进行管理，需要git init进行初始化 12# 初始化仓库， 在当前目录下生成一个隐藏文件夹.gitgit init git add 作用：将文件由 工作区 添加到 暂存区，在git中，文件无法直接从工作区直接添加到仓库区，必须先从工作区添加到暂存区，再从暂存区添加到仓库区。 命令：git add 文件名/目录名 12345678910111213# 将index.html添加到暂存区git add index.html# 将css目录下所有的文件添加到暂存区git add css# 将当前目录下所有的js文件添加到暂存区git add *.js# 添加当前目录下所有的文件（常用）git add .git add -Agit add --all git commit作用：将文件由 暂存区 添加到 仓库区，生成版本号 1234567891011# 将文件从暂存区提交到仓库git commit -m &quot;提交说明&quot;# 如果不写提交说明，会进入vi编辑器，没有写提交说明，是提交不成功的。git commit # 需要使用vi输入内容# 如果是一个已经暂存过的文件，可以快速提交，如果是未追踪的文件，那么命令将不生效。git commit -a -m &#x27;提交说明&#x27;# 修改最近的一次提交说明， 如果提交说明不小心输错了，可以使用这个命令git commit --amend -m &quot;提交说明&quot; git config配置如果是第一次提交，需要配置提交者信息，推荐和github的账号邮箱一致 12345678910# 使用--global参数，配置全局的用户名和邮箱，只需要配置一次即可。推荐配置github的用户名和密码git config --global user.name 用户名git config --global user.email 邮箱# 查看配置信息git config --list# 取消配置git config --unset --global user.namegit config --unset --global user.email git status 作用：查看文件的状态 命令：git status 红色表示工作区中的文件需要提交 绿色表示暂存区中的文件需要提交 命令：git stauts -s 简化日志输出格式 git log 作用：查看提交日志 git log 查看提交的日志 git log --oneline 简洁的日志信息 git重置git reset 作用：版本回退，将代码恢复到已经提交的某一个版本中。 git reset --hard 版本号 将代码回退到某个指定的版本(版本号只要有前几位即可) git reset --hard head~1将版本回退到上一次提交（不好用） ~1:上一次提交 ~2:上上次提交 ~0:当前提交 当使用了git reset命令后，版本会回退，使用git log只能看到当前版本之前的信息。使用git reflog可以查看所有的版本信息 git忽视文件 在仓库中，有些文件是不想被git管理的，比如数据的配置密码、写代码的一些思路，node_modules等。git可以通过配置从而达到忽视掉一些文件，这样这些文件就可以不用提交了。 在仓库的根目录创建一个.gitignore的文件，文件名是固定的。 将不需要被git管理的文件路径添加到.gitignore中 1234567891011# 忽视idea.txt文件idea.txt# 忽视css下的index.js文件css/index.js# 忽视css下的所有的js文件css/*.js# 忽视css文件夹css git分支操作为什么要有分支？ 如果你要开发一个新的功能，需要2周时间，第一周你只能写50%代码，如果此时立即提交，代码没写完，不完整的代码会影响到别人无法工作。如果等代码写完再提交，代码很容易丢失，风险很大。 有了分支，你就可以创建一个属于自己的分支，别人看不到，也不影响别人，你在自己的分支上工作，提交到自己的分支上，等到功能开发完毕，一次性的合并到原来的分支。这样既安全，又不影响他人工作。 git分支命令 在git中，分支实质上仅仅是一个指针，每次代码提交后，这个分支指针就会向后移动，保证一直指向最后一次提交的的版本。git中使用HEAD指向当前分支 创建分支 git branch 分支名称创建分支，分支中的代码，在创建时与当前分支的内容完全相同。 git在第一次提交时，就有了一个叫master的主分支。 git branch dev，创建了一个叫做dev的分支 查看分支 git branch可以查看所有的分支， 在当前分支的前面会有一个* 在git中，有一个特殊指针HEAD,永远会指向当前分支 切换分支 git checkout 分支名称切换分支 HEAD指针指向了另一个分支 在当前分支的任何操作，都不会影响到其他的分支，除非进行了分支合并。 提交代码时，会生产版本号，当前分支会指向最新的版本号。 创建并切换分支 git checkout -b 分支名称 创建并切换分支 切换分支会做两件事情 创建一个新分支 把head指针指向当前的分支 删除分支 git branch -d 分支名称 可以删除分支 注意：不能在当前分支删除当前分支，需要切换到其他分支才能删除。 注意：master分支是可以删除的，但是不推荐那么做。 合并分支 git merge 分支名称 将其他分支的内容合并到当前分支。 在master分支中执行git merge dev 将dev分支中的代码合并到master分支 分支合并 git合并冲突 对于同一个文件，如果有多个分支需要合并时，容易出现冲突。 合并分支时，如果出现冲突，只能手动处理，再次提交，一般的作法，把自己的代码放到冲突代码的后面即可。 git远程仓库 gitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。 github免费，代码所有人都能看到，但是只有你自己能修改。付费的可以隐藏。 创建git项目时，不能有中文。 github官网 码云-gitee git clone 作用：克隆远程仓库的代码到本地 git clone [远程仓库地址] 执行后会在本地新建一个对应的文件夹，文件夹中包含了一个.git目录，用于保存所有的版本记录，同时文件夹中还有最新的代码，如果是自己的仓库，可以直接进行后续的开发和使用。 git克隆默认会使用远程仓库的项目名字，也可以自己指定。需要使用以下命令：git clone [远程仓库地址] [本地项目名] git push 作用：将本地仓库中代码提交到远程仓库 git push 仓库地址 master 在代码提交到远程仓库，注意master分支必须写，不能省略 如果第一次使用，需要填写github的用户名和密码 git pull 作用：将远程的代码下载到本地 通常在push前，需要先pull一次。 12# 获取远程仓库的更新，并且与本地的分支进行合并git pull git remote每次push操作都需要带上远程仓库的地址，非常的麻烦， 我们可以给仓库地址设置一个别名 123456789# 查看远程仓库所有的别名git remote# 给远程仓库设置一个别名git remote add 仓库别名 仓库地址git remote add fubuki 仓库地址# 删除fubuki这个别名git remote remove fubuki git clone 后会自动将远程仓库地址存放到origin变量中，之后可以用origin代替地址 SSH免密码登陆git支持多种数据传输协议： https协议：https://github.com/xxxxx/xxx.git 需要输入用户名和密码 ssh协议：git@github.com:xxxxx/xxx.git 可以配置免密码登录 每次push或者pull代码，如果使用https协议，那么都需要输入用户名和密码进行身份的确认，非常麻烦。 github为了账户的安全，需要对每一次push请求都要验证用户的身份，只有合法的用户才可以push 使用ssh协议，配置ssh免密码，可以做到免密码往github推送代码 SSH免密码登录配置注意：这些命令需要在bash中敲 1 创建SSH Key：ssh-keygen -t rsa 2 在文件路径 C:\\用户\\当前用户名\\ 找到 .ssh 文件夹 3 文件夹中有两个文件： 私钥：id_rsa 公钥：id_rsa.pub 4 在 github -&gt; settings -&gt; SSH and GPG keys页面中，新创建SSH key 5 粘贴 公钥 id_rsa.pub 内容到对应文本框中 5 在github中新建仓库或者使用现在仓库，拿到git@github.com:用户名/仓库名.git 6 此后，再次SSH方式与github“通信”，不用输入密码确认身份了","categories":[{"name":"test","slug":"test","permalink":"https://bloodthirsty2b.github.io/categories/test/"},{"name":"Git","slug":"test/Git","permalink":"https://bloodthirsty2b.github.io/categories/test/Git/"}],"tags":[{"name":"test","slug":"test","permalink":"https://bloodthirsty2b.github.io/tags/test/"},{"name":"Git","slug":"Git","permalink":"https://bloodthirsty2b.github.io/tags/Git/"}]},{"title":"Vue基本概念","slug":"Vue/01-Vue基本概念","date":"2021-11-04T13:42:23.000Z","updated":"2021-12-20T15:49:39.388Z","comments":true,"path":"2021/11/04/Vue/01-Vue基本概念/","link":"","permalink":"https://bloodthirsty2b.github.io/2021/11/04/Vue/01-Vue%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","excerpt":"Vue基本概念vue介绍 vue 中文网 Vue.js 是什么 介绍：Vue是一套用于构建用户界面的渐进式框架。","text":"Vue基本概念vue介绍 vue 中文网 Vue.js 是什么 介绍：Vue是一套用于构建用户界面的渐进式框架。 库和框架的概念 前端框架与库的区别 Library 库，本质上是一些函数的集合。每次调用函数，实现一个特定的功能 代表：jQuery 使用库的时候，把库当成工具使用，需要自己控制代码的执行逻辑。比如原生和jQuery可以混合使用，没有上下文联系 Framework 框架，是一套完整的解决方案，使用框架的时候，需要把你的代码放到框架合适的地方，框架会在合适的时机调用你的代码 框架规定了自己的编程方式，是一套完整的解决方案 使用框架的时候，由框架控制一切，我们只需要按照规则把要求的代码放到空缺中 库和框架的区别 使用库的时候，很自由，只要调用库提供的各种各样的方法就行，也可以不用其他的一些方法 使用框架的时候，需要按照框架的规则写代码，限制会非常多，但同时框架的功能也很强大，可以极大的提升开发的效率。 MVVM的概念参考资料：从Script到Code Blocks、Code Behind到MVC、MVP、MVVM MVC MVC是一种软件架构模式，也有人叫做设计模式 M: Model 数据模型（专门用来操作数据，数据的CRUD） V：View 视图（对于前端来说，就是页面） C：Controller 控制器（是视图和数据模型沟通的桥梁，用于处理业务逻辑） MVVMMVVM，一种更好的UI模式解决方案 M：model数据模型(ajax获取到的数据) V：view视图（页面） VM：ViewModel 视图模型 MVC vs MVVM MVC模式，将应用程序划分为三大部分，实现了职责分离，需要自己实现controller的代码，需要操作DOM MVVM通过数据双向绑定让数据自动地双向同步 V（修改视图） -&gt; M（数据自动同步） M（修改数据） -&gt; V（视图自动徒步） Vue中的MVVM虽然没有完全遵循 MVVM 模型，Vue 的设计无疑受到了它的启发。因此在文档中经常会使用 vm (ViewModel 的简称) 这个变量名表示 Vue 实例 注意： 1. 在vue中，不推荐直接手动操作DOM！ 2. 在vue中，通过数据驱动视图，不要在想着怎么操作DOM，而是想着如何操作数据！！ vue初体验基本使用步骤 安装：npm install vue 引入：通过script标签引入vue，开发期间使用未压缩版vue.js 通过new Vue()创建vue实例，并且指定el和data参数 在页面中，通过双花括号访问数据 12345678910// 2. 创建vue实例，需要指定el和data属性let vm = new Vue(&#123; // 指定vue监管的视图区域,只有id为app的div内部才会受vue的管理 el: &#x27;#app&#x27;, // 提供了vue中使用的数据 data: &#123; msg: &#x27;hello vue&#x27; &#125;&#125;) 注意：el不能是html和body 插值表达式插值表达式：也叫Mustache语法，小胡子语法，因为长得像胡子 解释：使用双花括号（插值表达式）从data中获取数据，并展示在模板中 注意： 不支持if、for等js语句； 不是data中的数据不能使用； 标签属性中不能使用插值表达式 说明：数据对象的属性值发生了改变，插值处的内容都会更新 12345678&lt;!-- 支持三元运算符 --&gt;&lt;h1&gt;Hello, &#123;&#123; msg &#125;&#125;.&lt;/h1&gt;&lt;p&gt;&#123;&#123; isOk ? &#x27;yes&#x27;: &#x27;no&#x27; &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; 1 + 2 &#125;&#125;&lt;/p&gt;&lt;!-- 不支持if、for等js语句；不是data的数据不能使用；标签属性中不能使用&#123;&#123;&#125;&#125; --&gt;&lt;h1 title=&quot;&#123;&#123; if()&#123;&#125; &#125;&#125;&quot;&gt;&lt;/h1&gt;&lt;h1 title=&quot;&#123;&#123; err &#125;&#125;&quot;&gt;&lt;/h1&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://bloodthirsty2b.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://bloodthirsty2b.github.io/tags/Vue/"}]},{"title":"国内npm的使用以及nodemon的使用","slug":"test/国内npm的使用以及nodemon的使用","date":"2021-11-04T13:34:42.000Z","updated":"2021-12-20T16:00:10.572Z","comments":true,"path":"2021/11/04/test/国内npm的使用以及nodemon的使用/","link":"","permalink":"https://bloodthirsty2b.github.io/2021/11/04/test/%E5%9B%BD%E5%86%85npm%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8Anodemon%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"国内npm的使用以及nodemon的使用一、npm的使用 npm初始化，每个项目需要初始化一次（每个项目需要的包不同）npm init → 用于新建package.json，之后可以再次修改package.jsonnpm init -y → 省略确认细节package.json用于记录当前项目的全部依赖 → dependencies里显示 安装：npm install 包名（默认安装最新版本）如果要更换安装的版本，一般要先卸载已经装过的版本，否则可能影响整个node_modules文件夹（例如vue）npm uninstall 包名 → 卸载npm install 包名@版本号 →安装指定版本的包 安装简写：npm i 包名 若是删除了node_modules文件夹，可以直接npm i安装package.json中记录的项目依赖的包 npm cache clean -f 如果npm安装失败了，可以用这个命令清除缓存（之后要重新下，慎用） ps. npm的本地安装：将包安装到当前项目的目录中 (npm i 包名) npm的全局安装：将包安装到c盘，将来所有的目录都可以用到这个包(pm i 包名 -g)","text":"国内npm的使用以及nodemon的使用一、npm的使用 npm初始化，每个项目需要初始化一次（每个项目需要的包不同）npm init → 用于新建package.json，之后可以再次修改package.jsonnpm init -y → 省略确认细节package.json用于记录当前项目的全部依赖 → dependencies里显示 安装：npm install 包名（默认安装最新版本）如果要更换安装的版本，一般要先卸载已经装过的版本，否则可能影响整个node_modules文件夹（例如vue）npm uninstall 包名 → 卸载npm install 包名@版本号 →安装指定版本的包 安装简写：npm i 包名 若是删除了node_modules文件夹，可以直接npm i安装package.json中记录的项目依赖的包 npm cache clean -f 如果npm安装失败了，可以用这个命令清除缓存（之后要重新下，慎用） ps. npm的本地安装：将包安装到当前项目的目录中 (npm i 包名) npm的全局安装：将包安装到c盘，将来所有的目录都可以用到这个包(pm i 包名 -g) 二、nrm的使用npm是一个仓库地址管理工具，默认访问的是npm的仓库地址，在国外，下载很慢。所以通常访问国内的镜像网站 安装 npm i nrm -g （全局安装方便使用） 查看可用地址 nrm ls （默认采用的地址前有*，这里改用淘宝的地址） 切换仓库地址 nrm use 仓库地址名 （nrm use taobao） 三、nodemon的使用nodemon可以实现修改代码后自动重启服务器 npm i nodemon -g（应该全局安装，需要在任何目录内使用） 使用nodemon命令代替之前的node命令 ps. nodemon在内部封装了node命令","categories":[{"name":"test","slug":"test","permalink":"https://bloodthirsty2b.github.io/categories/test/"}],"tags":[{"name":"test","slug":"test","permalink":"https://bloodthirsty2b.github.io/tags/test/"}]},{"title":"接口测试工具postman","slug":"test/接口测试工具postman","date":"2021-11-04T13:32:11.000Z","updated":"2024-12-20T16:01:12.023Z","comments":true,"path":"2021/11/04/test/接口测试工具postman/","link":"","permalink":"https://bloodthirsty2b.github.io/2021/11/04/test/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7postman/","excerpt":"","text":"接口测试的工具postman一、使用方法 选择请求方式 输入路径 点击send按钮 二、postman的传参方式（部分） get ① 直接在路径中拼接键值对参数 ② 点击postman中的Params按钮输入键值对 post ① 写好路径 ② 在body栏中点击x-www-form-urlencoded单选框 ③ 在body栏中输入键值对","categories":[{"name":"test","slug":"test","permalink":"https://bloodthirsty2b.github.io/categories/test/"}],"tags":[{"name":"test","slug":"test","permalink":"https://bloodthirsty2b.github.io/tags/test/"}]},{"title":"nodejs模块","slug":"node/nodejs模块","date":"2021-11-04T13:28:39.000Z","updated":"2021-12-20T15:58:12.441Z","comments":true,"path":"2021/11/04/node/nodejs模块/","link":"","permalink":"https://bloodthirsty2b.github.io/2021/11/04/node/nodejs%E6%A8%A1%E5%9D%97/","excerpt":"nodejs模块：相当于封装的js文件一、定义 在nodejs中，一个js文件就是一个模块 每个模块，都有一个独立的作用域，在自己 js文件中声明的变量和函数，只能在自己所在的模块中使用","text":"nodejs模块：相当于封装的js文件一、定义 在nodejs中，一个js文件就是一个模块 每个模块，都有一个独立的作用域，在自己 js文件中声明的变量和函数，只能在自己所在的模块中使用 二、分类模块共有三种：核心模块（nodejs自带模块）、第三方模块（其他人封装好的模块，需要先下载再引入）、自定义模块（可自行编写的灵活模块） 三、模块的导入1. 语法： 123const fs = require(&#x27;fs&#x27;) // 核心模块的导入const moment = require(&#x27;moment&#x27;) // 第三方模块的导入，方法应参考官方文档const lalala = require(&#x27;./lalala&#x27;) // 自定义模块的导入 导入的时候应该使用一个变量去接收 2. 模块导入的顺序：① 先看是否是路径格式，如果是路径格式那就当作自定义模块，根据路径查找对应的文件进行加载；② 再看是不是模块名格式，是模块名格式的话③ 最后看是不是核心模块，是的话按照核心模块导入；如果不是核心模块，就当作第三方模块处理（会去当前文件夹中的node_modules中查找对应的包，如果当前文件夹内没有，会往上一级目录查找，直到根目录，根目录也没有的话就会报错） 所以 const fs = require(&#39;./fs&#39;) 会当作自定义模块查找 四、模块的导出 模块一定要导出才有封装的意义，不然模块中声明的变量和函数都是无法使用的 每个模块有一个独立的module全局变量（对象），在module对象中有一个exports的属性，代表当前模块的导出内容 语法： module.exports.属性名 &#x3D; 函数 module.exports &#x3D; fn （只需要导出一个内容时可以直接覆盖module） module.exports &#x3D; {fn, num, str} （以对象的形式覆盖） module.exports和exports的区别 虽然在模块中，module.exports和exports指向的是同一个对象（module.exports &#x3D;&#x3D;&#x3D; exports），但是一个模块的导出内容只是module.exports对应的内容 直接添加属性的导出方法，exports也可以使用 覆盖方法对exports无效（覆盖了exports的指向，但是导出的依然是module.exports） 五、部分核心模块的使用1. fs模块（文件读写模块） ① 写入文件 语法：writeFile(文件路径, 写入的内容, 回调函数(err)) 1234567891011const fs = require(&#x27;fs&#x27;)fs.writeFile(&#x27;xxx.txt&#x27;, &#x27;hello world&#x27;, err =&gt; &#123; if (err) &#123; // console.log(err) // return throw err // 抛出异常，并中断整个程序的运行，严重错误中配合try...catch处理 // throw会中断整个程序的运行 // return只会中断该函数的运行 &#125; console.log(&#x27;写入成功&#x27;)&#125;) 特点： 如果文件存在，会覆盖原本内容 如果文件不存在，会创建一个文件 如果文件路径不存在，会报错，不会新建文件夹去写入 ② 读取文件 语法：fs.readFile(文件路径, &#39;utf8&#39;, 回调函数(err, data)) 12345678910const fs = require(&#x27;fs&#x27;)fs.readFile(&#x27;xxx.txt&#x27;, (err, data) =&gt; &#123; if (err) &#123; return console.log(err); &#125; console.log(data.toString());&#125;)// err：错误信息,null表示没有错误,node中应该优先处理错误(加一个判断)// utf8: 编码，写utf-8一样，读取字符串的时候使用，如果读取的是图片、视频等二进制数据不要加// data：读取的数据，如果参数里没有&#x27;utf8&#x27;，那么为二进制编码(buffer)(显示为16进制),需要用toString方法 ​ ③ 追加文件​ 语法：fs.appendFile(文件路径, 追加内容, 回调函数(err)) 12345const fs = require(&#x27;fs&#x27;)fs.appendFile(&#x27;xxx.txt&#x27;, &#x27;哈哈哈&#x27;, err =&gt; &#123; if (err) return console.log(&#x27;追加失败&#x27;); console.log(&#x27;追加成功&#x27;);&#125;) ​ 通常文件的读写都是异步的，不会阻塞主线程代码的执行​ fs.readFileSync(&#39;xxx.txt&#39;, &#39;utf8&#39;)​ fs.writeFileSync(&#39;xxx.txt&#39;, data)​ fs.appendFileSync(&#39;xxx.txt&#39;, data)​ 而这三个都是同步的，代码可读性好，但是性能差(不需要回调函数) 2. path模块读写文件的规范：一律使用绝对路径因为只要是相对路径，就是相对于node命令执行的路径，一旦命令行路径改变就会报错要解决这个问题，可以使用 __dirname + &#39;/xxx.txt&#39;来作为路径使用cd ..👉回到上一级 语法：path.join(路径A, 路径B, 路径C) join方法会根据不同的系统（Windows、mac、linux）自动按照对应的分隔符进行路径合并 1234const path = require(&#x27;path&#x27;)const filePath = path.join(&#x27;aa&#x27;, &#x27;bb&#x27;, &#x27;cc.js&#x27;)console.log(filePath);// aa\\bb\\cc.js 👉 windows系统下的格式const filePath_join = path.join(__dirname, &#x27;xxx.txt&#x27;) // 这才是通常使用的格式 如果要回到上一级目录的话，可以使用path.resolve方法 12345const path = require(&#x27;path&#x27;)// 目前文件目录：/server/app.jsconst filePath = path.resolve(__dirname, &#x27;..&#x27;, &#x27;assert&#x27;, &#x27;favicon.ico&#x27;)// 可以获取到/assert/favicon.ico// 相当于用每个参数执行了cd命令，所以中间如果有/开头的目录则会回到根目录 3. http模块（建立服务器）响应请求的简单步骤： ​ ① 建立服务器，监听端口 12345const http = require(&#x27;http&#x27;)const server = http.createServer()server.listen(8080, () =&gt; &#123; console.log(&quot;服务器已启动，端口号8080&quot;)&#125;) ​ ② 给服务器添加请求事件（请求报文，响应报文） ​ ③ 根据请求报文的内容做判断，返回数据或者404错误 ​ ④ 返回数据的话先找到文件，然后发送响应报文（状态行，响应头，响应体） 12345678910111213server.on(&#x27;request&#x27;, (req, res) =&gt; &#123; // 设置响应头必须放在响应体的前面 res.setHeader(&#x27;content-type&#x27;, &#x27;text/html; charset=utf-8&#x27;) if (req.url === &#x27;/&#x27; || req.url === &#x27;/index.html&#x27;) &#123; res.write(&#x27;first&#x27;) res.write(&#x27;second&#x27;) res.write(&#x27;third&#x27;) res.end(&#x27;end&#x27;) // 如果只需要响应简单信息那么写在这里面就好 &#125; else &#123; res.statusCode = 404 res.end(&#x27;404&#x27;) &#125;&#125;) 4. url模块（用于获取url中包含的所有信息 ）12345678910111213141516171819const url = require(&#x27;url&#x27;) // 引入url模块url.parse(filePath, true) // url.parse(路径，布尔值) // 参数一：需要解析的路径地址（http://localhost:8080/delete?id=xx&amp;username=xx) // 参数二：true表示需要对query属性值进行解析，false时显示id=xx&amp;username=xx// 输出结果：&#123; protocol : &#x27;http&#x27;, auth : null, host : &#x27;localhost:8080&#x27;, port : &#x27;8080&#x27;, hostname : &#x27;localhost&#x27;, hash : null, search : &#x27;?id=xx&amp;username=xx&#x27;, query : &#x27;id=xx&amp;username=xx&#x27;, pathname : &#x27;/delete&#x27;, path : &#x27;/delete?id=xx&amp;username=xx&#x27;, href : &#x27;http://localhost:8080/delete?id=xx&amp;username=xx&#x27;&#125; 5. queryString模块(用于将url模块获取的query转化为对象)处理POST请求的注意点： ① req.method用来获取请求方式，其值GET和POST只会是大写的 ② node默认不会解析请求体内容（恶意post请求会消耗大量性能），需要自行获取信任的内容 ③ POST请求的参数可能很大，一次性拿不完，需要逐步获取，所以需要用到data和end事件 data和end的使用： 123456789let result = &#x27;&#x27;req.on(&#x27;data&#x27;, chunk =&gt; &#123; result += chunk console.log(&#x27;已获取数据&#x27;) // 因为会逐步接受，所以会显示很多次&#125;)req.on(&#x27;end&#x27;, () =&gt; &#123; console.log(&#x27;数据获取结束&#x27;) &#125;)// result便是最终获取的请求体内容 ​ ④ 这样就可以使用queryString模块内的方法解析post请求内容了 123// result = &#x27;name=xxx&amp;title=xxx&amp;content=xxx&#x27;const querystring = require(&#x27;querystring&#x27;)const query = querystring.parse(result)","categories":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/categories/js/"},{"name":"nodejs","slug":"js/nodejs","permalink":"https://bloodthirsty2b.github.io/categories/js/nodejs/"}],"tags":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/tags/js/"},{"name":"nodejs","slug":"nodejs","permalink":"https://bloodthirsty2b.github.io/tags/nodejs/"}]},{"title":"nodejs部分实用第三方模块介绍","slug":"node/nodejs部分实用第三方模块介绍","date":"2021-11-04T13:27:59.000Z","updated":"2021-12-20T15:58:03.875Z","comments":true,"path":"2021/11/04/node/nodejs部分实用第三方模块介绍/","link":"","permalink":"https://bloodthirsty2b.github.io/2021/11/04/node/nodejs%E9%83%A8%E5%88%86%E5%AE%9E%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D/","excerpt":"nodejs部分实用第三方模块介绍mime（获取文件类型）作用： 在设置响应报文时自动获取响应体文件的文件类型 使用方法： npm install mime const mime = require(&#39;mime&#39;) mime.getType(传入需要类型的文件名或文件路径) 特点： 会自动根据文件扩展名得到mime类型(content-type) 也可以根据文件路径得到mime类型","text":"nodejs部分实用第三方模块介绍mime（获取文件类型）作用： 在设置响应报文时自动获取响应体文件的文件类型 使用方法： npm install mime const mime = require(&#39;mime&#39;) mime.getType(传入需要类型的文件名或文件路径) 特点： 会自动根据文件扩展名得到mime类型(content-type) 也可以根据文件路径得到mime类型 art-template（服务端渲染使用的模板）服务端渲染流程： 建立node服务器，向后端发送请求 接受数据后渲染好页面，发送给浏览器 浏览器渲染好完整的页面 特点： 有利于SEO优化（爬虫能直接获取必要的内容，不会像ajax动态渲染一开始什么都没有） 工作量大，对技术要求高 使用方法： npm i art-template const template = require(&#39;art-template&#39;)获得template方法 语法：template(模板绝对路径，数据对象)（由于是把整个html文件当作模板，所以传入的参数是路径） 修改模板，进行渲染 将渲染好的内容响应给浏览器 moment（获取当前时间并格式化的工具）使用方法： 初始化并安装 npm i moment --save 语法：moment().format(&quot;YYYY年MM月DD日 HH:mm:ss&quot;)// moment().format(格式化参数) → moment()取到当前时间，format()格式化 格式化参数参考 http://momentjs.cn/docs/#/displaying/","categories":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/categories/js/"},{"name":"nodejs","slug":"js/nodejs","permalink":"https://bloodthirsty2b.github.io/categories/js/nodejs/"}],"tags":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/tags/js/"},{"name":"nodejs","slug":"nodejs","permalink":"https://bloodthirsty2b.github.io/tags/nodejs/"}]},{"title":"express的简单使用","slug":"node/express的简单使用","date":"2021-11-04T13:26:16.000Z","updated":"2021-12-20T15:57:54.338Z","comments":true,"path":"2021/11/04/node/express的简单使用/","link":"","permalink":"https://bloodthirsty2b.github.io/2021/11/04/node/express%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/","excerpt":"express的简单使用需要的npm包：express、body-parser、art-template、express-art-template 预先引入模块：express、fs、path、body-parser 一、静态页面的处理 使用 app.get方法精确匹配地址 使用 res.sendFile方法发送静态页面内容（可以发字符串内容或文件路径） 1234app.get(&#x27;/static&#x27;, (req, res) =&gt; &#123; const filePath = path.join(__dirname, &#x27;/pages/static.html&#x27;) res.sendfile(filePath)&#125;)","text":"express的简单使用需要的npm包：express、body-parser、art-template、express-art-template 预先引入模块：express、fs、path、body-parser 一、静态页面的处理 使用 app.get方法精确匹配地址 使用 res.sendFile方法发送静态页面内容（可以发字符串内容或文件路径） 1234app.get(&#x27;/static&#x27;, (req, res) =&gt; &#123; const filePath = path.join(__dirname, &#x27;/pages/static.html&#x27;) res.sendfile(filePath)&#125;) 二、资源的处理 使用app.use方法匹配所有匹配字符串开头的地址 发送资源内容，共有2种方法 ① 使用res.sendFile方法发送资源内容 1234app.use(&#x27;/static&#x27;, (req, res) =&gt; &#123; const filePath = path.join(__dirname, req.originalUrl) res.sendfile(filePath)&#125;) ② 使用express.static回调函数发送资源内容 12// express.static中的参数为存放静态资源的文件夹名app.use(&#x27;/static&#x27;, express.static(&#x27;static&#x27;)) 三、模板引擎的使用 初始化引擎1234// html为模板文件后缀名app.engine(&#x27;html&#x27;, require(&#x27;express-art-template&#x27;))// pages为存放模板的文件夹名，将views文件夹改为pages文件夹app.set(&#x27;views&#x27;, &#x27;pages&#x27;) 使用模板 ① 使用res.send方法发送模板字符串 12345678app.get(&#x27;/&#x27;, (req, res) =&gt; &#123; const filePath = path.join(__dirname, &#x27;/pages/index.html&#x27;) fs.readFile(dataPath, &#x27;utf8&#x27;, (err, data) =&gt; &#123; if (err) return console.log(&#x27;读取出错&#x27;, err) data = JSON.parse(data) res.send(template(filePath, data)) &#125;)&#125;) ② 使用res.render方法渲染模板内容 123456789app.get(&#x27;/&#x27;, (req, res) =&gt; &#123; const filePath = path.join(__dirname, &#x27;/pages/index.html&#x27;) fs.readFile(dataPath, &#x27;utf8&#x27;, (err, data) =&gt; &#123; if (err) return console.log(&#x27;读取出错&#x27;, err) data = JSON.parse(data) // render方法的第一个参数为相对路径的话相对的是当前目录的views文件夹，除非用app.set修改 res.render(filePath, data) &#125;)&#125;) 四、get请求的处理 使用 app.get 方法精确匹配地址 使用 req.query 获得转成对象的键值对数据 五、post请求的处理 引入并初始化body-parser 123const bodyParser = require(&#x27;body-parser&#x27;)app.use(bodyParser.json())app.use(bodyParser.urlencoded(&#123; extended: true &#125;)) 使用 app.post方法精确匹配地址 使用 req.body获得转成对象的键值对数据 六、重定向和状态码设置1234// 重定向至&#x27;.../&#x27;res.redirect(&#x27;/&#x27;)// 状态码改变为302res.status(302) 七、express中间件的使用概念： 1. express中间件是一个函数，语法：`(req, res, next) =&gt; &#123;语句; next();&#125;` 2. 下一个中间件可以获取到上一个中间件的内容，如上面的req和res 3. 中间件可以对内容进行处理 4. 处理完成后会给下一个[路径匹配的]中间件使用 作用： 1. 把中间件放在响应的最前面，统一处理post请求的参数，存到req或res的属性中 2. 在响应过程中进行分支处理，例如将访问过多的ip进行重定向（通过req.ip获取访问ip） 八、express路由容器的使用对于越大型的项目，不同文件的分工就越重要，维护时也越方便，路由的作用就是将主文件的作用整合，只让主文件处理大体问题，请求的响应一律交给路由处理。 对路由模块的处理： const router = express.Router() 123router.get(路径, (req, res) =&gt; &#123; ...语句（处理&#125;) module.exports = router 对需要路由的文件： const router = require(&#39;./模块名&#39;) app.use(router) 九、登录的处理​ 在express中，登录信息可以存放在req.session的属性中，例如req.session.user = 用户信息，而访问首页时可以对登录信息进行检测，如果存在相应的信息就放行（next()）；如果不存在就重定向到登录页进行拦截。","categories":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/categories/js/"},{"name":"nodejs","slug":"js/nodejs","permalink":"https://bloodthirsty2b.github.io/categories/js/nodejs/"}],"tags":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/tags/js/"},{"name":"nodejs","slug":"nodejs","permalink":"https://bloodthirsty2b.github.io/tags/nodejs/"}]},{"title":"展开运算符，可以展开对象和数组","slug":"js/es6/展开运算符，可以展开对象和数组","date":"2021-11-04T13:19:51.000Z","updated":"2021-12-20T15:48:35.804Z","comments":true,"path":"2021/11/04/js/es6/展开运算符，可以展开对象和数组/","link":"","permalink":"https://bloodthirsty2b.github.io/2021/11/04/js/es6/%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%B1%95%E5%BC%80%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%95%B0%E7%BB%84/","excerpt":"","text":"展开运算符，可以展开对象和数组一、语法：...数组或对象 二、展开数组 可以用于数组拼接 123const arr1 = [1, 2, 3]const arr2 = [4, 5, 6]const newArr = [...arr1, 100, ...arr2] 应用举例：可以用来求数组最大值 12const arr = [1, 4, 6, 2, 45, 72, 4, 7, 8]const max = Math.max(...arr)// 👉1, 4, 6, 2, 45, 72, 4, 7, 8 二、展开对象(相当于把对象的键值对提取出来)1234567891011121314const obj1 = &#123; name: &#x27;zs&#x27;, age: 18&#125;const obj2 = &#123; sayHi() &#123; console.log(&#x27;hi&#x27;); &#125;&#125;const mix = &#123; ...obj1, ...obj2, ability: &#x27;S.H.I.T&#x27;&#125;","categories":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/categories/js/"},{"name":"es6","slug":"js/es6","permalink":"https://bloodthirsty2b.github.io/categories/js/es6/"}],"tags":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/tags/js/"},{"name":"es6","slug":"es6","permalink":"https://bloodthirsty2b.github.io/tags/es6/"}]},{"title":"模板字符串","slug":"js/es6/模板字符串","date":"2021-11-04T13:19:18.000Z","updated":"2021-12-20T15:48:27.806Z","comments":true,"path":"2021/11/04/js/es6/模板字符串/","link":"","permalink":"https://bloodthirsty2b.github.io/2021/11/04/js/es6/%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"模板字符串一、语法：1`模板内容` 1234const obj = &#123; name: &#x27;ss&#x27;, age: 19&#125; 二、特点： 支持换行和空格 支持变量$&#123; 变量名 &#125; 支持引用类型的方法和 js 语法 1234567document.querySelector(&#x27;.person&#x27;).innerHTML = `&lt;h1&gt;人物&lt;/h1&gt; &lt;p&gt;$&#123; obj.name.toUpperCase()&#125;&lt;/p&gt; &lt;p&gt;$&#123; obj.age * 2&#125;&lt;/p&gt;`","categories":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/categories/js/"},{"name":"es6","slug":"js/es6","permalink":"https://bloodthirsty2b.github.io/categories/js/es6/"}],"tags":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/tags/js/"},{"name":"es6","slug":"es6","permalink":"https://bloodthirsty2b.github.io/tags/es6/"}]},{"title":"解构赋值","slug":"js/es6/解构赋值","date":"2021-11-04T13:18:26.000Z","updated":"2021-12-20T15:48:19.648Z","comments":true,"path":"2021/11/04/js/es6/解构赋值/","link":"","permalink":"https://bloodthirsty2b.github.io/2021/11/04/js/es6/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/","excerpt":"解构赋值一、对象解构1. 语法：1234567const obj = &#123; name: &#x27;js&#x27;, age: &#x27;18&#x27;, desc: &#x27;hoho&#x27;&#125;let &#123; name, age, desc &#125; = objconsole.log(name, age, desc) // &#x27;js&#x27;, &#x27;18&#x27;, &#x27;hoho&#x27;","text":"解构赋值一、对象解构1. 语法：1234567const obj = &#123; name: &#x27;js&#x27;, age: &#x27;18&#x27;, desc: &#x27;hoho&#x27;&#125;let &#123; name, age, desc &#125; = objconsole.log(name, age, desc) // &#x27;js&#x27;, &#x27;18&#x27;, &#x27;hoho&#x27; 2. 改变变量名12let &#123; name: n, age: a, desc: d &#125; = objconsole.log(n, a, d) // &#x27;js&#x27;, &#x27;18&#x27;, &#x27;hoho&#x27; 3. 可以给解构用的变量指定默认值12345let &#123; name, age, desc, fn &#125; = objconsole.log(fn);// undefined，没有值可赋let &#123; name, age, desc, fn = &#x27;lalala&#x27; &#125; = obj // 有变量就会赋值，没有变量就是&#x27;lalala&#x27; 二、数组解构1234567const arr = [1, 2, 3]// 不要的内容可以占个位，后面直接用逗号隔开const [, item2, item3] = arrconsole.log(item2, item3) // 2, 3 三、函数参数的解构12345678910111213const obj = &#123; name: &#x27;ss&#x27;, age: 19,&#125;const money = 10000function fn(obj, money) &#123; const &#123; name, age &#125; = obj console.log(name, age, money);&#125;// 也可以在传参的时候解构function fn2(&#123; name: n, age &#125;, money) &#123; console.log(n, age, money);&#125;","categories":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/categories/js/"},{"name":"es6","slug":"js/es6","permalink":"https://bloodthirsty2b.github.io/categories/js/es6/"}],"tags":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/tags/js/"},{"name":"es6","slug":"es6","permalink":"https://bloodthirsty2b.github.io/tags/es6/"}]},{"title":"箭头函数","slug":"js/es6/箭头函数","date":"2021-11-04T13:17:20.000Z","updated":"2021-12-20T15:48:12.609Z","comments":true,"path":"2021/11/04/js/es6/箭头函数/","link":"","permalink":"https://bloodthirsty2b.github.io/2021/11/04/js/es6/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/","excerpt":"箭头函数一、语法：就是把function删掉，在小括号和大括号中间添加了一个 ‘&#x3D;&gt;’ 1234const sum = (n1, n2) =&gt; &#123; console.log(n1 + n2);&#125;sum(1, 2) // 3","text":"箭头函数一、语法：就是把function删掉，在小括号和大括号中间添加了一个 ‘&#x3D;&gt;’ 1234const sum = (n1, n2) =&gt; &#123; console.log(n1 + n2);&#125;sum(1, 2) // 3 二、特点： 如果参数列表只有一个参数，小括号可以省略（没有参数不可以省略） 1234const sum2 = n1 =&gt; &#123; console.log(n1 + 10);&#125;sum2(100) 如果函数体只有一句话，大括号可以省略（且如果有return，return也可以省略） 12345const sum3 = n1 =&gt; console.log(n1 + 20);const sum4 = n =&gt; n + 1 // return n + 1 (看的时候需要随时注意前面会有return)sum3(200)console.log(sum4(55)); // 56heros.forEach(item =&gt; sum += item.wu) // 没有return也可以省略 箭头函数没有this，会往作用域外面访问，所以需要用到this的地方就不要用箭头函数了(对象中的对象中的方法this访问的是哪个) 好处：例如用于解决setTimeout方法中this只能指向window的问题 坏处：构造函数、对象内的方法等，this会往作用域外找，不再指向本体（例如dom中的点击事件常常会用到this，所以不适合用箭头函数）","categories":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/categories/js/"},{"name":"es6","slug":"js/es6","permalink":"https://bloodthirsty2b.github.io/categories/js/es6/"}],"tags":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/tags/js/"},{"name":"es6","slug":"es6","permalink":"https://bloodthirsty2b.github.io/tags/es6/"}]},{"title":"函数参数默认值","slug":"js/es6/函数参数默认值","date":"2021-11-04T13:16:03.000Z","updated":"2021-12-20T15:48:04.589Z","comments":true,"path":"2021/11/04/js/es6/函数参数默认值/","link":"","permalink":"https://bloodthirsty2b.github.io/2021/11/04/js/es6/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC/","excerpt":"","text":"函数参数默认值函数可以设置默认值了 123456function add(a = 0, b = 1) &#123; console.log(a + b);&#125;add() // 1add(1) // 2add(1, 2) // 3","categories":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/categories/js/"},{"name":"es6","slug":"js/es6","permalink":"https://bloodthirsty2b.github.io/categories/js/es6/"}],"tags":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/tags/js/"},{"name":"es6","slug":"es6","permalink":"https://bloodthirsty2b.github.io/tags/es6/"}]},{"title":"对象中属性和方法的简写","slug":"js/es6/对象中属性和方法的简写","date":"2021-11-04T13:15:01.000Z","updated":"2021-12-20T15:47:57.211Z","comments":true,"path":"2021/11/04/js/es6/对象中属性和方法的简写/","link":"","permalink":"https://bloodthirsty2b.github.io/2021/11/04/js/es6/%E5%AF%B9%E8%B1%A1%E4%B8%AD%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E7%AE%80%E5%86%99/","excerpt":"","text":"对象中属性和方法的简写包含： 对象中属性名和变量名相同时可以简写 对象中的方法可以省略function 12345678910const name = &#x27;zs&#x27;const age = 18const person = &#123; name, age, sayHi() &#123; console.log(&#x27;hi&#x27;); &#125;&#125;","categories":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/categories/js/"},{"name":"es6","slug":"js/es6","permalink":"https://bloodthirsty2b.github.io/categories/js/es6/"}],"tags":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/tags/js/"},{"name":"es6","slug":"es6","permalink":"https://bloodthirsty2b.github.io/tags/es6/"}]},{"title":"startsWith & endsWith & includes","slug":"js/es6/startsWith-endsWith-includes","date":"2021-11-04T13:13:50.000Z","updated":"2021-12-20T15:46:37.389Z","comments":true,"path":"2021/11/04/js/es6/startsWith-endsWith-includes/","link":"","permalink":"https://bloodthirsty2b.github.io/2021/11/04/js/es6/startsWith-endsWith-includes/","excerpt":"","text":"startsWith &amp; endsWith &amp; includes （es6字符串新方法 ）语法：1234const str = &#x27;abcdef&#x27;console.log(str.startsWith(&#x27;abc&#x27;));// 判断是否以abc开头console.log(str.endsWith(&#x27;abc&#x27;));// 判断是否以abc结束console.log(str.includes(&#x27;abc&#x27;));// 判断是否包含abc 可以用indexOf替代，不过includes返回布尔值 类似于正则","categories":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/categories/js/"},{"name":"es6","slug":"js/es6","permalink":"https://bloodthirsty2b.github.io/categories/js/es6/"}],"tags":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/tags/js/"},{"name":"es6","slug":"es6","permalink":"https://bloodthirsty2b.github.io/tags/es6/"}]},{"title":"let&const","slug":"js/es6/let-const","date":"2021-11-04T13:03:42.000Z","updated":"2021-12-20T15:46:12.237Z","comments":true,"path":"2021/11/04/js/es6/let-const/","link":"","permalink":"https://bloodthirsty2b.github.io/2021/11/04/js/es6/let-const/","excerpt":"","text":"let &amp; const一、 let特点： 不会预解析 不允许重复声明 123var num = 100let num = 200 // 同样不行 块级作用域 二、 const特点： 不允许修改值 定义的时候必须初始化(赋值)👆 const声明的变量是对象时代表其指针不可改变👈(可以改对象内容) let有的特点const也有 一般变量不会再修改值了就用 const ，并且可以在改变值的时候思考为什么修改(有点像标签的 id )只要是复杂类型一般都用 const 定义(内容可以修改，但是数据类型不能变)(包括数组，对象，函数)","categories":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/categories/js/"},{"name":"es6","slug":"js/es6","permalink":"https://bloodthirsty2b.github.io/categories/js/es6/"}],"tags":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/tags/js/"},{"name":"es6","slug":"es6","permalink":"https://bloodthirsty2b.github.io/tags/es6/"}]},{"title":"forEach&map&filter&some&every","slug":"js/es6/forEach-map-filter-some-every","date":"2021-11-04T13:01:25.000Z","updated":"2021-12-20T15:46:03.796Z","comments":true,"path":"2021/11/04/js/es6/forEach-map-filter-some-every/","link":"","permalink":"https://bloodthirsty2b.github.io/2021/11/04/js/es6/forEach-map-filter-some-every/","excerpt":"forEach &amp; map &amp; filter &amp; some &amp; every &amp; reduce的使用一、forEach1. 语法： 1arr.forEach(回调函数(item, index, array)) 2. 特点： ① 帮忙写了一个for循环，循环次数为数组长度，每次遍历index++，将arr[index]作为item传入回调函数 特殊情况：在回调函数中执行 arr.pop() 或 arr.shift() ，数组变短但是依然根据index的大小来遍历，导致遍历次数减半 ② 可传入一个回调函数循环执行，回调函数可以使用数组的item，index，array三个参数","text":"forEach &amp; map &amp; filter &amp; some &amp; every &amp; reduce的使用一、forEach1. 语法： 1arr.forEach(回调函数(item, index, array)) 2. 特点： ① 帮忙写了一个for循环，循环次数为数组长度，每次遍历index++，将arr[index]作为item传入回调函数 特殊情况：在回调函数中执行 arr.pop() 或 arr.shift() ，数组变短但是依然根据index的大小来遍历，导致遍历次数减半 ② 可传入一个回调函数循环执行，回调函数可以使用数组的item，index，array三个参数 二、map1. 语法： 1arr.map(回调函数(item, index, array)) 2. 相当于做了这么几件事： ① 创建了一个新数组 ② 对数组中的每一项调用回调函数(可以使用item、index和array参数) ③ 无论回调函数返回什么都把返回值添加到这个数组中(如果没有返回值就添加undefined) ④ 返回这个新数组 三、filter1. 语法： 1arr.filter(回调函数(item, index, array)) 2. 相当于做了这么几件事： ① 创建了一个新数组 ② 对数组中的每一项调用回调函数(可以使用item、index和array参数) ③ 只要回调函数返回true，就把这一项添加到这个数组中(如果回调函数只有return true那么所有内容都会被添加到新数组中) ④ 返回这个新数组 四、some（类似于或）1. 语法： 1arr.some(回调函数(item, index, array)) 2. 特点： ① 对数组中的每一项调用回调函数(可以使用item、index和array参数) ② 只要有一个回调函数返回true，跳出循环，整个some函数返回true，否则返回false 五、 every （类似于与）1. 语法： 1arr.every(回调函数(item, index, array)) 2. 特点： ① 对数组中的每一项调用回调函数(可以使用item、index和array参数) ② 只要有一个回调函数没有返回true，跳出循环，整个some函数返回false，否则返回true 六、 reduce（对数组的项进行某种累积运算）1. 语法： 1arr.reduce(回调函数(上一步运算的结果total, item, index, array), 基数) 2. 特点： ① 第一次运算total的值取决于是否给了基数，如果有基数那么使用基数，如果没有则使用array的第一个值，然后将第二个值作为item。 ② 回调函数return的值将作为下一步的total。","categories":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/categories/js/"},{"name":"es6","slug":"js/es6","permalink":"https://bloodthirsty2b.github.io/categories/js/es6/"}],"tags":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/tags/js/"},{"name":"es6","slug":"es6","permalink":"https://bloodthirsty2b.github.io/tags/es6/"}]},{"title":"find & findIndex","slug":"js/es6/find-findIndex","date":"2021-11-04T12:59:08.000Z","updated":"2021-12-20T15:45:53.736Z","comments":true,"path":"2021/11/04/js/es6/find-findIndex/","link":"","permalink":"https://bloodthirsty2b.github.io/2021/11/04/js/es6/find-findIndex/","excerpt":"find &amp; findIndex一、find作用：找到数组中满足条件的第一个项，并返回这个项（满足条件的意思就是回调函数返回了true） 12345678const arr = [ &#123; name: &#x27;ss&#x27;, id: 1 &#125;, &#123; name: &#x27;aa&#x27;, id: 2 &#125;, &#123; name: &#x27;dd&#x27;, id: 3 &#125;]arr.find(function (item, index, arr) &#123; return item.id === 3 // 条件&#125;) 相当于对 arr 中的每一项 (item) 调用传入的函数，如果函数返回了 true ，那么跳出遍历，返回这个项","text":"find &amp; findIndex一、find作用：找到数组中满足条件的第一个项，并返回这个项（满足条件的意思就是回调函数返回了true） 12345678const arr = [ &#123; name: &#x27;ss&#x27;, id: 1 &#125;, &#123; name: &#x27;aa&#x27;, id: 2 &#125;, &#123; name: &#x27;dd&#x27;, id: 3 &#125;]arr.find(function (item, index, arr) &#123; return item.id === 3 // 条件&#125;) 相当于对 arr 中的每一项 (item) 调用传入的函数，如果函数返回了 true ，那么跳出遍历，返回这个项 二、findIndex作用：找到数组中满足条件的第一个项，并返回这个项的下标 123arr.findIndex(function (item) &#123; return item.id === 3&#125;)","categories":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/categories/js/"},{"name":"es6","slug":"js/es6","permalink":"https://bloodthirsty2b.github.io/categories/js/es6/"}],"tags":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/tags/js/"},{"name":"es6","slug":"es6","permalink":"https://bloodthirsty2b.github.io/tags/es6/"}]},{"title":"05-SQL增删改查,node操作SQL","slug":"node/SQL增删改查-node操作SQL","date":"2021-11-02T03:38:49.000Z","updated":"2021-12-20T15:58:20.310Z","comments":true,"path":"2021/11/02/node/SQL增删改查-node操作SQL/","link":"","permalink":"https://bloodthirsty2b.github.io/2021/11/02/node/SQL%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5-node%E6%93%8D%E4%BD%9CSQL/","excerpt":"数据库基本操作一、字段操作(列操作)1. 增加列12345678910alter table &#x27;tableName&#x27; add &#x27;columnName&#x27; int(255)-- 类型长度可变alter table &#x27;tableName&#x27; add ( &#x27;columnName1&#x27; int(255), &#x27;columnName2&#x27; timestamp(8), &#x27;columnName3&#x27; float(5,2))-- 添加多个字段，如果某个新字段和原有的重复了，那么所有的新字段都不会添加-- timestamp类型长度可选，14(显示完整年份且精确到秒)，12(不显示完整年份且精确到秒)，8(完整年份+精确到日期)，6(不完整年份+精确到日期)-- float(5,2)表示这个数一共5位，小数部分2位，例如321.42 2. 修改列12alter table &#x27;tableName&#x27; alter &#x27;columnName&#x27; int(255)-- 修改类型 3. 删除列1alter table &#x27;tableName&#x27; drop column &#x27;columnName&#x27; 4. 获取所有某数据库某表所有列名123select COLUMN_NAME from information_schema.COLUMNS where table_name = &#x27;tableName&#x27; and table_schema = &#x27;databaseName&#x27;-- information_schema.COLUMNS中存有所有数据库所有表的各种信息，包括字段名。从中筛选出需要的某个数据库中的某个表的字段名即可-- 会获取到一个对象数组。每个对象是RowDataPacket类，只有一个COLUMN_NAME成员，存有字段名","text":"数据库基本操作一、字段操作(列操作)1. 增加列12345678910alter table &#x27;tableName&#x27; add &#x27;columnName&#x27; int(255)-- 类型长度可变alter table &#x27;tableName&#x27; add ( &#x27;columnName1&#x27; int(255), &#x27;columnName2&#x27; timestamp(8), &#x27;columnName3&#x27; float(5,2))-- 添加多个字段，如果某个新字段和原有的重复了，那么所有的新字段都不会添加-- timestamp类型长度可选，14(显示完整年份且精确到秒)，12(不显示完整年份且精确到秒)，8(完整年份+精确到日期)，6(不完整年份+精确到日期)-- float(5,2)表示这个数一共5位，小数部分2位，例如321.42 2. 修改列12alter table &#x27;tableName&#x27; alter &#x27;columnName&#x27; int(255)-- 修改类型 3. 删除列1alter table &#x27;tableName&#x27; drop column &#x27;columnName&#x27; 4. 获取所有某数据库某表所有列名123select COLUMN_NAME from information_schema.COLUMNS where table_name = &#x27;tableName&#x27; and table_schema = &#x27;databaseName&#x27;-- information_schema.COLUMNS中存有所有数据库所有表的各种信息，包括字段名。从中筛选出需要的某个数据库中的某个表的字段名即可-- 会获取到一个对象数组。每个对象是RowDataPacket类，只有一个COLUMN_NAME成员，存有字段名 二、行操作1. 增加数据12345insert into 表名 (键1, 键2, ...) values (值1, 值2, ...);-- 如果没有值可传，就写nullinsert into 表名 values (值1, 值2, ...);-- 必须给所有键传值，没有值就写nullinsert into 表名 set 键1=值1, 键2=值2, 键3=值3, ...; 2. 更新(修改)数据1234567-- where 筛选出一条或多条数据update 表名 set 键1=值1, 键2=值2, 键3=值3, ...;-- 这样会将所有数据对应键的值全部修改（很危险）update 表名 set 键1=值1, 键2=值2, 键3=值3, ... where 键=值;-- 根据指定键的指定值来修改某一条或多条数据-- 如果既没有字段名，又找不到这条数据(where找不到)，那么先报错：没有字段名-- 如果找不到这条数据，那么不会报错，而返回的OkPacket对象中affectedRows为0 3. 删除数据1234delete from 表名;-- 会清空整个表的数据（很危险）delete from 表名 where 键=值;-- 根据指定键的指定值来删除某一条或多条数据 4. 查询数据（普通）1234567select * from 表名;-- 查询表中所有的数据select 键1, 键2, ... from 表名;-- 查询每条数据的指定键的值select * from 表名 where 键1=值1;-- 根据指定键的指定值来查询某一条或多条数据-- 查询字符串时注意要给值加上双引号，否则查询的是字段名(列名) 5. 查询数据（组合）123456789101112131415161718192021222324252627282930-- 且 andselect * from 表名 where 键1=值1 and 键2=值2 and ...;-- 查询满足：键1是值1且键2是值2且… 的数据-- 或 orselect * from 表名 where 键1=值1 or 键2=值2 or ...;-- 查询满足：键1是值1或键2是值2或… 的数据-- 模糊查询 like （一般用来搜索）select * from 表名 where 键1 like &quot;%值1%&quot;;--（% → 可以指代若干个任意的字符）-- 根据指定键[包含]指定值来查询某一条或多条数据-- 指定多个值 inselect * from 表名 where 键名 in (值1, 值2, ...);-- 查询所有键是值1或值2或…的所有数据（一般用于批量删除）和or效果类似，不过在字段没有索引时or的效率是O(N)，而in的效率是O(logN) -- 排序 order by xxxselect * from 表名 order by 键名;-- 将查询结果根据键名的值排序（默认升序，从小到大）select * from 表名 order by 键名 desc;（降序） -- 分页 limitselect * from 表名 order by 键名 limit （跳过条数,） 选取条数;-- 查询并排序，展示时跳过第一个参数，展示第二个参数的条数（跳过条数可以省略） -- 总条数 countselect count(*) from 表名;select count(*) as 计数名 from 表名;-- 返回查出数据的条数 三、使用nodejs操作SQL 安装mysql包并导入 npm i mysql const mysql = require(&#39;mysql&#39;) 使用步骤 创建连接 123456789101112const connection = mysql.createConnection(&#123; // 主机地址（必须，根据需要更换） host: &#x27;127.0.0.1&#x27;, // 用户（必须，就是数据库用户） user: &#x27;root&#x27;, // 密码（必须，就是数据库密码） password: &#x27;root&#x27;, // 连接的数据库（必须） database: &#x27;mydatabase&#x27;, // 端口号 port: 3306&#125;) 建立连接 connection.connect() 执行查询操作 123456789connection.query(sql语句, [参数列表,] callback(error, results) =&gt; &#123; if (error) return console.log(error) // results为数组，就算没有数据也会给一个空数组 console.log(results)&#125;)sql语句： 可以用一个或多个?来占位 然后输入实参/实参数组/实参键值对对象作为参数列表（由mysql模块提供语法，其他地方不要用） 也可以传入多个实参时就用字符串拼接/模板字符串 关闭连接（重要）connection.end() 注意：每次调用end之后必须重新建立链接，createConnection的参数也必须重新输入。 操作效果 select results &#x3D;&gt; 返回查询内容[{}, {}, …]，如果没查到会是空数组[]。 delete results &#x3D;&gt; 返回OkPacket对象，包含操作成功后的信息，affectedRows属性表示影响行数。 update、insert和delete相同。 参考：https://www.npmjs.com/package/mysql","categories":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/categories/js/"},{"name":"nodejs","slug":"js/nodejs","permalink":"https://bloodthirsty2b.github.io/categories/js/nodejs/"}],"tags":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/tags/js/"},{"name":"nodejs","slug":"nodejs","permalink":"https://bloodthirsty2b.github.io/tags/nodejs/"}]},{"title":"05-接口化开发,art-template,隐藏域,timeout,FormData,upload,onprogress,jsonp原理,XHR2.0,CORS","slug":"Ajax/04-接口化开发-隐藏域-timeout-FormData-upload-onprogress-jsonp原理-XHR2.0-CORS","date":"2021-11-01T03:10:34.000Z","updated":"2021-12-20T16:01:10.992Z","comments":true,"path":"2021/11/01/Ajax/04-接口化开发-隐藏域-timeout-FormData-upload-onprogress-jsonp原理-XHR2.0-CORS/","link":"","permalink":"https://bloodthirsty2b.github.io/2021/11/01/Ajax/04-%E6%8E%A5%E5%8F%A3%E5%8C%96%E5%BC%80%E5%8F%91-%E9%9A%90%E8%97%8F%E5%9F%9F-timeout-FormData-upload-onprogress-jsonp%E5%8E%9F%E7%90%86-XHR2.0-CORS/","excerpt":"接口化开发请求地址即所谓的接口，通常所说的接口化开发，其实是指一个接口对应一个功能， 并且严格约束了请求参数 和响应结果 的格式，这样前后端在开发过程中，可以减少不必要的讨论， 从而并行开发，可以极大的提升开发效率，另外一个好处，当网站进行改版后，服务端接口进行调整时，并不影响到前端的功能。","text":"接口化开发请求地址即所谓的接口，通常所说的接口化开发，其实是指一个接口对应一个功能， 并且严格约束了请求参数 和响应结果 的格式，这样前后端在开发过程中，可以减少不必要的讨论， 从而并行开发，可以极大的提升开发效率，另外一个好处，当网站进行改版后，服务端接口进行调整时，并不影响到前端的功能。 注册接口表单序列化 jquery提供了一个serialize()方法序列化表单，说白就是将表单中带有name属性的所有参数拼成一个格式为name=value&amp;name1=value1这样的字符串。方便我们获取表单的数据。 1234// serialize将表单参数序列化成一个字符串。必须指定name属性// name=hucc&amp;pass=123456&amp;repass=123456&amp;mobile=18511249258&amp;code=1234$(&#x27;form&#x27;).serialize(); jquery的ajax方法，data参数能够直接识别表单序列化的数据data:$(&#39;form&#39;).serialize() 12345678$.post(&#123; url:&quot;register.php&quot;, data:$(&#x27;form&#x27;).serialize(), dataType:&#x27;json&#x27;, success:function (info) &#123; console.log(info); &#125;&#125;); 模板引擎 是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的HTML文档。 使用模板引擎的好处通过ajax获取到数据后，需要把数据渲染到页面，大量的拼接字符串只适用于结构简单的页面，但是如果页面结构很复杂，使用拼串的话代码可阅读性非常的差，而且非常容易出错，后期代码维护也是相当的麻烦。 【演示：使用拼串进行渲染的缺点.html】 作用：代替前面渲染数据是拼接字符串操作 实际工作渲染数据使用的模板引擎 常见的模板引擎BaiduTemplate：http://tangram.baidu.com/BaiduTemplate/velocity.js：https://github.com/shepherdwind/velocity.js/ArtTemplate：https://github.com/aui/artTemplate artTemplate的使用github地址 中文api地址 artTemplate入门1.引入模板引擎的js文件 1&lt;script src=&quot;template-web.js&quot;&gt;&lt;/script&gt; 2.准备模板 123456789&lt;!-- 指定了type为text/template后，浏览器就无法解析了。--&gt;&lt;script type=&quot;text/template&quot; id=&quot;tmp&quot;&gt; &lt;p&gt;姓名：&#123;&#123; username &#125;&#125;&lt;/p&gt; &lt;p&gt;年龄：&#123;&#123; age &#125;&#125;&lt;/p&gt; &lt;p&gt;技能：&#123;&#123; skill &#125;&#125;&lt;/p&gt; &lt;p&gt;描述：&#123;&#123;desc &#125;&#125;&lt;/p&gt;&lt;/script&gt; 3.准备数据 1234567// 模拟数据,数据是后台获取的，可以随时变化var json = &#123; userName:&quot;hoho&quot;, age:18, skill:&quot;code&quot;, desc:&quot;haha&quot;&#125; 4.将模板与数据进行绑定 1234// 第一个参数：模板的id// 第二个参数：数据（对象格式）// 返回值：根据模板生成的字符串。var html = template(&quot;myTmp&quot;, json); 5.将数据显示到页面 12var div = document.querySelector(&quot;div&quot;);div.innerHTML = html; 注意：传递给模板引擎的数据必须是对象 artTemplate语法if语法 12345&#123;&#123;if gender=&#x27;男&#x27;&#125;&#125; &lt;div class=&quot;man&quot;&gt;&#123;&#123;else&#125;&#125; &lt;div class=&quot;woman&quot;&gt;&#123;&#123;/if&#125;&#125; each语法 123456789101112&lt;!-- 1. &#123;&#123;each data&#125;&#125; 可以通过$value 和 $index获取值和下标 2. &#123;&#123;each data v i&#125;&#125; 自己指定值为v，下标为i--&gt;&#123;&#123;each data v i&#125;&#125;&lt;li&gt; &lt;a href=&quot;&#123;&#123;v.url&#125;&#125;&quot;&gt; &lt;img src=&quot;&#123;&#123;v.src&#125;&#125;&quot; alt=&quot;&quot;&gt; &lt;p&gt;&#123;&#123;v.content&#125;&#125;&lt;/p&gt; &lt;/a&gt; &lt;/li&gt;&#123;&#123;/each&#125;&#125; 12// 如果返回的数据是个数组，必须使用对象进行包裹，因为在&#123;&#123;&#125;&#125;中只写书写对象的属性。var html = template(&quot;navTmp&quot;, &#123;data:info&#125;); 同源与跨域同源不同源 则跨域 同源策略的基本概念 1995年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策。同源策略：最初，它的含义是指，A网页设置的 Cookie，B网页不能打开，除非这两个网页”同源”。现在浏览器的所谓”同源”指的是”三个相同”: 协议相同 域名相同 端口相同 举例来说，http://www.example.com/dir/page.html这个网址，协议是http://，域名是www.example.com，端口是80（默认端口可以省略）。它的同源情况如下。 1234// http://www.example.com/dir2/other.html：同源// http://example.com/dir/other.html：不同源（域名不同）// http://v2.www.example.com/dir/other.html：不同源（域名不同）// http://www.example.com:81/dir/other.html：不同源（端口不同） 同源策略的目的 同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。 同源策略的限制范围 随着互联网的发展，“同源策略”越来越严格，目前，如果非同源，以下三种行为都将收到限制。 123// 1. Cookie、LocalStorage 无法读取。// 2. DOM 无法获得。// 3. AJAX 请求不能发送。 虽然这些限制是很有必要的，但是也给日常开发带来不好的影响。实际开发过程中，往往都会把服务器端架设到一台甚至是一个集群的服务器中，把客户端页面放到另外一个单独的服务器。那么这时候就会出现不同源的情况，如果我们知道两个网站都是安全的话，我们是希望两个不同源的网站之间可以相互请求数据的。这就需要使用到跨域 。 跨域jsonp JSONP(JSON with Padding)、可用于解决主流浏览器的跨域数据访问的问题。 原理：服务端返回一个预先定义好的javascript函数的调用，并且将服务器的数据以该函数参数的形式传递过来，这个方法需要前后端配合。 script 标签是不受同源策略的限制的，它可以载入任意地方的 JavaScript 文件，而并不要求同源。类似的还有img和link标签 1234&lt;!--不受同源策略的标签--&gt;&lt;img src=&quot;http://www.api.com/1.jpg&quot; alt=&quot;&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;http://www.api.com/1.css&quot;&gt;&lt;script src=&quot;http://www.api.com/1.js&quot;&gt;&lt;/script&gt; jquery对于jsonp的封装12345678910111213// 跟普通的get请求没有任何的区别，只需要把dataType固定成jsonp即可。$.ajax(&#123; type:&quot;get&quot;, url:&quot;http://www.api.com/testjs.php&quot;, dataType:&quot;jsonp&quot;, data:&#123; uname:&quot;hucc&quot;, upass:&quot;123456&quot; &#125;, success:function (info) &#123; console.log(info); &#125;&#125;); http://lbsyun.baidu.com/index.php?title=car/api/weather 天气查询api地址 图灵机器人：http://www.tuling123.com/ XMLHttpRequest 2.0 XMLHttpRequest是一个javascript内置对象，使得Javascript可以进行异步的HTTP通信。2008年2月，就提出了XMLHttpRequest Level 2 草案。 老版本的XMLHttpRequest的缺点： 123// 1. 仅支持传输文本数据，无法传说二进制文件，比如图片视频等。// 2. 传输数据时，没有进度信息，只能提示完成与否。// 3. 受到了&quot;同源策略&quot;的限制 新版本的功能： 123// 1. 可以设置timeout 超时时间// 2. 可以使用formData对象管理表单数据// 3. 可以获取数据传输的进度信息 注意：现在使用new XMLHttpRequest创建的对象就是2.0对象了，只要学习一些2.0的新特性即可。 timeout超时事件1234xhr.timeout = 3000;// 设置超时时间xhr.ontimeout = function()&#123; alert(&quot;请求超时&quot;);&#125; formData管理表单数据 formData对象类似于jquery的serialize方法，用于管理表单数据 12345// 使用特点： // 1. 实例化一个formData对象， new formData(form); form就是表单元素// 4. formData对象可以直接作为 xhr.send(formData)的参数。注意此时数据是以二进制的形式进行传输。// 5. formData有一个append方法，可以添加参数。formData.append(&quot;id&quot;, &quot;1111&quot;);// 6. 这种方式只能以post形式传递，不需要设置请求头，浏览器会自动为我们设置一个合适的请求头。 代码示例： 12345678910111213// 1. 使用formData必须发送post请求 xhr.open(&quot;post&quot;, &quot;02-formData.php&quot;); // 2. 获取表单元素var form = document.querySelector(&quot;#myForm&quot;);// 3. 创建form对象，可以直接作为send的参数。var formData = new FormData(form);// 4. formData可以使用append方法添加参数formData.append(&quot;id&quot;, &quot;1111&quot;);// 5. 发送，不需要指定请求头，浏览器会自动选择合适的请求头xhr.send(formData); 文件上传 以前，文件上传需要借助表单进行上传，但是表单上传是同步的，也就是说文件上传时，页面需要提交和刷新，用户体验不好，xhr2.0中的formData对象支持文件的异步上传。 12345var formData = new FormData();// 获取上传的文件，传递到后端var file = document.getElementById(&quot;file&quot;).files[0];formData.append(&quot;file&quot;, file);xhr.send(formData); 显示文件进度信息 xhr2.0还支持获取上传文件的进度信息，因此我们可以根据进度信息可以实时的显示文件的上传进度。 需要注册 xhr.upload.onprogress = function(e)&#123;&#125; 事件，用于监听文件上传的进度.注意：需要在send之前注册。 上传的进度信息会存储事件对象e中 e.loaded表示已上传的大小 e.total表示整个文件的大小 代码参考： 1234567xhr.upload.onprogress = function (e) &#123; inner.style.width = (e.loaded/e.total*100).toFixed(2)+&quot;%&quot;; span.innerHTML = (e.loaded/e.total*100).toFixed(2)+&quot;%&quot;;&#125;xhr.send(formData); 如果上传文件超过8M，php会报错，需要进行设置，允许php上传大文件。 跨域资源共享(CORS)CORS的使用 新版本的XMLHttpRequest对象，可以向不同域名的服务器发出HTTP请求。这叫做“跨域资源共享”（Cross-origin resource sharing，简称CORS）。 跨域资源共享（CORS）的前提 浏览器支持这个功能 服务器必须允许这种跨域。 服务器允许跨域的代码： 1234// 允许所有的域名访问这个接口header(&quot;Access-Control-Allow-Origin:*&quot;);// 允许www.study.com这个域名访问这个接口header(&quot;Access-Control-Allow-Origin:http://www.study.com&quot;); CORS的具体流程 浏览器会根据同源策略 查看是否是跨域请求，如果同源，直接发送ajax请求。 如果非同源，说明是跨域请求，浏览器会自动发送一条请求（预检请求），并不会携带数据，服务器接受到请求之后，会返回请求头信息，浏览器查看返回的响应头信息中是否设置了header(&#39;Access-Control-Allow-Origin:请求源域名或者*&#39;); 如果没有设置，说明服务器不允许使用cors跨域，那么浏览器不会发送真正的ajax请求。 如果返回的响应头中设置了header(&#39;Access-Control-Allow-Origin:请求源域名或者*&#39;);,浏览器会跟请求头中的Origin: http://www.study.com进行对比，如果满足要求，则发送真正的ajax请求，否则不发送。 结论：跨域行为是浏览器行为，是浏览器阻止了ajax行为。服务器与服务器之间是不存在跨域的问题的，所以也可以使用服务器代理来发送ajax。","categories":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/categories/js/"},{"name":"Ajax","slug":"js/Ajax","permalink":"https://bloodthirsty2b.github.io/categories/js/Ajax/"}],"tags":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/tags/js/"},{"name":"Ajax","slug":"Ajax","permalink":"https://bloodthirsty2b.github.io/tags/Ajax/"}]},{"title":"03-AJAX,XML,JSON,jquery-ajax","slug":"Ajax/03-XML-JSON-jquery-ajax","date":"2021-11-01T03:00:28.000Z","updated":"2021-12-20T16:01:01.441Z","comments":true,"path":"2021/11/01/Ajax/03-XML-JSON-jquery-ajax/","link":"","permalink":"https://bloodthirsty2b.github.io/2021/11/01/Ajax/03-XML-JSON-jquery-ajax/","excerpt":"AJAX 即 Asynchronous [e’sɪŋkrənəs] Javascript And XML， AJAX 不是一门的新的语言，而是对现有技术的综合利用。 本质是在HTTP协议的基础上以异步的方式与服务器进行通信。","text":"AJAX 即 Asynchronous [e’sɪŋkrənəs] Javascript And XML， AJAX 不是一门的新的语言，而是对现有技术的综合利用。 本质是在HTTP协议的基础上以异步的方式与服务器进行通信。 同步与异步同步和异步概念： 同步: 指的就是事情要一件一件做。等做完前一件才能做后一件任务 异步: 不受当前任务的影响，两件事情同时进行，做一件事情时，不影响另一件事情的进行。 编程中：异步程序代码执行时不会阻塞其它程序代码执行，从而提升整体执行效率。 ajax技术的应用： 验证你的用户名是否已经存在（一边输入，一边获取你的信息，和后台比对）。 百度搜索提示，及相关内容展示（一边输入，一边找出了你可能要的内容）。 XMLHttpRequest可以以异步方式的处理程序。 XMLHttpRequest 浏览器内建对象，用于与服务器通信(交换数据) ， 由此便可实现对网页的部分更新，而不是刷新整个页面。这个请求是异步，即在往服务器发送请求时，并不会阻碍程序的运行，浏览器会继续渲染后续的结构。 发送get请求XMLHttpRequest以异步的方式发送HTTP请求，因此在发送请求时，一样需要遵循HTTP协议。 123456789101112// 使用XMLHttpRequest发送get请求的步骤// 1. 创建一个XMLHttpRequest对象var xhr = new XMLHttpRequest;// 构造函数没有参数的情况,括号可以省略// 2. 设置请求行// 第一个参数:请求方式 get/post// 第二个参数:请求的地址 需要在url后面拼上参数列表xhr.open(&quot;get&quot;, &quot;08.php?name=hucc&quot;);// 3. 设置请求头// 浏览器会默认添加基本的请求头,get请求时无需设置// 4. 设置请求体// get请求的请求体为空,因为参数列表拼接到url后面了xhr.send(null); get请求,设置请求行时,需要把参数列表拼接到url后面 get请求不用设置请求头 get请求的请求体为null 发送post请求1234567var xhr = new XMLHttpRequest;//1. 设置请求行 post请求的参数列表在请求体中xhr.open(&quot;post&quot;, &quot;09.php&quot;);//2. 设置请求头, post请求必须设置content-type,不然后端无法获取到数据xhr.setRequestHeader(&quot;content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);//3. 设置请求体xhr.send(&quot;name=hucc&amp;age=18&quot;); post请求,设置请求行时,参数列表不能拼接到url后面 post必须设置请求头中的content-type为application&#x2F;x-www-form-urlencoded post请求需要将参数列表设置到请求体中. 获取响应HTTP响应分为3个部分，状态行、响应头、响应体。 12345678910//给xhr注册一个onload事件，当xhr的状态发生状态发生改变时，会触发这个事件。xhr.onload = function () &#123; //1. 获取状态行 console.log(&quot;状态行:&quot;+xhr.status); //2. 获取响应头 console.log(&quot;所有的相应头:&quot;+xhr.getAllResponseHeaders()); console.log(&quot;指定相应头:&quot;+xhr.getResponseHeader(&quot;content-type&quot;)); //3. 获取响应体 console.log(xhr.responseText);&#125; readyState readyState:记录了XMLHttpRequest对象的当前状态 0：请求未初始化。1：请求已经建立，但是还没有开始发送。2：请求已发送，正在处理中3：请求在处理中；通常响应中已有部分数据可用了，但是服务器还没有完成响应的生成。4：响应已完成；您可以获取并使用服务器的响应了。(只需要关注状态4即可) 数据交互XML XML 指可扩展标记语言（EXtensible Markup Language） XML 是一种标记语言，很类似 HTML XML 的设计宗旨是传输数据，而非显示数据 XML 标签没有被预定义。您需要自行定义标签。 语法规范 第一行必须是版本信息 必须有一个根元素（有且仅有一个） 标签不可有空格、不可以数字或.开头、大小写敏感 不可交叉嵌套，都是双标签，如果是单标签，必须闭合 属性双引号（浏览器自动修正成双引号了） 特殊符号要使用实体 注释和HTML一样 1234567891011121314&lt;students&gt; &lt;student&gt; &lt;name&gt;张三&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;gender&gt;男&lt;/gender&gt; &lt;desc&gt;路人甲&lt;/desc&gt; &lt;/student&gt; &lt;student&gt; &lt;name&gt;李四&lt;/name&gt; &lt;age&gt;20&lt;/age&gt; &lt;gender&gt;男&lt;/gender&gt; &lt;desc&gt;路人乙&lt;/desc&gt; &lt;/student&gt;&lt;/students&gt; php获取xml文件的内容 123456// 注意，如果需要返回xml数据，需要把content-type改成text/xml,不然浏览器以text/html进行解析。header(&#x27;content-type:text/xml;charset=utf-8&#x27;);// 用于获取文件的内容// 参数：文件的路径$result = file_get_contents(&quot;data.xml&quot;);echo $result; html解析xml 1234// 获取服务端返回的xml数据，需要使用xhr.responseXML，这是一个document对象，可以使用DOM中的方法查找元素。var data = xhr.responseXML;// 获取所有的学生var students = data.querySelectorAll(&quot;student&quot;); 缺点：虽然可以描述和传输复杂数据，但是其解析过于复杂并且体积较大。 JSON数据JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式。它基于 ECMAScript 规范的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。 数据在名称&#x2F;值对中 数据由逗号分隔(最后一个健&#x2F;值对不能带逗号) 花括号保存对象，方括号保存数组 键使用双引号 12var obj = &#123;a: &#x27;Hello&#x27;, b: &#x27;World&#x27;&#125;; //这是一个对象，注意键名也是可以使用引号包裹的var json = &#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;; //这是一个 JSON 字符串，本质是一个字符串 JSON数据在不同语言进行传输时，类型为字符串，不同的语言各自也都对应有解析方法，需要解析完成后才能读取 php处理json php关联数组&#x3D;&gt; json 123456789// php的关联数组$obj = array( &quot;a&quot;=&gt;&quot;hello&quot;, &quot;b&quot;=&gt;&quot;world&quot;, &quot;name&quot;=&gt;&quot;胡聪聪&quot;);// json字符串$json = json_encode($obj);echo $json; json&#x3D;&gt;php对象 12345678910111213$json = &#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;;//json字符串// 第一个参数：json字符串// 第二个参数： // false，将json转换成对象(默认) // true：将对象转换成数组(推荐)$obj = json_decode($json,true);echo $obj[&#x27;a&#x27;];// 通过json文件获取到的内容就是一个json字符串。$data = file_get_contents(&quot;data.json&quot;);// 将json转换成数组$result = json_decode($data, true);print_r($result); JS处理json JS对象 &#x3D;&gt; JSON字符串 JSON.stringify(obj) 1234// obj是一个js对象var obj = &#123;a: &#x27;Hello&#x27;, b: &#x27;World&#x27;&#125;// result就变成了一个json字符串了var result = JSON.stringify(obj);// &#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27; JSON字符串 &#x3D;&gt; JS对象 JSON.parse(obj) 1234// json是一个json字符串var json = &#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;;// obj就变成了一个js对象var obj = JSON.parse(json);// &#123;a: &#x27;Hello&#x27;, b: &#x27;World&#x27;&#125; 兼容性处理12345678var xhr = null;if(XMLHttpRequest)&#123; // 现代浏览器 xhr = new XMLHttpRequest();&#125;else&#123; // IE5.5支持 xmlHttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);&#125; jQuery中的ajax方法 jQuery提供了更强大的Ajax封装 $.ajax参数列表 参数名称 描述 取值 示例 url 接口地址 url:”02.php” type 请求方式 get&#x2F;post type:”get” timeout 超时时间 单位毫秒 timeout:5000 dataType 服务器返回的格式 json&#x2F;xml&#x2F;text(默认) dataType:”json” data 发送的请求数据 对象 data:{name:”zs”, age:18} beforeSend 调用前的回调函数 function(){} beforeSend:function(){ alert(1) } success 成功的回调函数 function (data) {} success:function (data) {} error 失败的回调函数 function (error) {} error:function(data) {} complete 完成后的回调函数 function () {} complete:function () {} 使用示例： 123456789101112131415161718192021$.ajax(&#123; type:&quot;get&quot;,// 请求类型 url:&quot;02.php&quot;,// 请求地址 data:&#123;name:&quot;zs&quot;, age:18&#125;,// 请求数据 dataType:&quot;json&quot;,// 希望接受的数据类型 timeout:5000,// 设置超时时间 beforeSend:function () &#123; // alert(&quot;发送前调用&quot;); &#125;, success:function (data) &#123; // alert(&quot;成功时调用&quot;); console.log(data); &#125;, error:function (error) &#123; // alert(&quot;失败时调用&quot;); console.log(error); &#125;, complete:function () &#123; // alert(&quot;请求完成时调用&quot;); &#125;&#125;); 其他api12345// $.post(url, callback, [dataType]); // 只发送post请求// $.get(url, callback, [dataType]);// $.getJSON(url, callback);// $.getScript(url,callback); // 载入服务器端的js文件// $(&quot;div&quot;).load(url); // 载入一个服务器端的html页面。","categories":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/categories/js/"},{"name":"Ajax","slug":"js/Ajax","permalink":"https://bloodthirsty2b.github.io/categories/js/Ajax/"}],"tags":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/tags/js/"},{"name":"Ajax","slug":"Ajax","permalink":"https://bloodthirsty2b.github.io/tags/Ajax/"}]},{"title":"02-HTTP协议,请求响应报文,状态码","slug":"Ajax/02-HTTP协议-请求响应报文-状态码","date":"2021-11-01T02:49:39.000Z","updated":"2021-12-20T16:00:41.802Z","comments":true,"path":"2021/11/01/Ajax/02-HTTP协议-请求响应报文-状态码/","link":"","permalink":"https://bloodthirsty2b.github.io/2021/11/01/Ajax/02-HTTP%E5%8D%8F%E8%AE%AE-%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87-%E7%8A%B6%E6%80%81%E7%A0%81/","excerpt":"http协议 协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则 HTTP协议，即超文本传输协议(Hypertext transfer protocol)。是一种详细规定了浏览器和服务器之间互相通信的规则，HTTP协议分为请求 和响应 两个部分组成。","text":"http协议 协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则 HTTP协议，即超文本传输协议(Hypertext transfer protocol)。是一种详细规定了浏览器和服务器之间互相通信的规则，HTTP协议分为请求 和响应 两个部分组成。 请求与请求报文get请求的请求报文详解1234567891011121314151617181920212223242526//--------------------------请求行--------------------------------// GET 请求方式// /01.php?username=hucc&amp;password=123456 请求路径+参数（注意点）// HTTP/1.1 HTTP的版本号GET /01.php?username=hucc&amp;password=123456 HTTP/1.1//--------------------------请求头--------------------------------// Host:主机地址Host: localhost// HTTP1.1版本默认开启，建立过连接后，TCP连接不会断开，下次连接可以继续使用（底层，不用管）Connection: keep-alive// chrome浏览器自己增加的，不用管Upgrade-Insecure-Requests: 1// 浏览器的代理字符串（版本信息）User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.96 Safari/537.36// 浏览器端可以接受的类型。Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,`*/*`;q=0.8// 从哪个页面发出的请求Referer: http://www.study.com/day02/01-login.html// 检查浏览器支持的压缩方式Accept-Encoding: gzip, deflate, sdch// 浏览器支持的语言，优先中文。Accept-Language: zh-CN,zh;q=0.8,en;q=0.6//----------------------------请求体-------------------------------------//get请求没有请求体，但是参数会拼接到请求行中 POST请求的请求报文123456789101112131415161718192021//-----------------------请求行---------------------------------------------POST /01.php HTTP/1.1//-----------------------请求头--------------------------------------------Host: localhostConnection: keep-alive//传递的参数的长度。Content-Length: 29Cache-Control: max-age=0Origin: http:// localhostUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.96 Safari/537.36// 内容类型：表单数据，如果是post请求，必须指定这个属性。Content-Type: application/x-www-form-urlencodedAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,`*/*`;q=0.8Referer: http://localhost/01-login.htmlAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.8,en;q=0.6//------------------------请求体------------------------------------------username=hucc&amp;password=123456 GET请求与POST请求的对比 GET请求没有请求体，因为GET请求的参数拼接到地址栏中了 POST请求有请求体，就是传递的参数 POST请求需要指定content-type属性。 响应与响应报文1234567891011121314151617181920// ---------------------状态行（响应行）-------------------------------// HTTP/1.1 HTTP版本// 200 响应的状态 // 200表示成功 // 304表示读缓存 // 404表示找不到资源 // 500表示服务端错误HTTP/1.1 200 OK// ----------------------响应头-----------------------------------------------Date: Thu, 22 Jun 2017 16:51:22 GMTServer: Apache/2.4.23 (Win32) OpenSSL/1.0.2j PHP/5.4.45X-Powered-By: PHP/5.4.45Content-Length: 18Keep-Alive: timeout=5, max=100Connection: Keep-Alive// 内容类型，告诉浏览器该如何解析响应结果Content-Type: text/html;charset=utf-8// -----------------------响应体------------------------------------------------用户登录成功 谷歌浏览器会对报文进行一定的格式化，看起来虽然不是原生的报文，但是使用起来更加的方便简洁。","categories":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/categories/js/"},{"name":"Ajax","slug":"js/Ajax","permalink":"https://bloodthirsty2b.github.io/categories/js/Ajax/"}],"tags":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/tags/js/"},{"name":"Ajax","slug":"Ajax","permalink":"https://bloodthirsty2b.github.io/tags/Ajax/"}]},{"title":"01-前后端概念,php基本语法,前后端交互get&post","slug":"Ajax/01-前后端概念-php基本语法-前后端交互get-post","date":"2021-11-01T02:32:00.000Z","updated":"2021-12-20T16:00:33.296Z","comments":true,"path":"2021/11/01/Ajax/01-前后端概念-php基本语法-前后端交互get-post/","link":"","permalink":"https://bloodthirsty2b.github.io/2021/11/01/Ajax/01-%E5%89%8D%E5%90%8E%E7%AB%AF%E6%A6%82%E5%BF%B5-php%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92get-post/","excerpt":"Ajax - 前后端的交互技术","text":"Ajax - 前后端的交互技术 服务器软件 使计算机具备提供某种服务能力的应用软件，称为服务器软件，通过安装相应的服务软件，然后进行配置后就可以使计算具备了提供某种服务的能力。 常见的服务器软件： Apache服务器、Nginx 服务器、IIS服务器、Tomcat服务器、 Node服务器等； web服务器即(web服务器)网站服务器，主要提供文档(文本、图片、视频、音频)浏览服务，一般安装Apache、Nginx服务器软件。 服务器可以结合某一编程语言处理业务逻辑，由此进行的开发，通常称之为服务端开发。 常见后台开发的编程语言有： php、java、.net、Python、Ruby、Perl。 客户端 具有向服务器索取服务能力的终端，叫做客户端。 客户端：电脑、平板、手机安装了客户端软件，就可以称为客户端 客户端：安装客户端软件，索取服务的计算机 服务器：安装服务器软件，提供服务的计算机 客户端软件对于前端工程师而言，主要接触到的客户端软件就是浏览器。 以浏览器为宿主环境，结合 HTML、CSS、Javascript等技术，而进行的一系列开发，通常称之为前端开发。 服务器与客户端的关系 在浏览器中展示的所有的资源， 都是存放在服务器中的， 当客户端向服务器发送请求后，服务器会将资源返回给浏览器进行渲染； 动态网页与静态网页 静态网页：使用浏览器端语言进行编程，网站由静态代码（HTML.CSS,JS）组成。用户请求服务器上已经存在的页面，不需要进行业务逻辑的处理。 动态网站 ：网页通过服务器的程序动态生成。用户可以和服务器进行交互（可以根据用户输入的不同信息，返回不同的运行结果），可以处理复杂的业务逻辑。 网络基础ip地址所谓IP地址就是给每个连接在互联网上的主机分配的一个32位地址。(就像每个人的身份证号码一样) 通过ip就可以找到具体的某一台计算机。 例 192.168.1.110 弊端：没有规律，不方便记忆和推广 查看本机IP地址 ping、ipconfig 两种特殊的IP地址： 127.0.0.1作为本地测试的IP地址。本机测试时，客户端与服务器都安装在本地计算机上，数据无需任何网络传输。 192.168开头为局域网的地址。 域名由于IP地址基于数字，不方便记忆，于是便用域名来代替IP地址，域名是一个IP地址的“好记的名字” 查看域名对应的IP地址 ping 1ping jd.com // 可以获取到京东的ip 特殊的域名 ​ localhost，意思为本地主机。这是一个保留域名，主要用于本地测试，对应IP地址为127.0.0.1。 DNS服务器DNS（Domain Name System）因特网上作为域名和IP地址相互映射的一个分布式数据库， 能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。 简单的说就是用于记录IP地址和域名之间的对应关系。 查找优先级 本机hosts文件、DNS服务器 ipconfig &#x2F;flushdns 刷新DNS 端口端口号是计算机与外界通讯交流的出入口，每个端口对应不同的服务。 查看端口占用情况 netstat -an 常见端口号 80、3306、21 本地hosts Hosts是一个没有扩展名的系统文件，可以用记事本等工具打开，其作用就是将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”，当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从Hosts文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交DNS域名解析服务器进行IP地址的解析。 hosts文件的地址：C:\\Windows\\System32\\drivers\\etc 12//hosts文件内容127.0.0.1 localhost PHP基础PHP简介 开源（open source）软件，跨平台，常用操作系统稳定执行。Windows &#x2F; Linux。做WEB开发的经典组合 WAMP,LAMP基本都是开源软件。 入门简单，用户只需要关注应用，开发成本低。 支持的大多数主流数据库。MySQL，oracle,Redis等​ 文件以.php后缀结尾，所有程序包含在&lt;?php 这里是代码 ?&gt;避免使用中文目录和中文文件名 php页面无法直接打开需要运行在服务器环境当中 php初体验1234&lt;?php //echo 相当于document.write echo &quot;hello world&quot;;?&gt; 输入中文乱码问题：如果使用echo输出中文，会乱码。 在php的语法中，末尾必须加分号，不然会报错（最后一行可以不加分号） 12345678&lt;?php //content-Type:text/html;返回内容是一个HTML文档，这样设置后，就能识别HTML标签了。 //charset=utf-8 设置编码集 header(&quot;content-Type:text/html;charset=utf-8&quot;); echo &quot;hello world&quot;; echo &quot;&lt;br/&gt;&quot;; echo &quot;大家好;?&gt; 变量 php是一门弱类型语法，变量的类型可以随意改变。变量其实就是存储数据的容器 变量的命名规则 12345// 1. 不需要关键字进行声明，变量在第一次赋值的时候被创建。// 2. 必须以$符号开始// 3. $后面的命名规则与js的变量命名规则一致。$name = &quot;hoho&quot;;echo $name; 数据类型简单数据类型字符串 12$str = &quot;hoho&quot;;echo $str; 整数 12$num = 100;echo $num; 浮点型 12$float = 11.11;echo $float; 布尔类型 123456$flag = true;// 当布尔类型值为true时，输出1echo $flag;$flag = false;// 当布尔类型为false时，输出空字符串echo $flag; 字符串连接符 1234// 1. 在php中，+号只有算数的功能，并不能拼串// 2. 在php中，拼串使用.$name = &quot;hoho&quot;;echo &quot;大家好，我是&quot; . $name . &quot;，今年18岁&quot;; php中的单引号与双引号 1234567891011121314// 1. 字符串的定义可以使用单引号，也可以使用双引号$name = &quot;hoho&quot;;$desc = &#x27;haha&#x27;;// 2. 双引号可以解析变量// 3. 单引号的性能会高于双引号echo $name;echo $desc;$str = &#x27;$name haha&#x27;;// $name hahaecho $str;$str = &quot;$name haha&quot;;echo $str; 数组 在php中，数组分为两种，索引数组和关联数组 计算数组长度的方法： count(数组名); 索引数组（类似与JS中的数组） 123$arr = array(&quot;张飞&quot;,&quot;赵云&quot;,&quot;马超&quot;);echo $arr;// echo只能打印基本数据类型echo $arr[0];// 张飞 关联数组（类似与JS中的对象） 123// 属性名必须用引号引起来$arr = array(&quot;name&quot;=&gt;&quot;zhangsan&quot;, &quot;age&quot;=&gt;18);echo $arr[&quot;name&quot;]; 输出语句 123//1. echo 输出简单数据类型//2. print_r 输出数据结构，一般用于输出复杂类型。print_r($arr);// print_r是一个函数，不要忘记小括号 语句判断语句基本上，所有语言的if..else语法都是一样 123456$age = 17;if ($age &gt;= 18) &#123; echo &quot;终于可以看电影了,嘿嘿嘿&quot;;&#125; else &#123; echo &quot;哎，还是回家学习吧&quot;;&#125; 循环语句遍历索引数组 123456$arr = array(&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;, &quot;赵六&quot;);// 获取数组的长度： count($arr)for($i = 0; $i &lt; count($arr); $i++) &#123; echo $arr[$i]; echo &quot;&lt;br&gt;&quot;;&#125; 遍历关联数组 123456789//遍历关联数组$arr = array( &quot;name&quot;=&gt;&quot;zs&quot;, &quot;age&quot;=&gt;18, &quot;sex&quot;=&gt;20);foreach($arr as $key =&gt; $value) &#123; echo $key . &quot;=&quot; . $value . &quot;&lt;br&gt;&quot;;&#125; 表单提交 表单（form）：表单用于收集用户输入信息，并将数据提交给服务器。是一种常见的与服务端数据交互的一种方式 action：指定表单的提交地址 method:指定表单的提交方式，get&#x2F;post，默认get input的数据想要提交到后台，必须指定name属性，后台通过name属性获取值 想要提交表单，不能使用input:button 必须使用input:submit php获取表单数据 $_GET是PHP系统提供的一个超全局变量，是一个数组，里面存放了表单通过get方式提交的数据。 $_POST也是PHP系统提供的一个超全局变量，是一个数组，里面存放了表单通过post方式提交的数据。 get与post的区别 get方式 1.1 数据会拼接在url地址的后面?username&#x3D;hcc&amp;password&#x3D;123456 1.2 地址栏有长度限制，因此get方式提交数据大小不会超过4k post方式 2.1 数据不会在url中显示，相比get方式，post更安全 2.2 提交的数据没有大小限制 根据HTTP规范，GET用于信息获取，POST表示可能修改变服务器上的资源的请求","categories":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/categories/js/"},{"name":"Ajax","slug":"js/Ajax","permalink":"https://bloodthirsty2b.github.io/categories/js/Ajax/"}],"tags":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/tags/js/"},{"name":"Ajax","slug":"Ajax","permalink":"https://bloodthirsty2b.github.io/tags/Ajax/"}]},{"title":"04-解绑,触发,事件对象,链式编程,end,隐式迭代,插件使用&封装","slug":"JQuery/04-解绑-触发-事件对象-链式编程-end-隐式迭代-插件使用-封装","date":"2021-11-01T01:57:39.000Z","updated":"2021-12-20T15:51:39.832Z","comments":true,"path":"2021/11/01/JQuery/04-解绑-触发-事件对象-链式编程-end-隐式迭代-插件使用-封装/","link":"","permalink":"https://bloodthirsty2b.github.io/2021/11/01/JQuery/04-%E8%A7%A3%E7%BB%91-%E8%A7%A6%E5%8F%91-%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1-%E9%93%BE%E5%BC%8F%E7%BC%96%E7%A8%8B-end-%E9%9A%90%E5%BC%8F%E8%BF%AD%E4%BB%A3-%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8-%E5%B0%81%E8%A3%85/","excerpt":"事件解绑","text":"事件解绑 unbind方式（不用）12$(selector).unbind(); // 解绑所有的事件$(selector).unbind(&quot;click mouseenter&quot;); //解绑指定的事件 undelegate方式（不用）1234$( selector).undelegate(); // 解绑所有的delegate事件$( selector).undelegate(&quot;click&quot;); // 解绑所有元素的click事件$( selector).undelegate(&quot;p&quot;,&quot;click&quot;); // 解绑指定元素的指定事件$( selector).undelegate(&quot;p,li&quot;,&quot;click&quot;);// 如果是一次性注册多个给多个元素注册事件，那么解绑时也需要将多个选择器写全(顺序也不能颠倒) off方式（推荐） 12345678// 解绑匹配元素的所有事件$(selector).off();// 解绑匹配元素的所有click事件$(selector).off(&quot;click&quot;);// 解绑指定类型元素的委托事件()$(&#x27;div&#x27;).off(&quot;click&quot;,&#x27;p&#x27;) // 如果注册时选择器是多个元素，解绑必须写全多个，位置不能颠倒// 解绑所有的指定委托事件(&#x27;div&#x27;).off(&quot;click&quot;,&#x27;**&#x27;) 触发事件12&lt;button&gt;我是一个按钮&lt;/button&gt;&lt;input type=&quot;button&quot; value=&quot;按钮&quot;&gt; 12345678910111213141516&lt;script src=&quot;jquery-1.12.4.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(function()&#123; $(&#x27;button&#x27;).on(&#x27;click&#x27;, function() &#123; console.log(&#x27;这是给button注册的事件&#x27;); &#125;); $(&#x27;input&#x27;).on(&#x27;click&#x27;, function() &#123; // 触发button的点击事件 // 触发方式1： 直接调用事件名 // 触发方式2 trigger():触发 $(&#x27;button&#x27;).trigger(&#x27;click&#x27;); &#125;); &#125;);&lt;/script&gt; jquery事件对象 eventjQuery事件对象其实就是js事件对象做了兼容性处理 12&lt;button&gt;按钮&lt;/button&gt;&lt;a href=&quot;http://www.baidu.com&quot;&gt;哈哈&lt;/a&gt; 1234567891011121314&lt;script src=&quot;jquery-1.12.4.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(function()&#123; $(&#x27;a&#x27;).on(&quot;click&quot;, function(e) &#123; // e:就是事件对象 // e.stopPropagation() 阻止事件冒泡 // e.preventDefault(); // : 阻止浏览器默认行为 // return false; 即可阻止事件冒泡， 也可以阻止浏览器的默认行为(不推荐) return false; &#125;); &#125;);&lt;/script&gt; jquery链式编程 链式：在jquery中允许我们使用jquery对象连续调用jquery的方法 要求：但是要求链式编程过程每次函数执行完都要返回一个jquery对象，然后继续调用jquery方法 一般在设置性操作时才会使用链式编程，设执行操作后都会返回一个jquery对象 在获取时一般不能使用链式编程，因为获取操作一般返回的都是获取的值，并非jquery对象无法继续调用 链式编程在写法上虽然方便，但是在代码维护上成本高，所以不推荐频繁使用 end() 链式编程中使用了查找’亲戚’的方法，返回的就不是当前对象了 通过观察可以知道有个方法是 prevObject 指向前一个操作的对象 end() 函数内部做的就是通过 prevObject 找到上一个操作对象 通过prevObject这个属性点出来 隐式迭代的概念 隐式迭代：jquery对象不需要自己写for循环，jquery内部会自动遍历 jquery设置操作：内部自动遍历，所有元素都会被设置同样的值，如果需要设置不同的值，就需要自己处理循环 jquery获取操作，直接返回 第一个元素 的样式 显示迭代 each() &#x2F;&#x2F; 参数一：内部dom元素的下标，参数二：dom元素，可以用this直接获取 如：$(“div”).each(function(index,el){}) for循环 &#x2F;&#x2F;常用遍历方式 多库共存 jQuery也是jquery文件暴露的一个对象，可当作$使用 $是jquery文件的暴露的第二个对象 如果$冲突可以用jQuery替换 也可以使用$.noConflic()放弃$控制权，使用 自定变量 接收该方法返回的对象替代$ jquery插件 基于jquery扩展而来具有一定功能的js文件12345div&#123; height:100px; width:100px; background-color:&quot;blue&quot;;&#125; 12&lt;div&gt;&lt;/div&gt;&lt;!-- 动画颜色 渐变没能实现 -&gt; 1$(&quot;div&quot;).animate(&#123;&quot;width&quot;,500,&quot;backgroundColor&quot;:&#x27;red&#x27;&#125;) //backgroundColor 没用怎么办？ jquery.color库的使用1234567&lt;style&gt; div &#123; width: 300px; height: 300px; background-color: green; &#125;&lt;/style&gt; 1&lt;div&gt;&lt;/div&gt; 12345678910&lt;script src=&quot;jquery-1.12.4.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;jquery.color.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(function()&#123; $(&#x27;div&#x27;).animate(&#123; width: 600, backgroundColor: &#x27;red&#x27; &#125;, 1000) &#125;);&lt;/script&gt; jquery.lazyload库的使用 12345&lt;style&gt; div &#123; height: 3000px; &#125;&lt;/style&gt; 12345&lt;div&gt;&lt;/div&gt;&lt;!-- 真实图片的地址放在 data-original--&gt;&lt;!-- *注意了* 此处不能用src不然浏览器会直接通过src解读图片路径 --&gt; &lt;img class=&quot;lazy&quot; data-original=&quot;1.jpg&quot; alt=&quot;&quot; width=&quot;500&quot; height=&quot;350&quot;&gt; &lt;img class=&quot;lazy&quot; data-original=&quot;2.jpg&quot; alt=&quot;&quot;&gt; 12345678910&lt;script src=&quot;jquery-1.12.4.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;jquery.lazyload.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&quot;img.lazy&quot;).lazyload(); //带默认占位图片 $(&quot;img.lazy&quot;).lazyload(&#123; placeholder:&#x27;图片url&#x27; &#125;);&lt;/script&gt; jquery插件封装的原理$.fn.pluginName=function()&#123;&#125; 封装一个小插件12345$.fn.bgc = function(color) &#123; // 在$.fn的方法中， this指的就是当前的jquery对象 this.css(&#x27;backgroundColor&#x27;, color); return this;&#125; 封装一个拖拽插件1234567891011121314151617181920212223$.fn.drag = function() &#123; // 使用变量把this给存起来 var that = this; that.on(&#x27;mousedown&#x27;, function(e) &#123; e.preventDefault(); var x = e.offsetX; // offsetX 当鼠标事件发生时，鼠标相对于事件源x轴的位置 var y = e.offsetY; // offsetY 当鼠标事件发生时，鼠标相对于事件源y轴的位置 $(document).on(&#x27;mousemove&#x27;, function(e) &#123; that.css(&#123; position: &#x27;absolute&#x27;, left: e.pageX - x, //pageX 整个页面包括包括被卷曲 top: e.pageY - y &#125;); &#125;); &#125;); that.on(&#x27;mouseup&#x27;, function() &#123; $(document).off(&#x27;mousemove&#x27;); &#125;); return that;&#125;;","categories":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/categories/js/"},{"name":"JQuery","slug":"js/JQuery","permalink":"https://bloodthirsty2b.github.io/categories/js/JQuery/"}],"tags":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/tags/js/"},{"name":"JQuery","slug":"JQuery","permalink":"https://bloodthirsty2b.github.io/tags/JQuery/"}]},{"title":"03-节点操作,val,宽高,滚动,on注册","slug":"JQuery/03-节点操作-val-宽高-滚动-on注册","date":"2021-11-01T01:50:17.000Z","updated":"2021-12-20T15:51:32.614Z","comments":true,"path":"2021/11/01/JQuery/03-节点操作-val-宽高-滚动-on注册/","link":"","permalink":"https://bloodthirsty2b.github.io/2021/11/01/JQuery/03-%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C-val-%E5%AE%BD%E9%AB%98-%E6%BB%9A%E5%8A%A8-on%E6%B3%A8%E5%86%8C/","excerpt":"jquery节点操作","text":"jquery节点操作 创建节点$()里面放html标签字符串 添加节点append 往父级元素内部的最后面追加子元素12// parantNode.append(childNode)p.append(a) appendTo 子元素追加到父级元素内部的最后面12// childNode.appendTo(parentNode)a.appendTo(p) prepend 往父级元素内部的最前面追加子元素12// parantNode.prepend(childNode)p.prepend(a) prependTo 子元素追加到父级元素内部的最前面12// childNode.prependTo(parantNode)a.prependTo(p) before 追加到元素的前面(同级)123 var siblingDiv = $(&quot;&lt;div class=&#x27;siblingDiv&#x27;&gt;&lt;/div&gt;&quot;)// 原有的元素.before(新加元素) div.before(siblingDiv) after 追加到元素后面(同级)12// 原有的元素.after(新加元素) div.after(siblingDiv) 删除和清空节点remove() 删除自身，内部子元素一并删除 empty() 清空内部所有元素，不包括自身 克隆节点clone() 参数默认false 参数false：克隆标签元素等 参数true：深度克隆 包括事件 jquery特殊属性操作val()设置和获取表单元素的值，如text，textarea等等 html()和text() html() 相当于 innerHtml text() 相当于 innerText width(),height(),innerWidth(),outerWidth(),innerHeight(),outerHeight()width() 无参数：获取元素width 有Number类型参数：设置width innerWidth() 获取元素panding和width outerWidth() 无参数，参数默认是false时：获取元素pading和border和width 参数是true时：获取元素pading和border和width和margin height() 无参数：获取元素高度 有Number类型的参数:设置height innerHeight() 获取元素padding和height outerHeight() 无参数，默认参数是false时： 获取元素padding和border和height 参数是true时：获取元素padding和border和height和margin scrollTop()和scrollLeft() scrollTop() 获取被卷曲的高度, 可设置卷曲高度 scrollLeft() 获取被卷曲的宽度，可设置卷曲高度 js相关的屏幕滚动 window.pageYOffset window.pageXOffset 以屏幕左上角为基准获取卷曲宽高—-只读 document.documentElement.scrollTop document.documentElement.scrollLeft 这两个属性可读可写 $(window) 不支持的动画,可用$(‘html’) position()和offset() offset方法和position方法都是用来获取盒子的位置的 left和top offset() 相对于文档的位置 返回对象 {left:100,top:100} position() 获取相对于自身最近的父元素的位置 offsetLeft和offsetTop 都是返回一个对象 事件注册简单注册方式click(func) / mouseenter(handler) / mouseleave(handler) 缺点: 不能注册多个事件 bind注册 (内部是on实现)$(&quot;p&quot;).bind(&quot;click mouseenter&quot;, function()&#123;&#125;);缺点：不支持动态事件绑定 delegate 事件委托(内部是on实现) 让某一个元素做代理，代处理后代中某一类元素的事件 核心原理:利用事件冒泡，只指定一个事件(绑定给父级)处理程序来管理某一类型的所有事件(绑定给后代)。123456// 第一个参数：selector，要绑定事件的元素// 第二个参数：事件类型// 第三个参数：事件处理函数$(&quot;.parentBox&quot;).delegate(&quot;p&quot;, &quot;click&quot;, function()&#123; // 给.parentBox下面的所有的p标签绑定事件&#125;); 缺点：只能注册委托事件 on注册事件 jQuery1.7之后，jQuery用on统一了所有事件的处理方法。 最现代的方式，兼容zepto(移动端类似jQuery的一个库)，强烈建议使用。 on注册简单事件12// 表示给$(selector)绑定事件，并且由自己触发，不支持动态绑定。 $(selector).on( &quot;click&quot;, function() &#123;&#125;); on注册委托事件12// 表示给$(selector)绑定代理事件，当必须是它的内部元素span才能触发这个事件，支持动态绑定$(selector).on( &quot;click&quot;,“span”, function() &#123;&#125;); on注册事件的语法1234567891011 // on() 注册方式 jquery1.7版本之后，统一注册方式 // jquery对象.on(&quot;click mouseenter&quot;,function()&#123;&#125;) // 自己执行 相当于 bind() // jquery父级对象.on(&quot;click mouseenter&quot;,&quot;后代元素的选择器&quot;，&#123;data&#125;,function(e)&#123;&#125;) // 相当于注册委托事件 // 第一个参数：events，绑定事件的名称可以是由空格分隔的多个事件 // 第二个参数：selector, 执行事件的后代元素（可选），如果没有后代元素，那么事件将由自己执行。 // 第三个参数：data，传递给处理函数的数据，事件触发的时候通过event.data来使用（不常使用） // 第四个参数：handler，事件处理函数$(selector).on(events,[selector],[data],handler);","categories":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/categories/js/"},{"name":"JQuery","slug":"js/JQuery","permalink":"https://bloodthirsty2b.github.io/categories/js/JQuery/"}],"tags":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/tags/js/"},{"name":"JQuery","slug":"JQuery","permalink":"https://bloodthirsty2b.github.io/tags/JQuery/"}]},{"title":"02-动画","slug":"JQuery/02-动画","date":"2021-11-01T01:39:35.000Z","updated":"2021-12-20T15:51:24.510Z","comments":true,"path":"2021/11/01/JQuery/02-动画/","link":"","permalink":"https://bloodthirsty2b.github.io/2021/11/01/JQuery/02-%E5%8A%A8%E7%94%BB/","excerpt":"jquery动画 jquery提供了三组基本动画，这些动画都是标准的、有规律的效果，jquery还提供了自定义动画的功能","text":"jquery动画 jquery提供了三组基本动画，这些动画都是标准的、有规律的效果，jquery还提供了自定义动画的功能 隐藏&#x2F;展示动画(参数为空,没有动画效果):本质就是改变元素的width,height,opacity show(time,func) 展示动画 time：元素展开的动画时间，单位毫秒，可以直接数字，也可以固定字符串形式：fast:快&#x3D;200ms normal：正常&#x3D;400ms slow:慢&#x3D;600ms 运动曲线 func: 回调函数[可选参数],动画执行完成后执行 hide() 隐藏动画 用法和show()一致，只是动画效果是逆向的 toggle() 动画切换，如果当前状态是展示，触发toggle()则隐藏，否则展示 隐藏展示 演示12345678&lt;style&gt; div &#123; width: 400px; height: 400px; background-color: pink; display: none; &#125;&lt;/style&gt; 1234&lt;button&gt;显示&lt;/button&gt;&lt;button&gt;隐藏&lt;/button&gt;&lt;button&gt;切换&lt;/button&gt;&lt;div&gt;&lt;/div&gt; 1234567891011121314151617181920&lt;script src=&quot;jquery-1.12.4.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;button:first&#x27;).click(function() &#123; $(&#x27;div&#x27;).show(1000,&#x27;linear&#x27;,function() &#123; console.log(&#x27;展开动画执行完成&#x27;); &#125;); &#125;); $(&#x27;button&#x27;).eq(1).click(function() &#123; $(&#x27;div&#x27;).hide(1000,function()&#123; console.log(&#x27;隐藏动画执行完成&#x27;); &#125;); &#125;); $(&#x27;button&#x27;).eq(2).click(function() &#123; // 如果是显示状态，就会隐藏， 如果是隐藏状态，就会显示 $(&#x27;div&#x27;).toggle(1000,function()&#123; console.log(&quot;动画切换完成了&quot;); &#125;); &#125;)&lt;/script&gt; 淡入&#x2F;淡出动画(没有参数时默认是normal也就是400ms):本质就是改变元素透明度 1. fadeIn() 2. fadeOut() 3. fadeToggle() 4. **参数，用法和show()/hide()/toggle()一致可以一并记忆，只是动画效果不同** 上、下卷动画(没有参数时默认是normal也就是400ms):本质就是改变元素的height属性 slideDown() slideUp() slideToggle() 参数，用法和show()&#x2F;hide()&#x2F;toggle()一致可以一并记忆，只是动画效果不同 自定义动画 animate() 1. 参数1：必填，给动画设置样式 **是个对象** 2. 参数2：指定动画时间，默认是normal 3. 参数3：指定动画效果 默认是swing ,常用的还有linear等等 4. 参数4：回调函数，动画完成后执行 123456789101112&lt;style&gt; div &#123; width: 100px; height: 100px; background-color: red; position: absolute; left: 0; &#125; div:nth-of-type(2) &#123; margin-top: 200px; &#125;&lt;/style&gt; 123&lt;button&gt;执行动画&lt;/button&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt; 1234567891011121314151617&lt;script src=&quot;jquery-1.12.4.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&#x27;button&#x27;).eq(0).click(function () &#123; // 默认swing $(&#x27;div&#x27;).eq(0).animate(&#123; left: 1000 &#125;, 5000, function () &#123; console.log(&#x27;动画执行结束了&#x27;); &#125;); //声明 swing $(&#x27;div&#x27;).eq(0).animate(&#123; left: 1000 &#125;, 5000, &#x27;swing&#x27;, function ()&#123; console.log(&#x27;动画执行结束了&#x27;); &#125;); // linear 线性运动 $(&#x27;div&#x27;).eq(1).animate(&#123; left: 1000 &#125;, 5000, &#x27;linear&#x27;, function ()&#123; console.log(&#x27;动画执行结束了&#x27;); &#125;); &#125;);&lt;/script&gt; jquery动画队列 jquery为了保证动画不会丢失，使用队列的形式，依次执行动画 所以只要你触发动画事件，就相当于向队列添加一个动画任务,直到执行完成 演示12345678&lt;style&gt; div &#123; width: 100px; height: 100px; background-color: pink; position: absolute; &#125;&lt;/style&gt; 1&lt;div&gt;&lt;/div&gt; 12345678910111213141516171819&lt;script src=&quot;jquery-1.12.4.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // 类似回调地狱执行完在执行下一个,保证不会丢失 // $(&#x27;div&#x27;).animate(&#123;left: 400&#125;, function() &#123; // $(&#x27;div&#x27;).animate(&#123;width: 300&#125;, function() &#123; // $(&#x27;div&#x27;).animate(&#123;height: 300&#125;, function()&#123; // $(&#x27;div&#x27;).animate(&#123;borderRadius: 150&#125;) // &#125;) // &#125;) // &#125;); // 采用链式比较直观 $(&#x27;div&#x27;).animate(&#123;left: 400&#125;).animate(&#123;width: 300&#125;).animate(&#123;height: 300&#125;).animate(&#123;borderRadius: 150&#125;) // 1. 跑到left:400的地方 // 2. 宽度变大为300 // 3. 高度变为300 // 4. 变圆 // 四个步骤依次执行&lt;/script&gt; stop()停止动画 参数一：是否清除被选元素所有加入队列的动画？true&#x2F;false，默认false 参数二: 是否直接跳到最后的执行结果？true&#x2F;false,默认false 如果参数stop(true,true) 第一参数是true动画队列会被清除，所以即使第二参数也是true,但因为动画队列被清除后没有了后续动画也就只会执行到当前动画的最终效果 演示12345678910&lt;style&gt; .animator &#123; height: 150px; width: 150px; background-color: gainsboro; float: left; margin-left: 20px; &#125;&lt;/style&gt; 12345678910111213141516171819202122232425&lt;div class=&quot;animator&quot;&gt;&lt;/div&gt; &lt;button&gt;执行动画队列&lt;/button&gt; &lt;div style=&quot;clear:both&quot;&gt; &lt;p&gt; stop(param1,param2) 两个参数都是布尔类型 &lt;/p&gt; &lt;p&gt; param1:控制是否清空队列，true：清空，false：不清空 &lt;/p&gt; &lt;p&gt; param2:控制是否跳转到当前正在执行的动画的最终效果，true:跳转，false：不跳转 &lt;/p&gt; &lt;hr&gt; &lt;div&gt; &lt;p&gt;默认情况：stop() 参数false 停止当前动画，不清空队列，不跳转当前动画的最终效果&lt;/p&gt; &lt;button&gt;stop()&lt;/button&gt; &lt;p&gt;情况二: stop(true) 第一个参数true,第二参数false 清空队列，不跳转当前动画的最终效果&lt;/p&gt; &lt;button&gt;stop(true)&lt;/button&gt; &lt;p&gt;情况三:stop(true,true) 第一个参数true,第二个参数true 清空队列，跳转当前动画最终效果在清空动画队列&lt;/p&gt; &lt;button&gt;stop(true,true)&lt;/button&gt; &lt;p&gt;情况三:stop(false,true) 第一个参数false,第二个参数true 不清空队列，跳转当前动画最终效果在清空动画队列&lt;/p&gt; &lt;button&gt;stop(false,true)&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738&lt;script src=&quot;./jquery-1.12.4.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./jquery.color.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var div = $(&quot;.animator&quot;) var colors = [&quot;red&quot;, &quot;black&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;olive&quot;, &quot;fuchsia&quot;, &quot;teal&quot;, &quot;aqua&quot;] var count = 0; div.mouseenter(function () &#123; count++; if (count &gt; colors.length) &#123; return &#125; console.log(count); &#125;) $(&quot;button&quot;).eq(0).click(function () &#123; for (var i = 0; i &lt; count; i++) &#123; div.animate(&#123; &quot;backgroundColor&quot;: colors[i] &#125;, 5000, function () &#123; console.log(&quot;执行完~&quot;); &#125;) &#125; &#125;) // 默认情况：stop() 不清空动画队列，不跳转当前动画最终效果 $(&quot;button&quot;).eq(1).click(function () &#123; div.stop().animate(&#123; &quot;width&quot;: 300, &quot;height&quot;: 300 &#125;) &#125;) $(&quot;button&quot;).eq(2).click(function () &#123; div.stop(true).animate(&#123; &quot;width&quot;: 300, &quot;height&quot;: 300 &#125;) &#125;) $(&quot;button&quot;).eq(3).click(function () &#123; div.stop(true, true).animate(&#123; &quot;width&quot;: 300, &quot;height&quot;: 300 &#125;) &#125;) $(&quot;button&quot;).eq(4).click(function () &#123; div.stop(false, true).animate(&#123; &quot;width&quot;: 300, &quot;height&quot;: 300 &#125;) &#125;) &lt;/script&gt;","categories":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/categories/js/"},{"name":"JQuery","slug":"js/JQuery","permalink":"https://bloodthirsty2b.github.io/categories/js/JQuery/"}],"tags":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/tags/js/"},{"name":"JQuery","slug":"JQuery","permalink":"https://bloodthirsty2b.github.io/tags/JQuery/"}]},{"title":"01-入口函数,jq对象转换,jq选择器,mouseenter,addClass,attr&prop","slug":"JQuery/01-入口函数-jq对象转换-jq选择器-mouseenter-addClass-attr-prop","date":"2021-11-01T01:13:36.000Z","updated":"2021-12-20T15:51:13.668Z","comments":true,"path":"2021/11/01/JQuery/01-入口函数-jq对象转换-jq选择器-mouseenter-addClass-attr-prop/","link":"","permalink":"https://bloodthirsty2b.github.io/2021/11/01/JQuery/01-%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0-jq%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2-jq%E9%80%89%E6%8B%A9%E5%99%A8-mouseenter-addClass-attr-prop/","excerpt":"JQuery 官方网址：jQuery官方网站 jQuery是一个快速、小巧、功能丰富的JavaScript库。它使HTML文档遍历和操作、事件处理、动画和Ajax等操作变得更加简单，因为它提供了一个易于使用的API（ application programming interface ），可以跨多种浏览器工作。jQuery结合了通用性和可扩展性，改变了数百万人编写JavaScript的方式。","text":"JQuery 官方网址：jQuery官方网站 jQuery是一个快速、小巧、功能丰富的JavaScript库。它使HTML文档遍历和操作、事件处理、动画和Ajax等操作变得更加简单，因为它提供了一个易于使用的API（ application programming interface ），可以跨多种浏览器工作。jQuery结合了通用性和可扩展性，改变了数百万人编写JavaScript的方式。 JQuery的特点 不需要考虑浏览器的兼容性问题 jquery隐式迭代特性不需要再写繁琐的for循环 获取元素的方式简单多样，不需要原生js那么繁琐 提供一些列动画相关的函数,直接使用，简洁高效 js库的概念 js方法的集合即将js多个常用的js方法，写到一个js文件中，引入页面供我们直接调用 js库有很多种比如zeptojs,seejs,jquery只是其中一种 jquery的版本信息 1.x 兼容IE678(jquery最受欢迎的特色：处理浏览器的兼容性) 2.x 不兼容IE678(更小更快) 3.x jquery compat 3.0.0 兼容[IE8,Opera 12 ,Safari5] 放弃IE6,7 jquery 3.0.0 就面向当前长青浏览器 当前版本放弃IE8 兼容IE9+和其他长青浏览器 如今还在使用jquery绝大部分还在用1.x的版本 压缩版本和非压缩版本的区别 代用.min的版本就是压缩版本，特点是代码经过了压缩和混淆，体积更小，加载速度更快，用于线上生产环境 普通版本代码没有经过压缩，一般用于开发，学习用，体积大 jquery的使用步骤 jquery引入 &lt;script src=&quot;jquery-1.12.4.min.js&quot;&gt;&lt;/script&gt; 入口函数123$(function()&#123;&#125;) 功能实现12345$(function()&#123; // 功能代码&#125;) jquery入口函数入口函数的写法 写法一123$(document).ready(function()&#123;// 直观解析(document)文档(此处文档指页面元素)加载完成(ready)执行函数 // 功能代码&#125;) 写法二(简写)123$(function()&#123; // 功能代码&#125;) 入口函数的好处 文档加载完成执行函数，确保能够获取到元素 形成了一个沙箱，避免了全局变量的污染 相比js的入口函数有何不同？ 12345678window.onload=function()&#123; console.log(1)&#125;$(function(&#123; console.log(1) // jquery 先执行&#125;) JavaScript的入口函数要等到页面中所有资源（包括图片、文件）加载完成才开始执行。 jQuery的入口函数只会等待文档树加载完成就开始执行，并不会等待图片、文件的加载。 jquery入口函数可以多次调用且不会覆盖，onload只能执行一次 jquery对象和dom对象基本认识 使用js方法获取页面的元素返回的对象就是dom对象 使用jquery方法获取页面元素的返回的对象就是jquery对象关系：jquery对象内部是一个伪数组，内部存放就是dom对象 jquery对象和js对象的区别 jquery对象不能直接使用dom的方法 dom对象也不能使用jquery对象的方法 jquery对象和dom对象的相互转换1. dom对象转换成jquery对象 1DomObj+$()=&gt;$(DomObj) // 只需要用$()包住dom对象即可 2. jquery对象转dom对象 方法一：$(&#39;li&#39;).get(1) 方法二：$(&#39;li&#39;)[1] 解析：jquery对象是dom对象的合集，是一个伪数组，我们只需要从伪数组中取出dom即可 JQuery选择器 jquery为我们提供的一组方法，目的是更加方便的获取到页面的元素 jquery兼容了几乎所有的css的选择器，也添加了更多复杂的选择器 jquery的选择器很多，所以获取一个元素的方式就不止一种，所以常用的选择器并不多 jQuery完全兼容css选择器 名称 用法 描述 ID选择器 $(“#id”); 获取指定ID的元素 类选择器 $(“.class”); 获取同一类class的元素 标签选择器 $(“div”); 获取同一类标签的所有元素 并集选择器 $(“div,p,li”); 使用逗号分隔，只要符合条件之一就可。 交集选择器 $(“div.redClass”); 获取class为redClass的div元素 子代选择器 $(“ul&gt;li”); 使用&gt;号，获取儿子层级的元素，注意，并不会获取孙子层级的元素 后代选择器 $(“ul li”); 使用空格，代表后代选择器，获取ul下的所有li元素，包括孙子等 跟CSS的选择器一模一样。 过滤选择器 注意：这类选择器都带 冒号: 名称 用法 描述 :eq（index） $(“li:eq(2)”).css(“color”, ”red”); 获取到的li元素中，选择索引号为2的元素，索引号index从0开始 :odd $(“li:odd”).css(“color”, ”red”); 获取到的li元素中，选择索引号为奇数的元素 :even $(“li:even”).css(“color”, ”red”); 获取到的li元素中，选择索引号为偶数的元素 :first $(“li:first”).css(“color”, ”red”); 获取到的li元素中的第一个 :last $(“li:last”).css(“color”, ”red”); 获取到的li元素中的最后一个 筛选选择器(JQuery方法) 筛选选择器的功能与过滤选择器有点类似，但是用法不一样，筛选选择器主要是方法。回忆js中常用找亲戚的方法如：childNodes，parentNode，nextSbiling，previousSbiling，firstChild，lastChild 名称 用法 描述 children(selector) $(“ul”).children(“li”) 获取当前元素的所有子元素中的li元素 find(selector) $(“ul”).find(“li”) 获取当前元素中的后代元素中的li元素 siblings(selector) $(“#first”).siblings(“li”) 查找兄弟节点，不包括自己本身。 parent() $(“#first”).parent() 查找父亲 eq(index) $(“li”).eq(2) 相当于$(“li:eq(2)”),index从0开始 next() $(“li”).next() 找下一个兄弟 prev() $(“li”).prev() 找上一次兄弟 children()查找子元素 children(selector)查找指定子元素mouseover鼠标经过事mouseout:鼠标离开事件mouseenter:鼠标进入事件mouseleave：鼠标离开事件 mouseenter和mouseleave1234567891011121314151617181920212223&lt;style&gt; .container &#123; width: 800px; height: 800px; background-color: seagreen; padding: 100px; margin: 0 auto; &#125; .parent &#123; height: 600px; width: 600px; background-color: aqua; padding: 100px; &#125; .son &#123; width: 400px; height: 400px; background-color: sienna; padding: 100px; &#125; &lt;/style&gt; 12345&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;script src=&quot;jquery-1.12.4.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; var container = $(&quot;.container&quot;) var parent = $(&quot;.parent&quot;) var son = $(&quot;.son&quot;) // container.mouseover(function () &#123; // console.log(&quot;container over&quot;); // &#125;) // parent.mouseover(function () &#123; // console.log(&quot;parent over&quot;); // &#125;) // son.mouseover(function () &#123; // console.log(&quot;son over&quot;); // &#125;) // container.mouseout(function () &#123; // console.log(&quot;container out&quot;); // &#125;) // parent.mouseout(function () &#123; // console.log(&quot;parent out&quot;); // &#125;) // son.mouseout(function () &#123; // console.log(&quot;son out&quot;); // &#125;) // mouseenter和mouseleave container.mouseenter(function () &#123; console.log(&quot;container enter&quot;); &#125;) parent.mouseenter(function () &#123; console.log(&quot;parent enter&quot;); &#125;) son.mouseenter(function () &#123; console.log(&quot;son enter&quot;); &#125;) container.mouseleave(function () &#123; console.log(&quot;container leave&quot;); &#125;) parent.mouseleave(function () &#123; console.log(&quot;parent leave&quot;); &#125;) son.mouseleave(function () &#123; console.log(&quot;son leave&quot;); &#125;) // mouseover和mouseout 存在冒泡 // mouseenter和mouseleave 不存在冒泡 &#125;) &lt;/script&gt; find(selector)找到指定元素，siblings()找到所有兄弟元素 index() 获取元素索引值12345678&lt;ul&gt; &lt;li&gt;0&lt;/li&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt;&lt;/ul&gt; 12345678&lt;script src=&quot;jquery-1.12.4.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(function()&#123; $(&quot;li&quot;).click(function()&#123; console.log(&quot;index&quot;,$(this).index()) // 打印出索引 &#125;) &#125;)&lt;/script&gt; .eq(index)根据下标获得指定jquery对象 .get(index)根据下标获得dom对象index()方法获得jquery对象的索引值 JQuery操作样式 style：行内样式 class：类样式（主要方式） css()：采用的是行内 情况一： css(name,value)给元素添加一个样式，直接给样式名称和值 情况二： css({key:value,key2:value2}) 给元素添加多个样式，参数传入对象 情况三： css(name) 当只传入样式名的时候，返回该样式名称的值 注意 隐式迭代：设置操作的时候，如果是多个元素，那么给所有的元素设置相同的值 获取操作的时候，如果是多个元素，那么只会返回第一个元素的值。123456&lt;style&gt; div&#123; width: 500px; height: 500px; &#125;&lt;/style&gt; 1&lt;div&gt;&lt;/div&gt; 1234567891011121314&lt;script src=&quot;jquery-1.12.4.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 给元素添加单个样式 $(&#x27;div&#x27;).css(&quot;backgroundColor&quot;,&#x27;red&#x27;) // 给元素添加多个样式 $(&#x27;div&#x27;).css(&#123; &quot;backgroundColor&quot;:&#x27;red&#x27;, &#x27;border&#x27;:&#x27;2px solid black&#x27;, &quot;margin&quot;:&#x27;100px auto&#x27; &#125;) // 获取样式的值 var sv=$(&#x27;div&#x27;).css(&#x27;border&#x27;) //此处如果有多个div，只返回第一个元素的该样式的值 console.log(&quot;样式的值&quot;,sv) &lt;/script&gt; jquery操作classjs中操作类名的方法 classList.add(“className”); 添加类名 classList.remove(“className”); 删除类名 classList.contains(‘className’); 是否包含类名 classList.toggle(‘className’); 切换类名 常用方法介绍12345678910111213&lt;style&gt; .base &#123; background-color: pink; &#125; .fz &#123; font-size: 50px; &#125; .red &#123; color: red; &#125;&lt;/style&gt; 123&lt;div&gt;AAAAA&lt;/div&gt;&lt;div&gt;BBBBB&lt;/div&gt;&lt;div&gt;CCCCC&lt;/div&gt; addClass(name): 添加类名，同时操作多个类名，中间空格隔开1$(&#x27;div&#x27;).addClass(&#x27;base fz&#x27;) removeClass(name): 移除指定类，同时操作多个类名，中间空格隔开1$(&#x27;div&#x27;).removeClass(&#x27;fz&#x27;) // 如果参数为空，就会移除掉该元素所有的类名 toggleClass(name): 切换类名，同时操作多个类名，中间空格隔开1$(&#x27;div&#x27;).toggleClass(&#x27;red&#x27;) // 所谓切换，就是如果有该类名则删除，如果没有则添加 hasClass(name): 是否有某个类名，同时操作多个类名，中间空格隔开,顺序不能变1$(&#x27;div&#x27;).hasClass(&#x27;red&#x27;) // 返回true或者false，如果有多个元素只判断&quot;第一个&quot; addClass()添加了名siblings()获取兄弟节点index()获取索引值removeClass()移除class JQuery操作属性js中操作属性 setAttribute 设置属性 getAttribute 获取属性 常用方法12&lt;img src=&quot;imgs/01.jpg&quot; alt=&quot;&quot;&gt;&lt;img src=&quot;imgs/02.jpg&quot; alt=&quot;&quot;&gt; attr() 设置属性 情况一： attr(name,value) // 设置单个属性$(&#39;img&#39;).attr(&quot;title&quot;,&quot;这是图片&quot;) 情况二: attr(&#123;key:value,key2:value2&#125;) // 设置多个属性$(&#39;img&#39;).attr(&#123; &quot;title&quot;: &quot;这是图片&quot;, &#39;alt&#39;: &#39;哈哈&#39; &#125;) 情况三: attr(name) // 获取属性的值$(&#39;img&#39;).attr(&#39;title&#39;) removeAttr() 移除单个或者多个属性12$(&#x27;img&#x27;).removeAttr(&#x27;alt&#x27;) // 移除单个属性$(&#x27;img&#x27;).removeAttr(&#x27;alt title&#x27;) // 移除多个属性中间用&quot;空格隔开&quot; 布尔类型的属性操作attr操作布尔属性的bug1234 &lt;!-- 这段代码使用attr操作布尔类型的属性有Bug --&gt;&lt;button&gt;选中&lt;/button&gt;&lt;button&gt;不选中&lt;/button&gt;&lt;input type=&quot;checkbox&quot;&gt; 12345678$(&#x27;button:first&#x27;).click(function () &#123; $(&#x27;input&#x27;).attr(&#x27;checked&#x27;, true); console.log($(&#x27;input&#x27;).attr(&#x27;checked&#x27;)); &#125;); $(&#x27;button:last&#x27;).click(function () &#123; $(&#x27;input&#x27;).attr(&#x27;checked&#x27;, false); console.log($(&#x27;input&#x27;).attr(&#x27;checked&#x27;)); // undefined &#125;); prop()1.6版本以后凡是布尔类型属性如：checked disabled selected不在使用attr来操作，换成prop 123456789$(&#x27;button:first&#x27;).click(function() &#123; $(&#x27;input&#x27;).prop(&#x27;checked&#x27;, true); console.log($(&#x27;input&#x27;).prop(&#x27;checked&#x27;));&#125;);$(&#x27;button:last&#x27;).click(function() &#123; $(&#x27;input&#x27;).prop(&#x27;checked&#x27;, false); console.log($(&#x27;input&#x27;).prop(&#x27;checked&#x27;));&#125;);// 功能正常 attr和prop用法区别 attr() 处理非布尔类型的固有的或者 自定义属性 prop() 处理自带属性和布尔类型属性， 不能自定义属性","categories":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/categories/js/"},{"name":"JQuery","slug":"js/JQuery","permalink":"https://bloodthirsty2b.github.io/categories/js/JQuery/"}],"tags":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/tags/js/"},{"name":"JQuery","slug":"JQuery","permalink":"https://bloodthirsty2b.github.io/tags/JQuery/"}]},{"title":"grid布局语法参考","slug":"css/grid布局","date":"2021-10-16T09:08:01.000Z","updated":"2021-12-20T15:55:42.937Z","comments":true,"path":"2021/10/16/css/grid布局/","link":"","permalink":"https://bloodthirsty2b.github.io/2021/10/16/css/grid%E5%B8%83%E5%B1%80/","excerpt":"将网页划分成一个个网格，可以任意组合不同的网格 grid布局语法参考 grid布局是将网页划分成一个个网格，并将其任意组合的布局方法。类似于以前的table布局。 和flex布局的区别：flex是围绕轴线进行的一系列布局方法；而grid是将容器划分为行和列进行布局，其灵活性更高。 兼容性：有较大兼容性问题，参考caniuse-grid","text":"将网页划分成一个个网格，可以任意组合不同的网格 grid布局语法参考 grid布局是将网页划分成一个个网格，并将其任意组合的布局方法。类似于以前的table布局。 和flex布局的区别：flex是围绕轴线进行的一系列布局方法；而grid是将容器划分为行和列进行布局，其灵活性更高。 兼容性：有较大兼容性问题，参考caniuse-grid 容器属性布局属性： display: grid; 块级元素 display: inline-grid; 行内块元素 设置属性： grid-template-columns 123456789101112131415161718192021222324/* 把容器分为宽度为100px的三列 */grid-template-columns: 100px 100px 100px;/* 把容器等分为三列 */grid-template-columns: 33.33% 33.33% 33.33%;grid-template-columns: repeat(3, 33.33%);/* 把容器分为100px 20px 80px 100px 20px 80px的六列 */grid-template-columns: repeat(2, 100px 20px 80px);/* 用100px分列，直到将容器宽度撑满 */grid-template-columns: repeat(auto-fill, 100px);/* 容器第一列为150px，剩下的宽度以1：2均分(fr:fraction) */grid-template-columns: 150px 1fr 2fr;/* 容器第三列最小宽为100px，最大为一个片段长度 */grid-template-columns: 1fr 1fr minmax(100px, 1fr);/* 容器一三列为100px，中间自行撑开或撑满 */grid-template-columns: 100px auto 100px;/* 将网格线命名为c1、c2、c3、c4或lala，可对同一根网格线命名为多个名字 */grid-template-columns: [c1] 100px [c2] 100px [c3] auto [c4 lala]; grid-template-rows:; &#x3D;&gt; 语法和 grid-template-columns 相同，对容器分行； column-gap: 20px; &#x3D;&gt; 给每列之间设置20px的间距 （row-gap: ; 用法相同）； gap: &lt;row-gap&gt; &lt;column-gap&gt;; &#x3D;&gt; 将column-gap和row-gap 合写。如果省略了第二个值，那么默认第二个值和第一个相同； 使用gap的时候会把gap的厚度加入到grid的宽高中，超过100%会导致溢出问题，可使用fr变通 grid-template-areas 123456789/* 给区域命名 */grid-template-areas: &#x27;a b c&#x27; &#x27;d e f&#x27; &#x27;g h i&#x27;;/* 用. 代替不用的区域 */grid-template-areas: &#x27;a . c&#x27; &#x27;d . f&#x27; &#x27;g . i&#x27;; 注意，区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为区域名-start，终止网格线自动命名为区域名-end。 grid-auto-flow: column; &#x3D;&gt; 将先行后列的排列顺序改为先列后行的顺序 grid-auto-flow: row dense; &#x3D;&gt; 先行后列，并且尽可能紧密填满，尽量不出现空格。 justify-items、align-items、place-items 12345678/* justify-items属性设置单元格内容的水平位置（左中右），align-items属性设置单元格内容的垂直位置（上中下） */justify-items: start | end | center | stretch;align-items: start | end | center | stretch;/* place-items属性是align-items属性和justify-items属性的合并简写形式。省略第二个值，浏览器默认与第一个值相等。*/place-items: &lt;align-items&gt; &lt;justify-items&gt;; justify-content、align-content、place-content 123456/* justify-content属性是整个内容区域在容器里面的水平位置（左中右），align-content属性是整个内容区域的垂直位置（上中下）。*/justify-content: start | end | center | stretch | space-around | space-between | space-evenly;align-content: start | end | center | stretch | space-around | space-between | space-evenly; /* place-content属性是align-content属性和justify-content属性的合并简写形式。省略第二个值，浏览器默认与第一个值相等。*/place-content: &lt;align-content&gt; &lt;justify-content&gt;; grid-auto-rows 12/* grid-auto-columns属性和grid-auto-rows属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与grid-template-columns和grid-template-rows完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。*/grid-auto-rows: 50px; 项目属性 grid-column-start、grid-column-end、grid-row-start、grid-row-end、grid-column、grid-row 1234567891011121314151617/* 值可以是数字、网格线名字、跨行跨列span(end不会覆盖start) *//* 指定项目左边框所在的垂直网格线在第一条网格线上 */grid-column-start: 1 | c1-start | span 2;/* 指定项目右边框所在的垂直网格线在第三条网格线上 */grid-column-end: 3 | c2-end | span 2;/* 指定项目上边框所在的水平网格线在第一条网格线上 */grid-row-start: 1 | r1-start | span 2;/* 指定项目下边框所在的水平网格线在第三条网格线上 */grid-row-end: 3 | r2-end | span 2;/* grid-column属性是grid-column-start和grid-column-end的合写形式，grid-row属性是grid-row-start属性和grid-row-end的合写形式。*//* 上面的代码可以合写为下面的 */grid-column: 1 / 3;grid-row: 1 / span 2; grid-area: d &#x3D;&gt; 指定项目放在哪一个区域。 justify-self、align-self、place-self 12345678/* justify-self属性设置项目内内容的水平位置（左中右），跟justify-items属性的用法完全一致。*/justify-self: start | end | center | stretch;/* align-self属性设置项目内内容的垂直位置（上中下），跟align-items属性的用法完全一致。*/align-self: start | end | center | stretch;/* place-self属性是align-self属性和justify-self属性的合写形式。省略第二个值，浏览器默认认为这两个值相等。 */place-self: &lt;align-self&gt; &lt;justify-self&gt;; 用法参考：grid布局","categories":[{"name":"css","slug":"css","permalink":"https://bloodthirsty2b.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://bloodthirsty2b.github.io/tags/css/"}]},{"title":"promise,async,await","slug":"js/es6/promise-async-await","date":"2021-09-18T11:02:57.000Z","updated":"2021-12-20T15:46:25.230Z","comments":true,"path":"2021/09/18/js/es6/promise-async-await/","link":"","permalink":"https://bloodthirsty2b.github.io/2021/09/18/js/es6/promise-async-await/","excerpt":"promise,async,awaitpromisePromise最大的好处是在异步执行的流程中，把执行代码和处理结果的代码清晰地分离了 语法： 123456789// 创建const p = new promise((resolve, reject) =&gt; &#123; ... resolve() ... reject()&#125;)// 使用p.then(fn1).catch(fn2) 特点： 创建promise实例时，需要传入一个回调函数，该回调函数有两个函数参数，执行过程中会在你需要的时机调用两个传入的函数 使用promise时，p.then()内传入的函数就是第一个参数resolve的执行内容，p.catch()内传入的函数就是第二个参数reject的执行内容","text":"promise,async,awaitpromisePromise最大的好处是在异步执行的流程中，把执行代码和处理结果的代码清晰地分离了 语法： 123456789// 创建const p = new promise((resolve, reject) =&gt; &#123; ... resolve() ... reject()&#125;)// 使用p.then(fn1).catch(fn2) 特点： 创建promise实例时，需要传入一个回调函数，该回调函数有两个函数参数，执行过程中会在你需要的时机调用两个传入的函数 使用promise时，p.then()内传入的函数就是第一个参数resolve的执行内容，p.catch()内传入的函数就是第二个参数reject的执行内容 promise配合async&amp;await使用1234567891011// 只有带有async的函数内部才能使用await// 使用函数包裹p的执行，在函数内部使用await等待p执行结束（只有p执行完了才能往下继续执行）// foo内部可以使用判断来实现then和catch方法，如果p内部会报错（例如读取文件）就使用try~catch来分别实现then和catch方法async function foo () &#123; await p if (...) &#123; fn1 &#125; else &#123; fn2 &#125;&#125;","categories":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/categories/js/"},{"name":"es6","slug":"js/es6","permalink":"https://bloodthirsty2b.github.io/categories/js/es6/"}],"tags":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/tags/js/"},{"name":"es6","slug":"es6","permalink":"https://bloodthirsty2b.github.io/tags/es6/"}]},{"title":"06-动画,短路运算,轮播图,offset,scroll,client,classList,移动端事件","slug":"webAPI/06-动画-短路运算-轮播图-offset-scroll-client-classList-移动端事件","date":"2021-01-13T08:07:35.000Z","updated":"2021-12-20T15:52:51.616Z","comments":true,"path":"2021/01/13/webAPI/06-动画-短路运算-轮播图-offset-scroll-client-classList-移动端事件/","link":"","permalink":"https://bloodthirsty2b.github.io/2021/01/13/webAPI/06-%E5%8A%A8%E7%94%BB-%E7%9F%AD%E8%B7%AF%E8%BF%90%E7%AE%97-%E8%BD%AE%E6%92%AD%E5%9B%BE-offset-scroll-client-classList-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%BA%8B%E4%BB%B6/","excerpt":"动画函数封装","text":"动画函数封装 实现div到left&#x3D;400的位置1点击按钮，让div能够移动到400的位置，到达终点，清除定时器 让div做多个动画123点击按钮1，让div能够移动到400的位置，到达终点，清除定时器点击按钮2，让div能够移动到800的位置，到达终点，清除定时器还要让div能够从800 移动到400的位置，到达终点，清除定时器 div到达终点1让div移动到96px的位置，发现元素不能移动到终点位置 清除多个定时器1点击元素多次，会发现元素会左右来回移动，到达不了终点。 短路运算&amp;&amp;：短路与， 只要碰到了false，就会短路，短路后不会执行第二个表达式。 ||：短路或，只要碰到了true就会短路，短路后不会执行第二个表达式。 注意：&amp;&amp;和||的结果不一定是布尔类型，也可以是其他的类型 ||经常用来给函数设置默认值 轮播图简单轮播图1231. 结构分析2. 按钮高亮以及排他3. 移动图片：渐渐的移动图片，用到animate函数 左右焦点图1231.结构分析2.左右箭头的显示与隐藏3.点击左箭头与右箭头（下标判断） 无缝轮播图121. 需要添加假图片2. 真图片与假图片之间互相切换。 完整版轮播图1234561. js动态添加小圆点2. js动态添加最后一张假图片3. 实现左右焦点图 + 无缝滚动4. 自动播放5. 点击小圆点同步切换6. 解决点击小圆点的bug 三大家族offset家族 offset系列用于用于获取元素自身的大小和位置，在网页特效中有广泛应用 offset系列主要有：offsetHeight、offsetWidth、offsetParent、offsetLeft、offsetTop offsetHeight与offsetWidth 获取的是元素真实的高度和宽度 获取到的是数值类型，方便计算 offsetHeight与offsetWidth是只读属性，不能设置。 offsetHeight与offsetWidth的构成 ​ offsetHeight &#x3D; height + paddnig + border ​ offsetWidth &#x3D; width + padding + border scroll家族 scroll家族用来获取盒子内容的大小和位置 scroll家族有：scrollWidth、scrollHeight、scrollLeft、scrollTop scrollWidth与scrollHeight是盒子内容的真实的宽度和高度。与和盒子大小无关，仅仅与盒子的内容有关系。 scrollTop用于获取内容垂直滚动的像素数。如果没有滚动条，那么scrollTop值是0 onscroll事件，对于有滚动条的盒子，可以使用onscroll注册滚动事件，每滚动一像素，就会触发该事件。 1234var box = doucment.getElementById(“box”);box.onscroll = function()&#123; // 事件处理程序&#125; 获取页面被卷去的高度和宽度 通常来说，scroll家族用的最多的地方就是用来获取页面被卷去的宽度和高度，非常的常用 页面被卷去的高度和宽度 1234window.onscroll = function() &#123; var scrollTop = window.pageYOffset var scrollLeft = window.pageXOffset&#125; client家族 client家族用于获取盒子可视区的大小 client家族有clientWidth、clientHeight、clientLeft、clientTop clietnWidth: 获取内容和padding的大小 clientHeight:获取内容与padding的大小 clientTop与clientLeft clientTop与clientLeft 完全没有用，他们就是borderTop与borderLeft 三大家族对比 onresize事件：onresize事件会在窗口被调整大小的时候发生。 12345window.onresize = function()&#123; // 事件处理程序 var width = window.innerWidth; var height = window.innerHeight&#125; 类名操作 推荐：classList是一个集合，会存储某个元素上所有的类名，使用classList来替代className操作class类 12345678//添加类node.classList.add(&quot;classname&quot;);//移除类node.classList.remove(&quot;classname&quot;);//切换类node.classList.toggle(&quot;classname&quot;);//判断类node.classList.contains(&quot;classname&quot;); 移动端touch事件移动端新增了4个与手指触摸相关的事件。 1234// touchstart:手指放到屏幕上时触发// touchmove:手指在屏幕上滑动式触发（会触发多次）// touchend:手指离开屏幕时触发// touchcancel:系统取消touch事件的时候触发,比如电话 每个触摸事件被触发后，会生成一个event对象，event对象中changedTouches会记录手指滑动的信息。 123e.touches;// 当前屏幕上的手指e.targetTouches;// 当前dom元素上的手指。e.changedTouches;// 触摸时发生改变的手指。(重点) 这些列表里的每次触摸由touch对象组成，touch对象里包含着触摸信息，主要属性如下 12clientX / clientY: // 触摸点相对浏览器窗口的位置pageX / pageY: // 触摸点相对于页面的位置","categories":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/categories/js/"},{"name":"webAPI","slug":"js/webAPI","permalink":"https://bloodthirsty2b.github.io/categories/js/webAPI/"}],"tags":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/tags/js/"},{"name":"webAPI","slug":"webAPI","permalink":"https://bloodthirsty2b.github.io/tags/webAPI/"}]},{"title":"05-BOM,window,定时器,延时器,location,navigator,history","slug":"webAPI/05-BOM-window-定时器-延时器-location-navigator-history","date":"2021-01-11T02:02:39.000Z","updated":"2021-12-20T15:52:37.646Z","comments":true,"path":"2021/01/11/webAPI/05-BOM-window-定时器-延时器-location-navigator-history/","link":"","permalink":"https://bloodthirsty2b.github.io/2021/01/11/webAPI/05-BOM-window-%E5%AE%9A%E6%97%B6%E5%99%A8-%E5%BB%B6%E6%97%B6%E5%99%A8-location-navigator-history/","excerpt":"","text":"BOM BOM（Browser Object Model）：浏览器对象模型，提供了一套操作浏览器功能的工具。 BOM包含的内容很多，但是除了定时器、延时器外很多东西都不太常用 。 window对象 window对象是一个全局对象，也可以说是JavaScript中的顶级对象 像document、alert()、console.log()这些都是window的属性，其实BOM中基本所有的属性和方法都是属性window的。 所有定义在全局作用域中的变量、函数都会变成window对象的属性和方法 window对象下的属性和方法调用的时候可以省略window window.onload window.onload事件会在窗体加载完成后执行，通常我们称之为入口函数。 1234window.onload = function()&#123; // 里面的代码会在窗体加载完成后执行。 // 窗体加载完成包括文档树的加载、还有图片、文件的加载完成。&#125; 延时器与定时器setTimeout setTimeout延时器可以在延迟时间到期后执行一个指定的函数。 设置延时器 12345678// 语法：setTimeOut(callback, time);// 参数1：回调函数，时间到了就会执行。// 参数2：延时的时间// 返回：定时器的id，用于清除// 示例：var timer = setTimeOut(function()&#123; // 1秒后将执行的代码。&#125;, 1000); 清除延时器 1234// 语法：clearTimeOut(timerId)// 参数：定时器id// 示例：clearTimeOut(timer);// 清除上面定义的定时器 setInterval setInterval,方法重复调用一个函数或执行一个代码段，在每次调用之间具有固定的时间延迟。定时器除非清除，否则会一直执行下去。 设置定时器 12345678// 语法：var intervalID = setInterval(func, delay);// 参数1：重复执行的函数// 参数2：每次延迟的毫秒数// 返回：定时器的id，用于清除// 示例：var timer = setInterval(function()&#123; // 重复执行的代码。&#125;, 1000); 清除定时器 1234// 语法：clearInterval(intervalID)// 参数：定时器id// 示例：clearInterval(timer);// 清除上面定义的定时器 location对象 location对象也是window的一个属性，location其实对应的就是浏览器中的地址栏。 常用属性和方法 location.href：控制地址栏中的地址 12location.href = “http:www.baidu.com”;// 让页面跳转到百度首页console.log(window.location.search);// 参数 location.reload()：让页面重新加载 navigator对象 window.navigator的一些属性可以获取客户端的一些信息 1// navigator.userAgent：浏览器版本 history对象history对象表示页面的历史 123456// 后退：history.back();history.go(-1);// 前进：history.forward();history.go(1);","categories":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/categories/js/"},{"name":"webAPI","slug":"js/webAPI","permalink":"https://bloodthirsty2b.github.io/categories/js/webAPI/"}],"tags":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/tags/js/"},{"name":"webAPI","slug":"webAPI","permalink":"https://bloodthirsty2b.github.io/tags/webAPI/"}]},{"title":"04-事件注册,事件对象,事件流,offset","slug":"webAPI/04-事件注册-事件对象-事件流-offset","date":"2021-01-06T02:48:09.000Z","updated":"2021-12-20T15:52:30.579Z","comments":true,"path":"2021/01/06/webAPI/04-事件注册-事件对象-事件流-offset/","link":"","permalink":"https://bloodthirsty2b.github.io/2021/01/06/webAPI/04-%E4%BA%8B%E4%BB%B6%E6%B3%A8%E5%86%8C-%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1-%E4%BA%8B%E4%BB%B6%E6%B5%81-offset/","excerpt":"注册事件的两种方式","text":"注册事件的两种方式 on+事件名称 onclick、onmouseover这种on+事件名称的方式注册事件几乎所有的浏览器都支持。 注册事件： 123box.onclick = function()&#123; //事件处理程序 &#125; 移除事件： 1box.onclick = null; on+事件名称注册事件的缺点： 同一个元素同一类型的事件，只能注册一个，如果注册了多个，会出现覆盖问题。 注册事件的新方式addEventListener与removeEventListener 现代浏览器支持的注册事件的新方式，这种方式注册的事件不会出现覆盖问题。 addEventListener的语法 1234// 第一个参数：事件的类型：click mouseover// 第二个参数：函数，监听者，每次点击，这个函数就执行。// 第三个参数：是否使用捕获，默认为false，表示冒泡addEventListener(type, func, useCapture); tips：如果想要让你注册的事件能够移除，不能使用匿名函数。 12345function fn1() &#123; alert(&quot;hehe&quot;);&#125;// 如果想让注册的事件能移除，不能用匿名函数。box.addEventListener(&quot;click&quot;, fn1, false); removeEventListen的语法 1234// 第一个参数：参数类型// 第二个参数：要移除的那个函数// 第三个参数：falseremoveEventListener(type, func, useCapture); attachEvent与detachEvent IE678不支持addEventListener与removeEventListen两个方法，但是支持attachEvent与detachEvnet attachEvent的用法： 123// type:事件类型 需要加上on onclick onmouseenter// func:需要执行的那个事件attachEvent(type, func) detachEvent的用法 123// type:事件类型 需要加上on onclick onmouseenter// func:需要执行的那个事件detachEvent(type, func) 事件对象事件对象的概述 在触发某个事件的时候，都会产生一个事件对象Event，这个对象中包含所有与事件相关的一些信息，包括触发事件的元素，事件的类型以及其他与事件相关的信息。 鼠标事件触发时，事件对象中会包含鼠标的位置信息。 键盘事件触发时，事件对象中会包含按下的键相关的信息。 获取事件对象 既然事件对象中存储了这么多的信息，我们首先需要做的就是获取到这个事件对象。 获取事件对象非常的简单，只需要在注册事件的时候，指定一个形参即可。这个形参就是我们想要获取到的事件对象。 1234btn.onclick = function(event)&#123; // event就是事件对象，里面包含了事件触发时的一些信息。 console.log(event);&#125; 事件对象的常用属性 事件对象中有很多很多的属性，但是很多属性并不常用。我们经常用到的是鼠标位置信息 和键盘码 相关的信息。 记录了鼠标位置信息的相关属性 123screenX与screenY：光标相对于屏幕左上角的水平位置与垂直位置。clientX与clientY：光标相对于可视区左上角的水平位置和垂直位置。pageX与pageY：光标相对于网页（文档document）左上角的水平位置与垂直位置（推荐使用） 记录了键盘码的属性 1获取键盘码: 在键盘事件中，通过e.keyCode可以获取到按下的键盘码 offset系列offsetHeight与offsetWidth offsetHeight与offsetWidth 1231. 获取的是元素真实的高度和宽度2. 获取到的是数值类型，方便计算3. offsetHeight与offsetWidth是只读属性，不能设置。 1获取宽度和高度offsetWidth与offsetHeight offsetParent parentNode和offsetParent 121. parentNode始终是父元素2. offsetParent是离当前元素最近的定位元素(absolute、relative)，如果没有，那就找body offsetLeft与offsetTop offsetLeft: 自身左侧到offsetParent左侧的距离； offsetTop:自身顶部到offsetParent顶部的距离； 1231. 元素自身与offsetParent真实的距离2. 获取到的是数值类型，方便计算3. 只读属性，只能获取，不能设置 放大镜效果 放大镜在开发中是一个很常见的特效，但是所有的放大镜的实现效果都是一样。 【放大镜特效】 实现思路： 123451. 给box注册onmouseover事件，让big和mask显示2. 给box注册onmouseout事件，让big和mask隐藏3. 给box注册onmousemove事件，获取鼠标在box中的位置，让mask跟着移动4. 限定mask的移动范围5. 根据比例让bigImg跟着移动 事件流事件冒泡 当一个元素的事件被触发时，同样的事件将会在该元素的所有祖先元素中依次被触发。这一过程被称为事件冒泡。 说白了就是：当我们触发了子元素的某个事件后，父元素对应的事件也会触发。 事件捕获 事件捕获是火狐浏览器提出来的，IE678不支持事件捕获（基本上，我们都是用事件冒泡）事件的处理将从DOM层次的根开始，而不是从触发事件的目标元素开始，事件被从目标元素的所有祖先元素依次往下传递 1234// 当addEventListener第三个参数为true时，表示事件捕获arr[i].addEventListener(&quot;click&quot;, function () &#123; console.log(this);&#125;, true); 事件的三个阶段 事件的捕获阶段 事件的目标阶段（触发自己的事件） 事件的冒泡阶段 事件有三个阶段，首先发生的是捕获阶段，然后是目标阶段，最后才是冒泡阶段，让addEventLinstener第三个参数为true时，表示该事件在捕获阶段发生，如果第三个参数为false，表示该事件在冒泡阶段发生。 阻止事件冒泡 通过e.stopPropagation()方法可以阻止事件冒泡 事件补充：阻止浏览器默认行为 阻止浏览器默认行为除了使用 return false。 还可以通过 e.preventDefault() 可以阻止浏览器的默认行为 常见的事件 常见的鼠标事件 onmousedown:鼠标按下事件 onmouseup:鼠标弹起事件 onclick:单击事件 ondblclick：双击事件 onmouseover：鼠标经过事件 onmouseout：鼠标离开事件 onmousemove：鼠标移动事件 onfocus：鼠标获得焦点事件 onblur：鼠标失去焦点事件 常见的键盘事件 onkeydown:键盘按下时触发 onkeyup:键盘弹起时触发 对于鼠标事件，事件对象中有一系列的XY记录了鼠标的位置信息。 键盘事件中，事件对象有一个event.keyCode属性，记录了按下去的键的键盘码","categories":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/categories/js/"},{"name":"webAPI","slug":"js/webAPI","permalink":"https://bloodthirsty2b.github.io/categories/js/webAPI/"}],"tags":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/tags/js/"},{"name":"webAPI","slug":"webAPI","permalink":"https://bloodthirsty2b.github.io/tags/webAPI/"}]},{"title":"03-兄弟、父子节点,onkeyup,添加,删除,克隆,创建节点","slug":"webAPI/03-兄弟、父子节点-onkeyup-添加-添加-删除-克隆-创建节点","date":"2021-01-03T02:38:09.000Z","updated":"2021-12-20T15:52:23.178Z","comments":true,"path":"2021/01/03/webAPI/03-兄弟、父子节点-onkeyup-添加-添加-删除-克隆-创建节点/","link":"","permalink":"https://bloodthirsty2b.github.io/2021/01/03/webAPI/03-%E5%85%84%E5%BC%9F%E3%80%81%E7%88%B6%E5%AD%90%E8%8A%82%E7%82%B9-onkeyup-%E6%B7%BB%E5%8A%A0-%E6%B7%BB%E5%8A%A0-%E5%88%A0%E9%99%A4-%E5%85%8B%E9%9A%86-%E5%88%9B%E5%BB%BA%E8%8A%82%E7%82%B9/","excerpt":"节点操作","text":"节点操作 节点查找子节点123456// childNodes:获取所有的孩子节点（包括了元素节点和其他很多类型的节点）// children:获取所有的子元素（用途很广泛）// firstChild //第一个子节点// firstElementChild //第一个子元素// lastChild //最后一个节点// lastElementChild //最后一个子元素 兄弟节点1234// 1. nextSibling:下一个兄弟节点// 2. nextElementSibling:下一个兄弟元素// 3. previousSibling // 上一个兄弟节点// 4. previousElementSibling // 上一个兄弟元素 父节点1// 1. parentNode:父节点 onkeydown与onkeyup事件12341. onkeydown: 当键盘按下时触发的事件2. onkeyup: 键盘弹起时触发的事件注意：如果给文本框注册的是onkeydown事件，获取的value值是上一次的。 添加节点appendChild语法：parent.appendChild(child) parent: 调用者，父节点来调用 child:需要添加的那个孩子。 作用：把child添加到parent的孩子的最后面。 如果添加的是页面中本来就存在的元素，是一个剪切的效果，原来的就不在了。 123var demo = document.getElementById(&quot;demo&quot;);var box = document.getElementById(&quot;box&quot;);box.appendChild(demo); insertBefore语法：parent.insertBefore(child, refChild); parent：必须要父节点来调用 child：需要添加的那个节点 refChild：添加到哪一个节点的前面。 12345var ul = document.getElementById(&quot;list&quot;);var li = document.createElement(&quot;li&quot;);li.innerHTML = &quot;拉拉&quot;;// 就是添加到子节点的最前面。ul.insertBefore(li, ul.children[0]); 克隆节点语法：var newNode &#x3D; node.cloneNode(deep) 功能：在内存中克隆一份节点 参数：deep false：默认值，是浅复制，只会复制标签，节点本身，不会复制文本节点和子标签。 true：深度复制，会复制标签，还会复制标签的所有内容 — 常用 克隆出来的节点跟原来的节点没有关系了，修改了也不会相互影响。 如果克隆的节点带了id，我们需要给id重新设置一个值，不让id冲突 注意：只有内联事件&lt;div onclick=&quot;&quot;&gt;&lt;/div&gt;和attachEvent(是ie的bug)会被克隆，addEventListener和onclick注册的事件不会克隆。还想要后者注册的事件可以用4种方法： 重新注册事件 使用内联事件 使用事件委托 使用jquery的clone方法 删除节点语法：parent.removeChild(child); 功能：由父盒子调用，删除里面的一个子元素。 创建节点（3种方式）document.write（基本不用）可以生成新的节点，但是不推荐使用。如果页面已经加载完成了，你还是用document.write写内容的话，会把之前的页面给覆盖掉 原理：页面从上往下加载的时候，会开启一个文档流，当页面加载完，文档流就会关闭。 document.write的本意就是在文档流上写入内容。如果页面没加载完成，文档流还是开着的，document.write直接在这个文档流上写东西 如果页面加载完成了，还是用document.write写东西，会重新开启一个新的文档流，往新的文档流上写东西，旧的文档流就被新的文档流覆盖了。 innerHTMLinnerHTML也可以创建节点 innerHTML创建节点的时候有一个特点，如果原来有内容的话，使用innerHTML会把原先的内容给干掉。 慎用：很容易出现性能效率问题。 createElement语法：var element &#x3D; document.createElement(“tagName”); 作用：在内存里面创建了一个节点 返回：一个元素。 用途非常的广泛。","categories":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/categories/js/"},{"name":"webAPI","slug":"js/webAPI","permalink":"https://bloodthirsty2b.github.io/categories/js/webAPI/"}],"tags":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/tags/js/"},{"name":"webAPI","slug":"webAPI","permalink":"https://bloodthirsty2b.github.io/tags/webAPI/"}]},{"title":"02-innerText,js表单属性,style属性,自定义属性","slug":"webAPI/02-a链接不跳转-innerText-js表单属性-style属性-自定义属性","date":"2020-12-27T02:27:59.000Z","updated":"2021-12-20T15:52:15.127Z","comments":true,"path":"2020/12/27/webAPI/02-a链接不跳转-innerText-js表单属性-style属性-自定义属性/","link":"","permalink":"https://bloodthirsty2b.github.io/2020/12/27/webAPI/02-a%E9%93%BE%E6%8E%A5%E4%B8%8D%E8%B7%B3%E8%BD%AC-innerText-js%E8%A1%A8%E5%8D%95%E5%B1%9E%E6%80%A7-style%E5%B1%9E%E6%80%A7-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7/","excerpt":"标签的内容属性","text":"标签的内容属性 innerText和innerHTML属性都是用来获取和设置标签的内容的。但是二者还是有区别的。 innerHTML可以用于获取和设置标签的所有内容，包括标签和文本内容 123// innerHTML:内部的HTML// 获取标签内容的时候，不管标签还是文本，都能获取到// innerHTML设置内容的时候，覆盖原来内容，标签也能生效，浏览器能解析这个标签。 innerText可以用于获取和设置标签的文本内容，会丢弃掉标签 123//innerText:内部文本// 获取标签内容的时候，只会获取文本，标签扔掉了// 设置标签内容的时候，覆盖原来内容，对标签进行转义（目的：把标签直接当文本来用） 二者的区别： innerHTML能够识别标签，标签能够生效 innerText只识别文本，标签会被转义 表单属性操作 常见的表单属性有：disabled、type、value、checked、selected 对于disabled、checked、selected三个属性来说，比较特殊。 12在标签中，只要指定了disabled属性，无论有值没值，都代表这个input是被禁用的。注意，标签的disabled仅仅是默认值。在DOM对象中，disabled的属性是一个布尔类型的属性，值只有true或者false 样式操作（style属性） 标签不仅可以通过class属性操作样式，还可以通过style属性操作样式。同样的DOM对象可以通过className操作样式，也可以通过style属性操作样式。 123// 1. style属性是一个对象，里面存储了所有行内样式对应的键值对。// 2. 如果样式的名字带了-，比如background-color,到了style对象中，变成了驼峰命名法，backgroundColor（因为-在js中不是一个合法的标识符）// 3. style属性只能获取和设置行内样式，在类样式中定义的样式通过style获取不到。 style设置的样式是行内样式，因此优先级要高于className设置的样式 document常用属性：12341. document.body: body比较常用，并且在页面中时唯一的，因此可以使用document.body直接获取。2. document.documentElement: 可以获取html元素3. document.head: 可以直接获取head元素4. document.title: 可以直接获取title的文本 获取元素的方法根据id获取123//参数：元素的id//返回值：一个元素，如果id不存在，返回nulldocument.getElementById(&quot;id&quot;); 根据标签名获取1234// 参数：标签名// 返回值：伪数组，无论有几个元素，返回都是伪数组document.getElementsByTagName(&quot;tagName&quot;);box.getElementsByTagName(&quot;tagName&quot;); 根据类名获取123// 参数：字符串类型的类名// 返回值：伪数组document.getElementsByClassName(&quot;class&quot;) 注意：这个方法ie678不支持 根据name获取12// 只适用于表单元素var ps = document.getElementsByName(&quot;aa&quot;); 根据css选择器获取1234567// 参数：是一个css选择器， 如果是类选择器， .demo 如果是id选择器： #aa// 返回值：只会返回一个对象，如果有很多个，会返回第一个document.querySelector();// 参数：是一个css选择器// 返回值：会返回伪数组，不管有多少个，都会返回伪数组document.querySelectorAll(); 标签的自定义属性 我们之前讨论的属性，都是HTML规范中，标签本来就有的属性，对于标签自定义的一些属性，比较特殊。 在html页面中，定义一个自定义属性 1&lt;div id=&quot;box&quot; aa=&quot;bb&quot;&gt;&lt;/div&gt; 在对应的DOM对象中是不存在的，在DOM对象中只会存在固定的那些属性。 12var box = document.getElementById(&quot;box&quot;);console.log(box.aa);// undefined attribute方法 attribute系列方法用于设置标签的属性，不管是自定义的还是固有的属性。 123456// 获取标签的属性box.getAttribute(name);// 设置标签的属性box.setAttribute(name, value);// 移除标签的属性box.removeAttribute(name);","categories":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/categories/js/"},{"name":"webAPI","slug":"js/webAPI","permalink":"https://bloodthirsty2b.github.io/categories/js/webAPI/"}],"tags":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/tags/js/"},{"name":"webAPI","slug":"webAPI","permalink":"https://bloodthirsty2b.github.io/tags/webAPI/"}]},{"title":"1.WebApi基本概念、DOM获取元素&注册事件","slug":"webAPI/01-DOM-getElementXx","date":"2020-12-23T01:53:49.000Z","updated":"2021-12-20T15:52:07.926Z","comments":true,"path":"2020/12/23/webAPI/01-DOM-getElementXx/","link":"","permalink":"https://bloodthirsty2b.github.io/2020/12/23/webAPI/01-DOM-getElementXx/","excerpt":"WebApi基本概念API（Application Programming Interface,应用程序编程接口）,API是一些预先定义的方法，这些方法能够实现某些特定的功能。 任何开发语言都会提供自己的API API的特征输入和输出(参数&#x2F;返回值)","text":"WebApi基本概念API（Application Programming Interface,应用程序编程接口）,API是一些预先定义的方法，这些方法能够实现某些特定的功能。 任何开发语言都会提供自己的API API的特征输入和输出(参数&#x2F;返回值) ECMAScript - JavaScript的核心 定义了JavaScript 的语法规范 JavaScript的核心，描述了语言的基本语法和数据类型，ECMAScript是一套标准，定义了一种语言的标准。与具体实现无关 BOM - 浏览器对象模型 一套操作浏览器功能的API 通过BOM可以操作浏览器窗口，比如：弹出框、控制浏览器跳转、获取分辨率等 DOM - 文档对象模型 一套操作页面元素的API DOM可以把HTML看做是文档树，通过DOM提供的API可以对树上的节点进行操作 DOM-文档对象模型DOM基本概念 DOM（Document Object Model）文档对象模型，是W3C组织推荐的一套用于处理HTML的标准编程接口。 DOM又称为文档树模型，因为整个HTML文档是一个树形的结构 DOM中常见的概念 文档document：一个网页可以称为文档 节点node：网页中的所有内容都是节点（标签、属性、文本、注释等） 元素element：网页中的标签 DOM初体验 document.getElementById(&quot;box&quot;)的作用是根据页面中元素的id来获取元素 在DOM中，想要操作一个元素，首先需要先获取到这个元素才能进行操作。 123456//功能：通过id获取元素//参数：字符串类型的id值//返回值：元素，如果id不存在，会返回nullvar div = document.getElementById(&#x27;main&#x27;);console.dir(div); 关于console.log和console.dir的区别 console.log打印一个元素的时候，是以标签的形式进行展示的 console.dir打印一个元素的时候，是以对象的形式进行展示的 在DOM中，页面标签的属性和DOM对象的属性是一一对应的，因此我们可以通过修改DOM对象的属性来修改标签的属性。 1234567891011&lt;!-- html内容 --&gt;&lt;div title=&quot;hehe&quot; id=&quot;box&quot;&gt;&lt;script&gt;// javascript代码var div = document.getElementById(&#x27;box&#x27;);div.title = &quot;哈哈&quot;;&lt;/script&gt;&lt;!-- 结果：div标签的title属性就发生了更改 --&gt;&lt;div title=&quot;哈哈&quot; id=&quot;box&quot;&gt; 获取元素使用getElementById的注意事项 如果id不存在，会返回null 在DOM中，document.getElementById(&quot;box&quot;)方法需要写在html内容的后面，保证页面加载完成之后才能获取到内容。 部分浏览器，如果元素设置了id属性，可以直接使用（但是不是规范，不推荐） 当getElementById返回null的时候，null.onclick就会报错 12345678&lt;!--没有id--&gt;&lt;img src=&quot;images/1.jpg&quot; alt=&quot;图破了&quot; title=&quot;呵呵&quot;&gt;&lt;script&gt; // 如果找不到，返回的是null，试图给null设置属性会报错 var element = document.getElementById(&quot;img&quot;); element.title = &quot;嘿嘿&quot;;// 报错Uncaught TypeError: Cannot set property &#x27;title&#x27; of null&lt;/script&gt; mdn地址 getElementsByTagName 通过标签名获取元素 123// 参数：标签名// 返回值：一个伪数组， 伪数组不是数组，不能使用数组的方法，但是可以跟数组一样进行遍历和使用下标进行操作。var divs = document.getElementsByTagName(&#x27;div&#x27;); 注意：返回值有没有获取到元素，都是一个伪数组，即便元素只有一个 缩小查找范围 document.getElemntsByTagName(&quot;div&quot;)表示获取页面中所有的div元素，范围太大了，可以使用box.getElementsByTagName(&quot;div&quot;)表示获取box中所有的div元素，范围更小。 document.getElementById(&quot;demo&quot;)表示获取页面中id为box的元素，没有box.getElementById(&quot;demo&quot;)这种用法。 注册事件事件的基本使用 事件：触发-响应机制 事件三要素： 事件源:触发事件的元素 事件名称: click 点击事件 事件处理程序:事件触发后要执行的代码(函数形式) 注册事件的基本语法： 12345var box = document.getElementById(&#x27;box&#x27;);// on:当 click:点击 当按钮被点击的时候触发box.onclick = function() &#123; console.log(&#x27;代码会在box被点击后执行&#x27;); &#125;; 注意：事件处理程序并不是立马执行，而是当事件触发的时候在会执行（浏览器会自动调用） 修改标签的属性 在DOM中，页面标签的属性和DOM对象的属性是一一对应的，因此我们可以通过修改DOM对象的属性来修改标签的属性。 标签的alt，title，src，width，height等属性，可以直接通过对象进行修改。 如果是class属性，在js中class是关键字，因此对应的是className属性 鼠标经过事件与鼠标离开事件 12onmouseover:当鼠标经过时触发onmouseout:当鼠标离开时触发 事件中的this 当在事件中表示当前元素的时候，可以使用this 12345var btn = document.getElementById(&quot;btn&quot;);btn.onclick = function() &#123; // 给 btn注册的事件，因此this表示btn this.value = &quot;哈哈&quot;;&#125; 阻止a标签跳转 对于a标签来说，默认的行为就是进行页面跳转，如果不想让a标签进行跳转，可以在注册事件中使用return false 123456var link = document.getElementById(&quot;link&quot;);link.onclick = function() &#123; alert(&quot;呵呵&quot;); // 阻止页面跳转 return false;&#125; 标签的内容属性 innerText &amp;&amp; innerHTML","categories":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/categories/js/"},{"name":"webAPI","slug":"js/webAPI","permalink":"https://bloodthirsty2b.github.io/categories/js/webAPI/"}],"tags":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/tags/js/"},{"name":"webAPI","slug":"webAPI","permalink":"https://bloodthirsty2b.github.io/tags/webAPI/"}]},{"title":"过滤器","slug":"css/mobile/05-过滤器","date":"2020-11-16T12:48:50.000Z","updated":"2021-12-20T15:57:18.497Z","comments":true,"path":"2020/11/16/css/mobile/05-过滤器/","link":"","permalink":"https://bloodthirsty2b.github.io/2020/11/16/css/mobile/05-%E8%BF%87%E6%BB%A4%E5%99%A8/","excerpt":"一些常用过滤器 :not()可以用来排除某些属性 12p.chosen:not(.other-chosen)/* 可以代表包含chosen类而不包含other-chosen类 */","text":"一些常用过滤器 :not()可以用来排除某些属性 12p.chosen:not(.other-chosen)/* 可以代表包含chosen类而不包含other-chosen类 */","categories":[{"name":"css","slug":"css","permalink":"https://bloodthirsty2b.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://bloodthirsty2b.github.io/tags/css/"}]},{"title":"rem,less","slug":"css/mobile/04-rem-less","date":"2020-11-15T12:34:50.000Z","updated":"2021-12-20T15:57:09.283Z","comments":true,"path":"2020/11/15/css/mobile/04-rem-less/","link":"","permalink":"https://bloodthirsty2b.github.io/2020/11/15/css/mobile/04-rem-less/","excerpt":"为什么要用rem？ rem的主要目的就是解决用于不同屏幕的适配问题。rem能够等比例的适配所有的屏幕。 1单纯使用流式布局的结果是宽度自适应 高度是写死的 导致不能完全适配设计图(因为不同的屏幕大小下 高度永远是写死的), 而使用rem就可以让高度也保持自适应效果","text":"为什么要用rem？ rem的主要目的就是解决用于不同屏幕的适配问题。rem能够等比例的适配所有的屏幕。 1单纯使用流式布局的结果是宽度自适应 高度是写死的 导致不能完全适配设计图(因为不同的屏幕大小下 高度永远是写死的), 而使用rem就可以让高度也保持自适应效果 流式布局：虽然可以让各种屏幕都适配，但是显示效果不是很好，因为只有几个尺寸的手机能够完美的显示出来视觉设计师和交互最想要的效果。但是目前使用流式布局的公司非常多，比如 亚马逊 、京东 、携程 rem布局：rem能够适配所有的屏幕，与less配合使用效果会更好。目前使用rem布局的有：淘宝 、 苏宁 rem是什么？ rem（font size of the root element）是指相对于根元素的字体大小的单位。它是一个相对单位。 123既然是一个单位, 而px也是一个单位 所以但凡是使用px的地方都可以使用rem来代替 而rem单位的大小永远参照的是html的font-size值 1rem = html的font-size的大小特点: 一旦html的font-size发生了改变 那么rem的大小也会发生改变 rem与高度自适应因为rem的基准点是根元素html的字体大小，因此我们只需要设置不同屏幕的html的font-size大小不一样就可以达到不同屏幕的适配了。 媒体查询 媒体查询（Media Query）是CSS3提出来的一个新的属性，通过媒体查询可以查询到screen的宽度，从而指定某个宽度区间的网页布局。 1234567891011121314根据不同的屏幕大小去加载不同的css样式语法说明:media screen (条件) &#123; 满足条件加载的css内容&#125;// 条件说明1. min-width: 320px =&gt; 最小宽为320 (320以上的设备)2. max-width: 640px =&gt; 最大宽为640 (640以下的设备)3. width: 540px =&gt; 宽度等于540and连接符 =&gt; 可以查询多个多个条件 rem与媒体查询使用rem配合媒体查询可以适配多个终端 12345需求：基于750的设计图自定义 html的font-size为50 ,里面得到的盒子的大小为100px 100px 改写成rem 可以实现在主流手机里面宽高自适应 主流手机机型：320 360 375 384 400 414 424 480 540 720 750px转换成rem的公式: px/html的font-size值 动态计算不同屏幕对应的html的font-size值公式: 当前屏幕/(设计图的宽 / 基于这个设计图的html的fontsize) LESSLess简介 Less 是一门 CSS 预处理语言,它扩展了 CSS 语言,增加了变量、Mixin、函数等特性。 浏览器不直接识别less文件，浏览器只识别css文件，所以我们写了less文件之后，我们需要预先把less文件转换成css文件。 本质上，LESS 包含一套自定义的语法及一个解析器，用户根据这些语法定义自己的样式规则，这些规则最终会通过解析器，编译生成对应的 CSS 文件。LESS 并没有裁剪 CSS 原有的特性，更不是用来取代 CSS 的，而是在现有 CSS 语法的基础上，为 CSS 加入程序式语言的特性。 less仅仅是写css的另一种方式，写出来的less文件浏览器也不识别。所以，写完了less文件，还需要通过less解析器解析成css，最终浏览器引入的还是css文件。 官网中文网 less的编译 如何把less文件变成css文件 安装easy less插件 1234和前面的内容需要使用 ,&quot;less.compile&quot;: &#123; &quot;out&quot;: &quot;../css/&quot;&#125; 使用webpack打包的时候用less-loader处理 Less语法less初体验注释12/*这个注释是CSS中的注释，因此会编译到css中*///这个注释,CSS中用不了，因此不会编译出来。 变量12345678910@wjs_color:#e92322;body &#123; background-color: @wjs_color;&#125;div &#123; width: 400px; height: 400px; border: 1px solid @wjs_color;&#125; 嵌套 我们可以在一个选择器中嵌套另一个选择器来实现继承，这样很大程度减少了代码量，并且代码看起来更加的清晰。 使用伪类的时候 可以使用&amp; 表示父选择器 12345678910111213@charset &quot;UTF-8&quot;;.wjs_header &#123; border-bottom: 1px solid #ccc;&#125;.wjs_header .header_item &#123; height: 40px; line-height: 40px; text-align: center; border-left: 1px solid #ccc;&#125;.wjs_header .header_item:first-child &#123; border-left: none;&#125; less数学运算 在我们的 CSS 中充斥着大量的数值型的 value，less可以直接支持运算，也提供了一系列的函数提供给我们使用。 less函数函数：可以重复使用 不带参数的函数 1234567891011@charset &quot;UTF-8&quot;;//不会被编译.btn() &#123; width: 200px; height: 200px; background-color: #ccc;&#125;.my_btn &#123; .btn();&#125; 带参数的函数 123456789.btn_border(@width) &#123; border: @width solid #000;&#125;.my_btn &#123; //如果函数定义了参数，调用的时候必须传入参数，否则会报错 .btn_border(); //传入参数，就不会报错 .btn_border(10px);&#125; 12345678910//js中函数的默认值设置方法是等号，不要混淆.btn_border(@width:1px) &#123; border: @width solid #000;&#125;.my_btn &#123; //因为有默认值，所以不会报错 .btn_border(); //传入参数，会覆盖1px，也不会报错 .btn_border(10px);&#125;","categories":[{"name":"css","slug":"css","permalink":"https://bloodthirsty2b.github.io/categories/css/"},{"name":"mobile","slug":"css/mobile","permalink":"https://bloodthirsty2b.github.io/categories/css/mobile/"}],"tags":[{"name":"css","slug":"css","permalink":"https://bloodthirsty2b.github.io/tags/css/"},{"name":"mobile","slug":"mobile","permalink":"https://bloodthirsty2b.github.io/tags/mobile/"}]},{"title":"flex布局,响应式布局,bootstrap简要","slug":"css/mobile/03-flex布局-响应式布局-bootstrap简要","date":"2020-11-06T04:59:40.000Z","updated":"2021-12-20T15:56:57.571Z","comments":true,"path":"2020/11/06/css/mobile/03-flex布局-响应式布局-bootstrap简要/","link":"","permalink":"https://bloodthirsty2b.github.io/2020/11/06/css/mobile/03-flex%E5%B8%83%E5%B1%80-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80-bootstrap%E7%AE%80%E8%A6%81/","excerpt":"弹性布局 flex(伸缩布局)CSS3在布局方面做了非常大的改进，使得对块级元素的布局排列变得十分灵活，适应性非常强，其强大的伸缩性，在响应式开中可以发挥极大的作用。","text":"弹性布局 flex(伸缩布局)CSS3在布局方面做了非常大的改进，使得对块级元素的布局排列变得十分灵活，适应性非常强，其强大的伸缩性，在响应式开中可以发挥极大的作用。 当给一个盒子设置了display：flex之后，这个盒子就有了主轴 和侧轴 的概念。主轴：Flex容器的主轴主要用来配置Flex项目，默认是水平方向侧轴：与主轴垂直的轴称作侧轴，默认是垂直方向的方向：默认主轴从左向右 ，默认侧轴从上到下 flex-direction flex-diretion主要是用来调整主轴的方向的，默认是水平方向 一般来说，很少调整主轴的方向。 可选值 1234row：主轴方向为水平向右column：主轴方向为竖直向下row-reverse:主轴方向为水平向左column-reverse:主轴方向是竖直向上。 justify-content(重点) justify-content主要用来设置主轴方向的对齐方式 ，可选的值有： 可选值： 12345flex-start: 弹性盒子元素将向起始位置对齐flex-end: 弹性盒子元素将向结束位置对齐。center: 弹性盒子元素将向行中间位置对齐space-around: 弹性盒子元素会平均地分布在行里space-between:第一个贴左边，最后一个贴右边，其他盒子均分，保证每个盒子之间的空隙是相等的。 align-items(重点) align-items用于调整侧轴的对齐方式 ，可选的值有： 1234flex-start： 元素在侧轴的起始位置对齐。 flex-end： 元素在侧轴的结束位置对齐。center： 元素在侧轴上居中对齐。stretch： 元素的高度会被拉伸到最大（不能给死高度）。 flex-wrap flex-wrap属性控制flex容器是单行或者多行,默认不换行 12nowrap： 不换行（默认），会压缩子盒子的宽度。wrap： 当宽度不够的时候，会换行。 align-content align-content用来设置多行的flex容器的排列方式。 123456flex-start： 各行向侧轴的起始位置堆叠。 flex-end： 各行向弹性盒容器的结束位置堆叠。center： 各行向弹性盒容器的中间位置堆叠。space-around： 各行在侧轴中平均分布。 space-between： 第一行贴上边，最后一个行贴下边,其他行在弹性盒容器中平均分布。 stretch：拉伸，不设置高度的情况下。 align-items与align-content的区别 12align-items调整的是侧轴单行的对齐方式，不换行一般用align-itemsalign-content:必须是多行才生效，如果单行，没有效果。换行了就用align-content。 flex属性 上述属性都是给父盒子设置的，接下来的几个属性是给子盒子设置的。 flex属性用来设置子盒子如何分配主轴空间 1flex:1 order属性 order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 1order:1; align-selfalign-self也是用于设置在侧轴的位置，但是align-self给子元素设置，优先级比align-items的优先级高。 1取值与align-items的取值一样。 flex-grammar 响应式什么是响应式布局 响应式布局（respond layout）是Ethan Marcotte在2010年5月份提出的一个概念，简而言之，就是一个网站能够兼容多个终端（手机、平板、pc电脑） ——而不是为每个终端做一个特定的版本。这个概念是为解决移动互联网浏览而诞生的。 为什么要有响应式布局？ 在移动互联日益成熟的时候，在PC端开发的网页已经无法满足移动设备的要求。 通常的做法是针对移动端单独做一套特定的版本。 如果终端越来越多，那么需要开发的版本就会越来越多（大屏设备的普及） 响应式布局 ：一个网站能够兼容多个终端（节约开发成本） 优点： 面对不同分辨率设备灵活性强 能够快捷解决多设备显示适应问题 **缺点： ** 兼容各种设备工作量大，效率低下 代码累赘，会出现隐藏无用的元素，加载时间加长 响应式开发现状： 如果已经存在PC的网站了，那么一般不会使用响应式开发，而是针对移动端再开发一套系统（比如京东、淘宝） 在新建站点采用响应式开发的较多 响应式开发与移动web开发的比较 开发方式 移动web开发+pc开发 响应式开发 引用场景 一般已经有了PC端网站，只需要端独开发移动端网站即可 针对一些新建网站，并且要求适配移动端 开发 针对性强，开发效率高 兼容各种终端，效率低 适配 只能适配移动端或者PC端，pad上体验比较差 可以适配各种终端 效率 代码简介，加载快 代码相对复杂，加载慢 媒体查询 媒体查询（Media Query）是CSS3提出来的一个新的属性，通过媒体查询可以查询到screen的宽度，从而指定某个宽度区间的网页布局。 设备分类 分类 宽度范围 大屏设备 &gt;1200px 中屏设备 992px~1200px 小屏设备 768px~992px 超小屏设备 &lt; 768px 媒体查询的使用响应式开发的原理：使用媒体查询实现不同终端的布局和样式的切换。 媒体查询语法： 12345678910111213141516171819202122232425262728293031323334/*查询屏幕*/@media screen and (条件) &#123;&#125;/*条件的写法*//*min-width:只要屏幕宽度超过这个值的设备样式就能生效*//*max-width:只要屏幕宽度小于这个值的设备样式就能生效*/@media screen and (min-width: 1200px) &#123; .container &#123; width: 1170px; background-color: red; &#125;&#125;@media screen and (min-width: 992px) and (max-width: 1200px) &#123; .container &#123; width: 970px; background-color: blue; &#125;&#125;@media screen and (min-width: 768px) and (max-width: 992px) &#123; .container &#123; width: 750px; background-color: yellow; &#125;&#125;@media screen and (max-width: 768px) &#123; .container &#123; width: 100%; background-color: green; &#125;&#125; 弊端：只有一个div，要做一套响应式布局，就需要如此多的代码，非常的麻烦，因此开发会更多的借助一些响应式的框架，比如bootstrap。 bootstrap框架 Bootstrap，来自 Twitter，是很受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JAVASCRIPT 的，它简洁灵活，使得 Web 开发更加快捷。 bootstrap中文网 特点： 组件简洁大方、代码规范精简、界面自定义性强。 Bootstrap是基于HTML5和CSS3开发的, js功能效果依赖于 jQuery。 Bootstrap中包含了丰富的Web组件，根据这些组件，可以快速的搭建一个漂亮、功能完备的网站。 优点： 有自己的生态圈，不断的更新迭代 提供了一套简洁、直观、强悍的组件 标准化的HTML+CSS编码规范 让开发更简单，提高了开发效率。 扩展性强，虽然界面组件样式已经定义好了，但还是可以自定义，修改默认样式。 版本： 2.x.x 停止维护 优点：兼容性好 缺点：代码不够简洁、功能不够完善 3.x.x 目前使用最多 优点：稳定，偏向于开发响应式布局，移动设备优先的WEB项目 缺点：放弃了IE67，对IE8支持但是界面效果不友好 4.x.x 阶段 基本模板123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;bootstrap基本模板&lt;/title&gt; &lt;!--引入bootstrap的核心样式文件--&gt; &lt;link href=&quot;lib/bootstrap/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;你好，世界！&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 全局样式container容器Bootstrap 需要为页面内容和栅格系统包裹一个 .container 容器。默认带了15px的padding值。 .container 类用于固定宽度并支持响应式布局的容器。 123&lt;div class=&quot;container&quot;&gt; ...&lt;/div&gt; .container-fluid 类用于 100% 宽度，占据全部视口（viewport）的容器。 123&lt;div class=&quot;container-fluid&quot;&gt; ...&lt;/div&gt; 这两种 容器类不能互相嵌套。 栅格系统栅格系统，也叫网格系统 .row用于抵消.container容器的15px的padding值 可以在.row中嵌套column 栅格系统常用类（总共12列） 类名 例子 解释 .col-xs-xx .col-xs-6 在超小屏幕（及以上）生效 .col-sm-xx .col-sm-6 在小屏幕（及以上）生效 .col-md-xx .col-md-6 在中屏幕（及以上）生效 .col-lg-xx .col-lg-3 在大屏幕及生效，占1&#x2F;4 .col-lg-xx .col-lg-4 在大屏幕及生效，占1&#x2F;3 .col-lg-xx .col-lg-5 在大屏幕及生效，占1&#x2F;2 【列嵌套】 1234567&lt;div class=&quot;col-lg-4&quot;&gt; &lt;!--栅格系统无处不在，只要父盒子有宽度，就可以使用栅格系统--&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-lg-6&quot;&gt;&lt;/div&gt; &lt;div class=&quot;col-lg-6&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 【列偏移】 123456&lt;!-- 使用 .col-md-offset-* 类可以将列向右侧偏移。--&gt;&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-lg-3&quot;&gt;&lt;/div&gt; &lt;!--col-lg-offset-3:在大屏下，这个div将向右侧偏移3个单位--&gt; &lt;div class=&quot;col-lg-6 col-lg-offset-3&quot;&gt;&lt;/div&gt;&lt;/div&gt; 推荐使用hidden相关的属性","categories":[{"name":"css","slug":"css","permalink":"https://bloodthirsty2b.github.io/categories/css/"},{"name":"mobile","slug":"css/mobile","permalink":"https://bloodthirsty2b.github.io/categories/css/mobile/"}],"tags":[{"name":"css","slug":"css","permalink":"https://bloodthirsty2b.github.io/tags/css/"},{"name":"mobile","slug":"mobile","permalink":"https://bloodthirsty2b.github.io/tags/mobile/"}]},{"title":"过渡,动画,私有前缀,视口,流式布局","slug":"css/mobile/02-过渡-动画-私有前缀-视口-流式布局","date":"2020-11-05T00:43:51.000Z","updated":"2021-12-20T15:56:48.354Z","comments":true,"path":"2020/11/05/css/mobile/02-过渡-动画-私有前缀-视口-流式布局/","link":"","permalink":"https://bloodthirsty2b.github.io/2020/11/05/css/mobile/02-%E8%BF%87%E6%B8%A1-%E5%8A%A8%E7%94%BB-%E7%A7%81%E6%9C%89%E5%89%8D%E7%BC%80-%E8%A7%86%E5%8F%A3-%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80/","excerpt":"过渡过渡的属性","text":"过渡过渡的属性 如果两个状态发生改变，没有过渡，效果是瞬间变化的 如果加上了过渡，那么这个过程就会有动画的效果。 整个状态变化的过程是由浏览器来完成的，我们只需要关注开始状态与结束状态即可。 12345678910111213/*transition-property：设置过渡属性/*也可以是width,height*/transition-property:all;/*transition-duration:设置过渡时间*/transition-duration:1s;/*transition-delay：设置过渡延时*/transition-delay:2s;/*transition-timing-function:设置过渡的速度*//*linear，ease，ease-in，ease-out，ease-in-out， steps(10)*/transition-timing-function:linear; 属性合写12/* 属性 时间 延时 速度 */transition: width 1s 3s linear; 过渡的注意点： 过渡必须要有两个状态的变化。 过渡可以写在A状态，也可以写在B状态，但是如果写在B状态，那么回来的时候，就没有过渡效果了。 深入理解过渡 CSS3动画 动画可以通过设置多个节点来精确控制一个或者一组动画，常用来实现复杂的动画效果。 动画与过渡的区别： 121. 过渡必须触发，需要两个状态的改变。2. 动画可以一直运行下去，不需要触发。实现效果与过渡差不多 定义动画基本步骤 12//1.通过@keyframes指定动画序列//2.通过animation将动画应用于相应的元素 定义基本动画 123456789101112/* 1. 定义一个动画 */@keyframes rotate &#123; /* 动画的开始状态 */ from &#123; transform: rotate(0deg); &#125; /* 动画的结束状态 */ to &#123; transform: rotate(360deg); &#125;&#125; 定义百分比动画 123456789101112131415@keyframes scale &#123; 0% &#123; width: 200px; height: 200px; &#125; 50% &#123; width: 300px; height: 200px; &#125; 100% &#123; width: 300px; height: 300px; &#125;&#125; animation详解 animation是一个复合属性，一共有8个参数 1234567891011121314151617animation-name:动画名称，由@keyframes定义的animation-duration：动画的持续时间animation-timing-function：动画的过渡类型 ease：变速 linear：匀速 steps：分步动画animation-delay：动画的延迟时间animation-iteration-count：动画的循环次数 infinite:无穷次animation-direction：设置动画在循环中是否反向运动 normal：从from到to reverse: 从to到from alternate: 交替执行animation-fill-mode：设置动画时间之外的状态 forwards：停留在结束状态animattion-play-state:设置动画的状态。 paused: 暂停动画 帧动画原理 CSS3私有前缀 在标准还未确定时，部分浏览器已经根据最初草案实现了部分功能，为了与之后确定下来的标准进行兼容，所以每种浏览器使用了自己的私有前缀与标准进行区分，当标准确立后，各大浏览器将逐步支持不带前缀的css3新属性 目前已有很多私有前缀可以不写了，但为了兼容老版本的浏览器，可以仍沿用私有前缀和标准方法，逐渐过渡。 一般来说，CSS3主要是为移动端而生的，因此我们在移动端没必要写太多的前缀，因为移动端的ios和Android的浏览器都是webkit内核。 1234谷歌、苹果浏览器：-webkit-火狐浏览器：-moz-IE浏览器：-ms-欧朋浏览器：-o- 1234567891011121314151617div &#123; width: 200px; height: 200px; background-color: pink; margin: 100px auto; /*谷歌浏览器和safari浏览器的前缀 -webkit-*/ -webkit-transform: rotate(45deg); /*火狐浏览器的前缀 -moz-*/ -moz-transform: rotate(45deg); /*ie浏览器的前缀 -ms-*/ -ms-transform: rotate(45deg); /*opera浏览器的前缀 -o-*/ -o-transform: rotate(45deg); /*规范化后的写法*/ transform: rotate(45deg);&#125; 移动端样式移动端开发现状 移动web开发指的是需要适配移动设备的网页开发 移动web开发与pc端web开发没有本质的区别，使用的还是HTML&#x2F;CSS&#x2F;JavaScript的技术 移动web开发与pc端web开发的区别是什么？ 移动端的浏览器与pc端不同 1234谷歌浏览器 苹果浏览器、 UC浏览器 QQ浏览器 欧朋浏览器 百度手机浏览器 360安全浏览器 搜狗浏览器 猎豹浏览器等国内的手机浏览器都是根据webkit内核修改过来的，国内没有自主研发的内核，国内的操作系统也是基于Android系统修改的。因此在移动端，css3属性只需要加webkit前缀即可。 移动端设备尺寸不一样(尺寸非常多，碎片化很严重) 12Android： 320*480 480*800 540*960 720*1280 1080*1920 2k屏 4k屏iphone： 640*960 640*1136 750*1334 1242*2208 视口 viewport（重要）123456789101112问题：一个电脑上的网站，在手机端访问，效果是什么样的？iPhone5的设备宽度只有320px，一张宽度为640px的图片在手机端访问，显示的效果是什么？1. 在手机端，html的大小都是980px，为什么？这主要是历史原因导致的，因为在移动设备刚流行的时候，网站大多都是pc端的，pc端的页面宽度一般都比较大，移动设备的宽度比较小，如果pc端页面直接在移动端显示的话，页面就会错乱。为了解决这个问题，移动端html的大小直接就定死成了980px（因为早起的pc端网站版心就是980px居多）。2. 视口在pc端，html的大小默认是继承了浏览器的宽度，即浏览器多宽，html的大小就是多宽，但是在移动端，多出来了一个视口的概念（乔布斯）,视口说白了就是介于浏览器与html之间的一个东西，视口的宽度默认定死了980px，因此html的宽度默认就是980px，视口的特点是能够根据设备的宽度进行缩放。3. 视口设置。对于现在的移动端页面来说，视口默认为980px肯定不合适，因为设备宽度不够的话，视口会进行缩放，导致页面展示效果不好看。 视口参数设置 12345678910111213141516171819//width 设置视口的宽度//width=device-width 设置视口宽度为设备的宽度（常用）。//initial-scale 设置初始缩放比例//initial-scale=1.0 表示不缩放//user-scalable 设置是否允许用户缩放//user-scalable=no 不允许用户缩放//maximum-scale 设置允许的最大缩放比例//maximum-scale=1.0 可以不设置，因为都禁止用户缩放了。//minimum-scale 设置允许最小缩放比//minimum-scale=1.0 不设置，因为禁用用户缩放了。//标准写法：//快捷键： meta:vp + tab键&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0&quot;&gt; 流式布局移动端的特点 手机端的兼容性问题比PC端小很多，因为手机端的浏览器版本比较新 手机端屏幕比较小，能够放的内容比较少。 问题：布局的时候怎么解决屏幕大小不一致的问题？ PC端，固定版心，让所有分辨率的电脑的版心都是一样的，比如京东 移动端：移动端无法设置版心，因为移动端的设备屏幕本身就小，设置版心不合适。因此移动端大多会采用流式布局（百分比布局） 流式布局，也叫百分比布局，是移动端开发中经常使用的布局方式之一。 流式布局的特征： 宽度自适应，高度写死，并不是百分百还原设计图 图标都是固定死大小的，包括字体等也是固定死的。并不是所有的东西都是自适应的。 一些大的图片，设置宽度为百分比自适应即可，随着屏幕大小进行变化 经典的流式布局 1234//1. 左侧固定，右侧自适应//2. 右侧固定，左侧自适应//3. 两侧固定，中间自适应（圣杯布局，双飞翼布局）//4. 等分布局 设计图的缩放手机端的设计图相对手机来说 是两倍或者三倍的关系 直接拿到这样的设计图量的结果都是2倍的 所以需要除以2 每次手动去除较为麻烦 所以 推荐将设计图缩放到320的大小 两倍图 由于手机端的像素密度要比PC端高,很多手机的像素密度是电脑的2倍甚至3倍,所以为了在手机上显示的图片更加清晰,设计师给的图片都是2倍图甚至3倍图 问题: 如何使用2倍图片的精灵图或者3倍图片的精灵图？ 123456789以2倍图为例:1. 利用PS将精灵图缩小一倍,去量取对应的宽高和位置坐(这个缩小仅仅是为了量取坐标 而真正引入到页面的图片还是原设计图下面切出来的图片)2. 利用background-size去缩放精灵图(缩放至原始图片的1/2)重点注意: 引用的图片还是原来的2倍图 利用ps缩放图片:1. 将图片选项卡拖拽出来或者选择菜单栏2. 图像 - 图像大小 - 将宽度缩放至1/2即可 只需要缩放一个就行 默认会保证等比例","categories":[{"name":"css","slug":"css","permalink":"https://bloodthirsty2b.github.io/categories/css/"},{"name":"mobile","slug":"css/mobile","permalink":"https://bloodthirsty2b.github.io/categories/css/mobile/"}],"tags":[{"name":"css","slug":"css","permalink":"https://bloodthirsty2b.github.io/tags/css/"},{"name":"mobile","slug":"mobile","permalink":"https://bloodthirsty2b.github.io/tags/mobile/"}]},{"title":"闭包,正则","slug":"js/11-闭包-正则","date":"2020-10-13T04:39:01.000Z","updated":"2021-12-20T15:43:49.364Z","comments":true,"path":"2020/10/13/js/11-闭包-正则/","link":"","permalink":"https://bloodthirsty2b.github.io/2020/10/13/js/11-%E9%97%AD%E5%8C%85-%E6%AD%A3%E5%88%99/","excerpt":"闭包闭包的基本概念闭包（closure）是JavaScript的一个特色，很多高级的应用都要依靠闭包来实现。","text":"闭包闭包的基本概念闭包（closure）是JavaScript的一个特色，很多高级的应用都要依靠闭包来实现。 作用域在js中，函数会形成函数作用域，在函数内部可以直接访问全局变量 12345var str = &quot;zs&quot;;function fn()&#123; console.log(str);//访问全局变量&#125;fn();//zs 在函数外部却无法访问函数内部的变量 12345function fn()&#123; var str = &quot;zs&quot;;&#125;fn();console.log(str);//报错 str is not defined 问题：怎么才能获取到函数内部的变量？ 作用域链在函数内部有一个函数，那么函数内部的函数是可以访问到外部函数的变量的。 解决方法： 12345678function fn()&#123; var str = &quot;zs&quot;; function f2()&#123; console.log(str); &#125; f2();&#125;fn(); 在上述代码中，fn中定义的所有变量，对于f2函数都来都是可以访问的。但是现在f2在函数的内部，我们如何在外部访问到f2这个函数呢？ 123456789function fn()&#123; var str = &quot;zs&quot;; function f2()&#123; console.log(str); &#125; return f2;&#125;var result = fn();result();// &quot;zs&quot; 闭包的概念 闭包是函数和声明该函数的词法环境的组合。 在JavaScript中，在函数中可以（嵌套）定义另一个函数时，如果内部的函数引用了外部的函数的变量，产生闭包。 **闭包中包含了内部函数的代码，以及所需外部函数中的变量的引用 ** 产生闭包的条件 1当内部函数访问了外部函数的变量的时候，就会形成闭包。 闭包的作用： 私有变量，保护数据安全 持久化维持数据 闭包的应用计数器需求：统计一个函数的调用次数 12345678var count = 0;function fn()&#123; count++; console.log(&quot;我被调用了，调用次数是&quot;+count);&#125;fn();fn();fn(); 缺点：count是全局变量，不安全。 使用闭包解决这个问题 1234567891011function outer()&#123; var count = 0; // 私有变量, 将count保护起来了 function add()&#123; count++; console.log(&quot;当前count&quot;+count); &#125; return add;&#125;var result = outer();result(); 缓存 缓存（cache）：数据的缓冲区，当要读取数据时，先从缓冲中获取数据，如果找到了，直接获取，如果找不到，重新去请求数据。 计算斐波那契数列，会有很大的性能问题，因为重复的计算了很多次，因此我们可以使用缓存来解决这个性能问题。 初级优化： 使用缓存的基本步骤： 如果要获取数据，先查询缓存，如果有就直接使用 如果没有，就进行计算，并且将计算后的结果放到缓存中，方便下次使用。 123456789101112131415// 缓存var arr = [];var fbi = function (n) &#123; count++; if (n == 1 || n == 2) &#123; return 1; &#125; if (arr[n]) &#123; return arr[n]; &#125; else &#123; var temp = fbi(n - 1) + fbi(n - 2); arr[n] = temp;// 存入缓存 return temp; &#125;&#125; 缺点：既然使用缓存，就需要保证缓存的数据的安全，不能被别人修改，因此，需要使用闭包来实现缓存的私有化。 1234567891011121314151617181920function outer() &#123; //缓存 var arr = []; var fbi = function (n) &#123; if (n == 1 || n == 2) &#123; return 1; &#125; if (arr[n]) &#123; return arr[n]; &#125; else &#123; var temp = fbi(n - 1) + fbi(n - 2); arr[n] = temp;//存入缓存 return temp; &#125; &#125; return fbi;&#125;var fbi = outer();console.log(fbi(40)); 闭包存在的问题 闭包占用的内存是不会被释放的，因此，如果滥用闭包，会造成内存泄漏的问题。闭包很强大，但是只有在必须使用闭包的时候才使用。 js的垃圾回收机制https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management 内存：计算机中所有程序的运行都是在内存中进行的，因此内存的性能对计算机的影响非常大，运行程序需要消耗内存，当程序结束时，内存会得到释放。 javascript分配内存：当我们定义变量，javascript需要分配内存存储数据。无论是值类型或者是引用类型，都需要存储在内存中。 垃圾回收：当代码执行结束，分配的内存已经不需要了，这时候需要将内存进行回收，在javascript语言中，垃圾回收机器会帮我们回收不再需要使用的内存。 引用记数法清除引用记数垃圾收集：如果没有引用指向某个对象（或者是函数作用域），那么这个对象或者函数作用域就会被垃圾回收机制回收。 12345678var o = &#123; name:&quot;zs&quot;&#125;// 对象被o变量引用，引用记数1var obj = o; // 变量被o和obj引用，引用记数2o = 1; // o不在引用对象了，引用记数1obj = null; // obj不在引用对象了，引用记数0，可以被垃圾回收了。 标记清除法清除使用引用计数法进行垃圾回收的时候，会出现循环引用导致内存泄漏的问题。因此现代的浏览器都采用标记清除法来进行垃圾回收。 这个算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象Window）。定期的，垃圾回收器将从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和所有不能获得的对象。 从2012年起，所有现代浏览器都使用了标记-清除垃圾回收算法。 闭包占用内存释放1234567891011121314function outer()&#123; var count = 0; function fn()&#123; count++; console.log(&quot;执行次数&quot;+count); &#125; return fn;&#125;var result = outer();result();result = null;// 当函数fn没有被变量引用了，那么函数fn就会被回收，函数fn一旦被回收，那么outer调用形成的作用域也就得到了释放。 正则表达式 正则表达式：用于匹配规律规则的表达式，正则表达式最初是科学家对人类神经系统的工作原理的早期研究，现在在编程语言中有广泛的应用，经常用于表单校验，高级搜索等。 创建正则表达式构造函数的方式 1var regExp = new RegExp(/\\d/); 正则字面量 1var regExp = /\\d/; 正则的使用 1234567891011121314/\\d/.test(&quot;aaa1&quot;); // 返回布尔值/\\d/.exec(&quot;aaa1&quot;); /* 返回一个长度为1的伪数组， 数组第0项为匹配的完整子字符串， 第1项为正则第1个子分组(正则中用括号包裹起来的内容)匹配的内容， 第2项为正则第2个子分组匹配的内容， 第3项(如果还有的话)… 属性index表示下标 属性input表示匹配的原始字符串 使用全局匹配可以得到整个字符串的匹配结果，即多个上面的伪数组*/ &quot;aaa1&quot;.search(/\\d/); // 返回下标 元字符 正则表达式由一些普通字符和元字符组成，普通字符包括大小写字母、数字等，而元字符则具有特殊的含义。 常见元字符 |表示或，优先级最低 ()优先级最高，表示分组 字符类的元字符[]在正则表达式中表示一个字符的位置，[]里面写这个位置可以出现的字符。 1console.log(/[abc]/);//匹配a,b,c [^]在中扩号中的^表示非的意思。 12//^表示该位置不可以出现的字符console.log(/[^abc]/);//匹配除了a，b，c以外的其他字符 [a-z] [1-9]表示范围 1234console.log(/[a-z]/.test(&quot;d&quot;));//小写字母console.log(/[A-Z]/.test(&quot;d&quot;));//大写字母console.log(/[0-9]/.test(&quot;8&quot;));//数字console.log(/[a-zA-Z0-9]/);//所有的小写字母和大写字母以及数字 边界类元字符 前面的正则只要有满足的条件的就会返回true，并不能做到精确的匹配。 ^表示开头 []里面的^表示取反 $表示结尾 123456console.log(/^chuan/.test(&quot;dachuan&quot;));//必须以chuan开头console.log(/chuan$/.test(&quot;chuang&quot;));//必须以chuan结尾console.log(/^chuan$/.test(&quot;chuan&quot;));//精确匹配chuan//精确匹配chuan,表示必须是这个console.log(/^chuan$/.test(&quot;chuanchuan&quot;));//fasle 量词类元字符 量词用来控制出现的次数，一般来说量词和边界会一起使用 *表示能够出现0次或者更多次，x&gt;&#x3D;0; +表示能够出现1次或者多次，x&gt;&#x3D;1 ?表示能够出现0次或者1次，x&#x3D;0或者x&#x3D;1 &#123;n&#125;表示能够出现n次 &#123;n,&#125;表示能够出现n次或者n次以上 &#123;n,m&#125;表示能够出现n-m次","categories":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/tags/js/"}]},{"title":"函数原型链,作用域链,递归","slug":"js/10-函数原型链-作用域链-递归","date":"2020-10-12T03:32:38.000Z","updated":"2021-12-20T15:44:01.547Z","comments":true,"path":"2020/10/12/js/10-函数原型链-作用域链-递归/","link":"","permalink":"https://bloodthirsty2b.github.io/2020/10/12/js/10-%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E9%93%BE-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE-%E9%80%92%E5%BD%92/","excerpt":"函数也是对象 函数是由new Function创建出来的，因此函数也是一个对象， 所有的函数都是new Function的实例。","text":"函数也是对象 函数是由new Function创建出来的，因此函数也是一个对象， 所有的函数都是new Function的实例。 函数的原型链结构 Function.prototype常用成员 call：调用函数，重新指向this apply：调用函数，重新指向this bind：重新指向this，返回一个新的函数，不调用。 完整版原型链 总结： 所有函数都是new Function创建出来的，因此所有函数.__proto__都是Function.prototype 所有对象都是new Object创建出来的，因此所有对象.__proto__都是Object.prototyp 作用域 作用域：变量起作用的区域，也就是说：变量定义后，可以在哪个范围内使用该变量。 1234567var num = 11;//全局变量function fn()&#123; var num1 = 22;//局部变量 console.log(num); // 全局变量在任何地方都能访问到 console.log(num1); &#125;console.log(num); JS中没有块级作用域。 在JS里只有函数可以形成作用域，叫做函数作用域。 因为函数能够形成作用域，所以，函数内部声明的变量函数外部无法访问。 函数作用域是在函数定义的时候作用域就确定下来了，和函数在哪调用无关。 12345678910var num = 123;function f1() &#123; console.log(num);&#125;function f2()&#123; var num = 456; f1();&#125;f2();// ? 作用域链 作用域链：只要是函数，就会形成一个作用域，如果这个函数被嵌套在其他函数中，那么外部函数也有自己的作用域，这个一直往上到全局环境，就形成了一个作用域链。 变量的搜索原则： 从当前作用域开始查找是否声明了该变量，如果存在，那么就直接返回这个变量的值。 如果不存在，就会往上一层作用域查询，如果存在，就返回。 如果不存在，一直查询到全局作用域，如果存在，就返回。如果在全局中也没有找到该变量会报错 递归函数 递归函数：函数内部直接或者间接的调用自己 递归的要求： 自己调用自己（直接或者间接） 要有结束条件（出口） 递归函数主要是化归思想，将一个复杂的问题简单化，主要用于解决数学中的一些问题居多。 把要解决的问题，归结为已经解决的问题上。 一定要考虑什么时候结束让函数结束，也就是停止递归（一定要有已知条件）","categories":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/tags/js/"}]},{"title":"函数定义的三种方法,函数调用的四种模式","slug":"js/09-函数定义的三种方法-函数调用的四种模式","date":"2020-10-11T02:04:47.000Z","updated":"2021-12-20T15:44:13.301Z","comments":true,"path":"2020/10/11/js/09-函数定义的三种方法-函数调用的四种模式/","link":"","permalink":"https://bloodthirsty2b.github.io/2020/10/11/js/09-%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%A8%A1%E5%BC%8F/","excerpt":"函数进阶定义函数的三种方式","text":"函数进阶定义函数的三种方式 函数声明1234fn();// 函数声明可以先调用，在声明function fn()&#123; console.log(&quot;这是函数声明&quot;)&#125; 函数表达式1234var fn = function() &#123; console.log(&quot;这是函数表达式&quot;); &#125;fn();//函数表达式必须先声明，再调用 构造函数Function123456789101112//函数也是对象，可以使用Function构造函数new出来//相当于var fn = function()&#123;&#125;var fn = new Function();//语法：new Function(arg1,arg2,arg3..,body);// 1. 所有的参数都是字符串类型。// 2. 前面可以定义任意多个形参，最后一个参数是代码体。var fn = new Function(&quot;alert(1111)&quot;);fn();var fn1 = new Function(&quot;a1&quot;, &quot;a2&quot;, &quot;alert(a1+a2)&quot;);fn1(1,2); eval函数 eval的可以和new Function一样，执行字符串代码 注意：eval函数的功能非常的强大，但是实际使用的情况并不多。 eval形式的代码难以阅读 eval形式的代码无法打断点，因为本质还是还是一个字符串 在浏览器端执行任意的 JavaScript会带来潜在的安全风险，恶意的JavaScript代码可能会破坏应用，特别是在用它执行用户输入数据的情况下。否则，可能会有恶意用户输入威胁你的站点或应用程序安全的代码（即所谓的代码注入） 了解： xss攻击 函数的四种调用模式 根据函数内部this的指向不同，可以将函数的调用模式分成4种 函数调用模式 方法调用模式 构造函数调用模式 上下文调用模式（借用方法模式） 12函数：当一个函数不是一个对象的属性时，称之为函数。方法：当一个函数被保存为对象的一个属性时，称之为方法。 函数调用模式如果一个函数不是一个对象的属性时，就是被当做一个函数来进行调用的。此时this指向了window 1234function fn()&#123; console.log(this);//指向window&#125;fn(); 方法调用模式当一个函数被保存为对象的一个属性时，称之为一个方法。当一个方法被调用时，this被绑定到当前对象上。 123456var obj = &#123; sayHi:function()&#123; console.log(this);// 在方法调用模式中，this指向调用当前方法的对象。 &#125;&#125;obj.sayHi(); 构造函数调用模式如果函数是通过new关键字进行调用的，此时this被绑定到创建出来的新对象上。 12345function Person()&#123; console.log(this);&#125;Person();//this指向什么？var p = new Person();//this指向什么？ 总结：分析this的问题，主要就是区分函数的调用模式，看函数是怎么被调用的。 几种特殊的this指向 定时器中的this指向了window，因为定时器的function最终是由window来调用的。**可以使用箭头函数来避免这一问题 ** 事件中的this指向的是当前的元素，在事件触发的时候，浏览器让当前元素调用了function。多数情况不能使用箭头函数 上下文调用模式 上下文调用模式也叫方法借用模式，分为apply与call 使用方法： 函数.call() 或者 函数.apply() call方法call方法可以调用一个函数，并且可以指定这个函数的this指向 12345// 所有的函数都可以使用call进行调用// 参数1：指定函数的this，如果不传，则this指向window// 其余参数：和函数的参数列表一模一样。// 说白了，call方法也可以和()一样，进行函数调用，call方法的第一个参数可以指定函数内部的this指向。fn.call(thisArg, arg1, arg2, arg2); 借用对象的方法 伪数组与数组 伪数组也叫类数组 伪数组其实就是一个对象，但是跟数组一样，伪数组也会有length属性，也有0,1,2,3等属性。 伪数组并没有数组的方法，不能使用push/pop等方法 伪数组可以跟数组一样进行遍历，通过下标操作。 常见的伪数组：arguments、document.getElementsByTagName的返回值、jQuery对象 1234567var arrayLike = &#123; 0:&quot;张三&quot;, 1:&quot;李四&quot;, 2:&quot;王五&quot;, length:3&#125;// 伪数组可以和数组一样进行遍历 伪数组借用数组的方法 1Array.prototype.push.call(arrLike, &quot;赵六&quot;); 将伪数组转换成真数组 1var arr = Array.prototype.slice.call(arrLike); apply方法apply()方法的作用和 call()方法类似，只有一个区别，就是apply()方法接受的是一个包含多个参数的数组。而call()方法接受的是若干个参数的列表 call和apply的使用场景： 如果参数比较少，使用call会更加简洁 如果参数存放在数组中，此时需要使用apply bind方法**bind()**方法创建一个新的函数, 可以绑定新的函数的this指向 1234// 语法：函数.bind(thisArg)// 返回值：新的函数// 参数：新函数的this指向，当绑定了新函数的this指向后，无论使用何种调用模式，this都不会改变。var newFn = fn.bind(window);","categories":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/tags/js/"}]},{"title":"对象属性查找&设置,hasOwnProperty,继承","slug":"js/08-对象属性查找-设置-hasOwnProperty-继承","date":"2020-10-09T02:47:49.000Z","updated":"2021-12-20T15:44:21.902Z","comments":true,"path":"2020/10/09/js/08-对象属性查找-设置-hasOwnProperty-继承/","link":"","permalink":"https://bloodthirsty2b.github.io/2020/10/09/js/08-%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E6%9F%A5%E6%89%BE-%E8%AE%BE%E7%BD%AE-hasOwnProperty-%E7%BB%A7%E6%89%BF/","excerpt":"对象属性查找&amp;设置属性查找原则","text":"对象属性查找&amp;设置属性查找原则 会先在自身上查找，如果没有 则根据__proto__对应的原型去找，如果没有 一直找到Object.prototyp，如果没有，那就找不到了。 属性设置原则只会修改对象自身的属性，如果自身没有这个属性，那么就会添加这个属性，并不会修改原型中的属性。 hasOwnProperty 方法语法：对象.hasOwnProperty(属性)作用：判断该属性是否是对象自身的属性，如果是返回true 使用场景举例：使用在for…in遍历对象中，来过滤出对象自身的属性 12345678910111213141516171819202122function Person(name)&#123; this.name = name; &#125; Person.prototype.color = &quot;lime&quot;; var p = new Person(&quot;xm&quot;); /*console.log(&quot;name&quot; in p); // true console.log(&quot;age&quot; in p); // false console.log(&quot;color&quot; in p); // true console.log(&quot;hasOwnProperty&quot; in p); // true*/ // 遍历p对象 for(var k in p)&#123; // 需求：只希望遍历到p对象自身的属性 // 解决方案： 使用hasOwnProperty方法来进行过滤，过滤出对象自身的属性 if(p.hasOwnProperty(k))&#123; // if成立，说明k变量所代表的属性是p对象自身的 console.log(k); &#125; // 不管属性是对象上的还是属于原型链上的，只要是可以被遍历到的属性，都会被遍历到 // console.log(k); &#125; 继承在JS中的继承概念非常简单：一个对象自己没有的属性和方法，另一个对象有，拿过来使用，就实现了继承。 继承的目的：让一个对象可以使用另一个对象的属性和方法。 JS常见的几种继承模式： 混入式继承（mixin） 把一个对象中的属性和方法拷贝到另一个对象中。 12345678var ff = &#123; name:&quot;hoho&quot;, extend: function(obj) &#123; for(var k in obj) &#123; this[k] = obj[k]; &#125; &#125;&#125; 原型链继承一个对象可以访问构造函数的原型中的属性和方法，那么如果想要让一个对象增加某些属性和方法， 只需要把这些属性和方法放到原型对象中即可。这样就实现了继承, 称之为原型链继承 直接给原型增加属性和方法 原型替换（注意：constructor） mixin+原型替换 Object.create 最初是由道格拉斯丶克罗克福德发布的一篇文章提出的，ECMAScript5新增了Object.create()方法来规范化了这种继承。 ES5中新增了一个方法Object.create(),方法会使用指定的原型对象及其属性去创建一个新的对象。 1234//参数：proto 一个对象//返回值：obj 新对象，新对象的原型就是protovar obj = Object.create(proto);console.log(obj);","categories":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/tags/js/"}]},{"title":"面向对象,对象构建,原型,原型链","slug":"js/07-面向对象-对象构建-原型-原型链","date":"2020-10-09T02:34:59.000Z","updated":"2021-12-20T15:44:31.282Z","comments":true,"path":"2020/10/09/js/07-面向对象-对象构建-原型-原型链/","link":"","permalink":"https://bloodthirsty2b.github.io/2020/10/09/js/07-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%AF%B9%E8%B1%A1%E6%9E%84%E5%BB%BA-%E5%8E%9F%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E9%93%BE/","excerpt":"面向对象编程基本概念对象到底是什么，可以从两次层次来理解。","text":"面向对象编程基本概念对象到底是什么，可以从两次层次来理解。 (1) 对象是具体事物的抽象。 一本书、一辆汽车、一个人都可以是对象，当实物被抽象成对象，实物之间的关系就变成了对象之间的关系，从而就可以模拟现实情况，针对对象进行编程。 (2) 对象是无序键值对的集合，其属性可以包含基本值、对象或者函数 每个对象都是基于一个引用类型创建的，这些类型可以是系统内置的原生类型，也可以是开发人员自定义的类型。 面向对象面向对象编程 —— Object Oriented Programming，简称 OOP ，是一种编程开发思想。 在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工，可以完成接受信息、处理数据、发出信息等任务。因此，面向对象编程具有灵活、代码可复用、高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统的过程式编程（procedural programming），更适合多人合作的大型软件项目。 面向对象与面向过程： 面向过程就是亲历亲为，事无巨细，有条不紊，面向过程是解决问题的一种思维方式，（执行者的角度） 关注点在于解决问题的过程（先xx，然后xx，在xx）； 面向对象就是找一个对象，让它去做这件事情（指挥者的角度） 关注点在找到能解决问题的对象上。 面向对象不是面向过程的替代，而是面向过程的封装 面向对象的特性： 封装性 将功能的具体实现，全部封装到对象的内部，外界使用对象时，只需要关注对象提供的方法如何使用，而不需要关心对象的内部具体实现，这就是封装。 继承性 在js中，继承的概念很简单，一个对象没有的一些属性和方法，另外一个对象有，拿过来用，就实现了继承。 注意：在其他语言里面，继承是类与类之间的关系，在js中，是对象与对象之间的关系。 [多态性] 多态是在强类型的语言中才有的。js是弱类型语言，所以JS不支持多态 创建对象的方式内置构造函数创建可以直接通过 new Object() 创建： 12345678//在js中，对象有动态特性，可以随时的给一个对象增加属性或者删除属性。var person = new Object()person.name = &#x27;Jack&#x27;person.age = 18person.sayName = function () &#123; console.log(this.name)&#125; 缺点：麻烦，每个属性都需要添加。 对象字面量创建1234567var person = &#123; name: &#x27;Jack&#x27;, age: 18, sayName: function () &#123; console.log(this.name) &#125;&#125; 缺点：如果要批量生成多个对象，代码很冗余 工厂函数可以写一个函数，解决代码重复问题： 123456789function createPerson (name, age) &#123; return &#123; name: name, age: age, sayName: function () &#123; console.log(this.name) &#125; &#125;&#125; 然后生成实例对象： 12var p1 = createPerson(&#x27;Jack&#x27;, 18)var p2 = createPerson(&#x27;Mike&#x27;, 18) 缺点：但却没有解决对象识别的问题，创建出来的对象都是Object类型的。 构造函数构造函数是一个函数，用于实例化对象，需要配合new操作符使用。 12345678910111213function Person (name, age) &#123; this.name = name this.age = age this.sayName = function () &#123; console.log(this.name) &#125;&#125;var p1 = new Person(&#x27;Jack&#x27;, 18)p1.sayName() // =&gt; Jackvar p2 = new Person(&#x27;Mike&#x27;, 23)p2.sayName() // =&gt; Mike 而要创建 Person 实例，则必须使用 new 操作符。以这种方式调用构造函数会经历以下 4 个步骤： 创建一个新对象 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象） 执行构造函数中的代码 返回新对象 构造函数需要配合new操作符使用才有意义，构造函数首字母都应该大写 构造函数的缺点使用构造函数带来的最大的好处就是创建对象更方便了，但是其本身也存在一个浪费内存的问题： 123456789101112function Person (name, age) &#123; this.name = name this.age = age this.type = &#x27;human&#x27; this.sayHello = function () &#123; console.log(&#x27;hello &#x27; + this.name) &#125;&#125;var p1 = new Person(&#x27;lpz&#x27;, 18)var p2 = new Person(&#x27;Jack&#x27;, 16)console.log(p1.sayHello === p2.sayHello) // =&gt; false 解决方案：将方法提取到外面 123456789101112131415function sayHello() &#123; console.log(&#x27;hello &#x27; + this.name)&#125;function Person (name, age) &#123; this.name = name this.age = age this.type = &#x27;human&#x27; this.sayHello = sayHello&#125;var p1 = new Person(&#x27;lpz&#x27;, 18)var p2 = new Person(&#x27;Jack&#x27;, 16)console.log(p1.sayHello === p2.sayHello) // =&gt; true 缺点：会暴漏很多的函数，容易造成全局变量污染。 原型原型基本概念Javascript 规定，每一个函数都有一个 prototype 属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。 这也就意味着，我们可以把所有对象实例需要共享的属性和方法直接定义在 prototype 对象上。 1234567891011121314151617function Person (name, age) &#123; this.name = name this.age = age&#125;console.log(Person.prototype)Person.prototype.type = &#x27;human&#x27;Person.prototype.sayName = function () &#123; console.log(this.name)&#125;var p1 = new Person(...)var p2 = new Person(...)console.log(p1.sayName === p2.sayName) // =&gt; true 这时所有实例的 type 属性和 sayName() 方法，其实都是同一个内存地址 构造函数、实例、原型三者之间的关系构造函数：构造函数就是一个函数，配合new可以新建对象。 实例：通过构造函数实例化出来的对象我们把它叫做构造函数的实例。一个构造函数可以有很多实例。 原型：每一个构造函数都有一个属性prototype，函数的prototype属性值就是原型。通过构造函数创建出来的实例能够直接使用原型上的属性和方法。 思考：内置对象中，有很多的方法，这些方法存在哪里？ __proto__任意一个对象，都会有__proto__属性，这个属性指向了构造函数的prototype属性，也就是原型对象。 获取原型对象： 通过构造函数.prototype可以获取 通过实例.__proto__可以获取（隐式原型） 它们指向了同一个对象构造函数.prototype === 实例.__proto__ 注意：__proto__是浏览器的一个隐藏（私有）属性，IE浏览器不支持，不要通过它来修改原型里的内容，如果要修改原型中的内容，使用构造函数.prototype去修改 constructor属性默认情况下，原型对象中只包含了一个属性：constructor，constructor属性指向了当前的构造函数。 原型链原型链概念任何一个对象，都有原型对象，原型对象本身又是一个对象，所以原型对象也有自己的原型对象，这样一环扣一环就形成了一个链式结构，我们把这个链式结构称为：原型链。 **Object.prototype是原型链的尽头，Object.prototype的原型是null **","categories":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/tags/js/"}]},{"title":"内置对象,数组方法,基本包装类型","slug":"js/06-内置对象,数组方法,基本包装类型","date":"2020-10-06T10:42:19.000Z","updated":"2021-12-20T15:44:41.992Z","comments":true,"path":"2020/10/06/js/06-内置对象,数组方法,基本包装类型/","link":"","permalink":"https://bloodthirsty2b.github.io/2020/10/06/js/06-%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1,%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95,%E5%9F%BA%E6%9C%AC%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B/","excerpt":"内置对象 JS内置对象就是指Javascript自带的一些对象，供开发者使用，这些对象提供了一些常用的的功能。 常见的内置对象有Math、String、Array、Date等","text":"内置对象 JS内置对象就是指Javascript自带的一些对象，供开发者使用，这些对象提供了一些常用的的功能。 常见的内置对象有Math、String、Array、Date等 Math对象 属性PI Math.PI 最大值&#x2F;最小值 12Math.max();Math.min(); 取整 123Math.ceil();// 天花板，向上取整Math.floor();// 地板，向下取整Math.round();// 四舍五入，如果是.5，则取更大的那个数 随机数 1Math.random();// 返回一个[0,1)之间的数，能取到0，取不到1 绝对值 1Math.abs();// 求绝对值 次幂和平方 12Math.pow(num, power);// 求num的power次方Math.sqrt(num);// 对num开平方 Date对象 Date对象用来处理日期和时间 创建一个日期对象 12345var date = new Date();// 使用构造函数创建一个当前时间的对象var date = new Date(&quot;2017-03-22&quot;);// 创建一个指定时间的日期对象var date = new Date(&quot;2017-03-22 00:52:34&quot;);// 创建一个指定时间的日期对象var date = new Date(2017, 2, 22, 0, 52, 34);var date = new Date(1523199394644);// 参数：毫秒值 日期格式化 123456date.toString();// 默认的日期格式date.toLocalString();// 本地风格的日期格式（兼容性处理）date.toDateString();date.toLocalDateString();date.toTimeString();date.toLocalTimeString(); 获取日期的指定部分 12345678getMilliseconds();// 获取毫秒值getSeconds();// 获取秒getMinutes();// 获取分钟getHours();// 获取小时getDay();// 获取星期，0-6 0：星期天getDate();// 获取日，即当月的第几天getMonth();// 返回月份，注意从0开始计算，0-11getFullYear();// 返回4位的年份 如 2016 时间戳 1var date = +new Date();// 1970年01月01日00时00分00秒起至现在的总毫秒数 Array对象 数组转换 123456//语法：array.join(separator)//作用：将数组的值拼接成字符串var arr = [1,2,3,4,5];arr.join();// 不传参数，默认按【,】进行拼接arr.join(&quot;-&quot;);// 按【-】进行拼接 数组的增删操作 1234array.push();// 从后面添加元素，返回新数组的lengtharray.pop();// 从数组的后面删除元素，返回删除的那个元素array.unshift();// 从数组的前面的添加元素，返回新数组的长度array.shift();// 从数组的最前面删除元素，返回删除的那个元素 数组的翻转与排序 12345678910array.reverse();// 翻转数组array.sort();// 数组的排序，默认按照字母顺序排序// sort方法可以传递一个函数作为参数，这个参数用来控制数组如何进行排序arr.sort(function(a, b)&#123; //如果返回值&gt;0,则交换位置 return a - b;&#125;);// 或者使用箭头函数arr.sort((a, b) =&gt; &#123;a - b&#125;); 数组的拼接与截取 12345678910// concat：数组合并，不会影响原来的数组，会返回一个新数组。var newArray = array.concat(array2);// slice: 数组切分，复制数组的一部分到一个新数组，并返回这个数组// 原来的数组不受影响，包含begin，不包含endvar newArray = array.slice(begin, end);// splice:删除数组或者增加数据元素// start:开始位置 deleteCount:删除的个数 items:替换的内容array.slice(start, deleteCount, [items]); 数组查找元素 12345// indexOf方法用来查找数组中某个元素第一次出现的位置，如果找不到，返回-1array.indexOf(search, [fromIndex]);// lastIndexOf()从后面开始查找数组中元素出现位置,如果找不到，返回-1array.lastIndexOf(search, [fromIndex]); 清空数组 123//1. array.splice(0,array.leng);// 删除数组中所有的元素//2．array.length = 0;// 直接修改数组的长度//3．array = [];// 将数组赋值为一个空数组，推荐 基本包装类型 简单数据类型是没有方法的。为了方便操作基本数据类型，JavaScript还提供了三个特殊的引用类型：String&#x2F;Number&#x2F;Boolean。 基本包装类型：把基本类型包装成复杂类型。 123456var str = “abc”;var result = str.indexOf(“a”);// 发生了三件事情// 1. 把简单类型转换成复杂类型：var s = new String(str);// 2. 调用包装类型的indexOf方法：var result = s.indexOf(“a”);// 3. 销毁刚刚创建的复杂类型 Number对象 Number对象是数字的包装类型，数字可以直接使用这些方法 12toFixed(2)// 保留2位小数toString();// 转换成字符串 Boolean对象 Boolean对象是布尔类型的包装类型。 1toString( );//转换成字符串 undefined和null没有包装类型，所以调用toString方法会报错 String对象 字符串可以看成是一个字符数组（伪数组）。因此字符串也有长度，也可以进行遍历。String对象很多方法的名字和和Array的一样。 查找指定字符串 12// indexOf:获取某个字符串第一次出现的位置，如果没有，返回-1// lastIndexOf:从后面开始查找第一次出现的位置。如果没有，返回-1 去除空白 1trim();// 去除字符串两边的空格，内部空格不会去除 大小写转换 12// toUpperCase：全部转换成大写字母// toLowerCase：全部转换成小写字母 字符串拼接与截取 123456// 字符串拼接// 可以用concat，用法与数组一样，但是字符串拼串一般用+// slice(start, end)：从start开始，end结束，并且取不到end。// substring(start, end)：从start开始，end结束，并且取不到end// substr(start, length)：从start开始，截取length个字符。 字符串切割 1234// split:将字符串分割成数组（很常用）// 功能和数组的join正好相反。var str = &quot;张三,李四,王五&quot;;var arr = str.split(&quot;,&quot;); 字符串替换 12replace(searchValue, replaceValue)// 参数：searchValue:需要替换的值 replaceValue:用来替换的值 注意：所有字符串的方法都是重新创建一个新的字符串，不会在原字符串上修改！","categories":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/tags/js/"}]},{"title":"对象,for in循环,值类型,引用类型","slug":"js/05-对象,for in循环,值类型,引用类型","date":"2020-10-05T05:33:01.000Z","updated":"2021-12-20T15:44:51.849Z","comments":true,"path":"2020/10/05/js/05-对象,for in循环,值类型,引用类型/","link":"","permalink":"https://bloodthirsty2b.github.io/2020/10/05/js/05-%E5%AF%B9%E8%B1%A1,for%20in%E5%BE%AA%E7%8E%AF,%E5%80%BC%E7%B1%BB%E5%9E%8B,%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/","excerpt":"对象对象的基本概念数组：是有序的元素集合 ，数组用于存放一组数据，比如一个班级所有人的名字，一个班级所有人的成绩。 函数：封装一段重复的代码，只要声明一次，就可以多次调用。 对象：是一组无序的键值对的集合。 事物的特征在对象中用属性来表示。 事物的行为在对象中用方法来表示。","text":"对象对象的基本概念数组：是有序的元素集合 ，数组用于存放一组数据，比如一个班级所有人的名字，一个班级所有人的成绩。 函数：封装一段重复的代码，只要声明一次，就可以多次调用。 对象：是一组无序的键值对的集合。 事物的特征在对象中用属性来表示。 事物的行为在对象中用方法来表示。 创建对象对象字面量123456789var o = &#123;&#125;;var o = &#123; name : &quot;zs&quot;, age : 18, sex : true, sayHi : function() &#123; console.log(this.name); &#125;&#125;; 通过Object构造函数创建1var hero = new Object();//创建一个空的对象 操作对象的属性设置对象的属性12345678910//语法 对象名.属性 = 值;var obj = new Object();obj.name = &quot;zs&quot;;obj.age = 18;obj.gender = &quot;男&quot;;//给对象设置添加一个方法obj.sayHi = function() &#123; console.log(&quot;大家好，我是&quot;+obj.name);&#125; 获取对象的属性1234567//语法： 对象名.属性console.log(obj.name);console.log(obj.age);console.log(obj.gender);//如果是方法，可以调用obj.sayHi(); 操作对象的属性.语法获取对象属性的语法：对象.属性 如果有这个属性，直接返回属性值 如果没有这个属性，返回undefined 设置对象的属性的语法：对象.属性 = 值 如果对象有这个属性，修改这个属性 如果对象没有这个属性，添加这个属性 []语法也叫关联数组的方式，其实说白了就是把对象当成数组看待。在中括号中可以是一个变量或者是字符串。 获取对象属性：对象[&#39;下标&#39;] （把对象的属性当成下标） 设置对象的属性：对象[&#39;下标&#39;] = &quot;值&quot;; 二者的区别：当属性名是一个字符串存储在变量中的时候，只能使用关联数组的方式。 遍历对象 通过for..in语法可以遍历一个对象 123for(var key in obj) &#123; console.log(key + &quot;==&quot; + obj[key]);&#125; 批量创建对象使用工厂函数创建对象优点：可以同时创建多个对象 缺点：创建出来的没有具体的类型，都是object类型的 构造函数 构造函数 ，是一种特殊的函数。主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。 构造函数首字母要大写（推荐做法）。 构造函数要和new一起使用才有意义。 构造函数的作用是用于实例化一个对象，即给对象添加属性和方法。 new在执行时会做四件事情 12341. new会创建一个新的空对象，类型是Teacher2. new 会让this指向这个新的对象3. 执行构造函数 目的：给这个新对象加属性和方法4. new会返回这个新对象 总结：创建对象的几种方式 12341. new Object()2. 对象字面量3. 工厂函数4. 自定义构造函数 值类型与引用类型值类型：简单类型，变量在存储的时候，存储的是值本身。 引用类型：复杂类型，变量在存储的时候，存储的是复杂数据的地址。 值类型与引用类型赋值特征12345678910111213141516// 值类型var num1 = 10;var num2 = num1;num2 = 99;console.log(num1);console.log(num2);// 引用类型var obj1 = &#123; name:&quot;zs&quot;, age:18&#125;var obj2 = obj1;obj2.name = &quot;ls&quot;;console.log(obj1.name);console.log(obj2.name); 值类型与引用类型参数传递123456789101112131415161718var num = 10;function fn(a) &#123; a = 99; console.log(a);&#125;fn(num);console.log(num);var obj = &#123; name:&quot;zs&quot;, age:18&#125;function fn(a) &#123; a.name = &quot;ls&quot;; console.log(a.name);&#125;fn(obj);console.log(obj.name); 123456789101112131415161718192021222324252627282930//测试1 : // a -&gt; xfunction fn(a, b) &#123; // 相当于 // var a = 10; // var b = 20; // 函数的参数 其实就是函数内部的局部变量 a = a + 1; b = b + 1; console.log(a); console.log(b);&#125;var x = 10;var y = 20;fn(x, y);console.log(x);console.log(y);//测试2 : var p = &#123; name:&quot;zs&quot;, age:18&#125;function fn(person) &#123; person.name = &#x27;ls&#x27;; console.log(person.name);&#125;fn(p);console.log(p.name); 结论：简单类型存储的是值本身，复杂类型存储的是地址，引入如果把第一个对象赋值给另一个变量，此时两个变量会指向同一个对象。","categories":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/tags/js/"}]},{"title":"函数,作用域,预解析,沙箱模式","slug":"js/04-函数,作用域,预解析,沙箱模式","date":"2020-10-04T05:26:34.000Z","updated":"2021-12-20T15:45:01.930Z","comments":true,"path":"2020/10/04/js/04-函数,作用域,预解析,沙箱模式/","link":"","permalink":"https://bloodthirsty2b.github.io/2020/10/04/js/04-%E5%87%BD%E6%95%B0,%E4%BD%9C%E7%94%A8%E5%9F%9F,%E9%A2%84%E8%A7%A3%E6%9E%90,%E6%B2%99%E7%AE%B1%E6%A8%A1%E5%BC%8F/","excerpt":"函数函数基础重复代码、冗余代码的缺点： 代码重复，可阅读性差 不易维护，如果代码逻辑改变了，所有地方的代码都要跟着改变，效率太低。","text":"函数函数基础重复代码、冗余代码的缺点： 代码重复，可阅读性差 不易维护，如果代码逻辑改变了，所有地方的代码都要跟着改变，效率太低。 函数的声明与调用声明函数的语法： 123function 函数名()&#123; //函数体&#125; 调用函数的语法： 1函数名(); 特点： 121. 函数声明的时候，函数体并不会执行，函数体只有在调用的时候才会执行，2. 可以调用多次 函数的参数 形参（形式参数）：在函数声明时，设置的参数。作用是占位置。 实参（实际参数）：在函数调用时，传入的参数。作用：函数调用时，会把实参的值赋值给形参，这样形参就有了值。 语法： 1234567//带参数的函数声明function 函数名(形参1, 形参2, 形参...)&#123; //函数体&#125;//带参数的函数调用函数名(实参1, 实参2, 实参3); 注意： 形参在声明时，值不固定，只有在调用的时候，形参的值才确定，形参的值会跟着函数调用时的实参不一样而不一样。 如何确定形参：在声明函数的时候，碰到不确定的值的时候，就可以定义成形参。 函数的返回值 当函数执行完的时候，我们期望函数给我一些反馈（比如计算的结果），这个时候可以让函数返回一些东西。也就是返回值。函数通过return返回一个返回值 返回值语法： 12345678//声明一个带返回值的函数function 函数名(形参1, 形参2, 形参...)&#123; //函数体 return 返回值;&#125;//可以通过变量来接收这个返回值var 变量 = 函数名(实参1, 实参2, 实参3); 注意： 函数的调用结果就是返回值，因此我们可以直接对函数调用结果进行操作。 函数三要素函数三要素包括：函数名、参数、返回值 123function getArea (r) &#123; return Math.PI * r * r;&#125; 函数高级函数调试断点调试： 1234F8：跳到下一个断点，如果后面没有断点了，那么代码直接执行完。F10：单步调试（跳过函数调用）F11：单步调试（进入函数调用）shift+F11：跳出函数调用 函数内部可以调用函数12345678910111213function fn1() &#123; console.log(&quot;fn1开始...&quot;); fn2(); console.log(&quot;fn1结束...&quot;);&#125;function fn2 () &#123; console.log(&quot;执行fn2的代码&quot;); console.log(&quot;执行fn2的代码&quot;); console.log(&quot;执行fn2的代码&quot;);&#125;//在函数1中调用了函数2fn1(); 全局变量与局部变量全局变量：在最函数外，script标签内声明的变量就是全局变量，全局变量在任何地方都能访问的到。 局部变量：在函数中声明的变量，就是局部变量，局部变量只有在当前函数体内能够访问。 隐式全局变量：没有使用var定义的变量也是全局变量。 1234567var num = 11;//全局变量function fn() &#123; var num1 = 22;//局部变量 num2 = 33;//隐式全局变量 console.log(num1);&#125;fn(); 变量的查找规则： 自己有就用自己的，自己没有就用外面的。 1234567var num = 11;function fn() &#123; var num = 22; console.log(num);//22&#125;fn();console.log(num);//11 预解析js执行代码分为两个过程： 预解析过程（变量与函数提升） 代码一行一行执行 预解析过程： 函数优先，先提升function，后提升var 遇到重名的var会被忽略。 遇到重名的function会被覆盖。 测试： 12345678910111213141516171819202122232425262728//1. var num = 10;fn1();function fn1() &#123; console.log(num); var num = 20;&#125;//2. var a = 18;fn2();function fn2() &#123; var b = 9; console.log(a); console.log(b);&#125;//3.fn3();console.log(c);console.log(b);console.log(a);function fn3() &#123; a = b = c = 9; console.log(a); console.log(b); console.log(c);&#125; 声明函数的两种方式函数声明(命名函数)： 123function 函数名()&#123; //函数体&#125; 函数表达式(匿名函数)： 123var 函数名 = function()&#123; //函数体&#125; 这两种函数声明的区别： 命名函数可以先调用，在声明，因为预解析 函数表达式必须先声明，再调用（在DOM中注册事件的时候用的非常的多） 匿名函数 匿名函数：没有名字的函数 匿名函数如何使用： 121. 将匿名函数赋值给一个变量，这样就可以通过变量进行调用2. 匿名函数自调用 自执行函数（匿名函数自调用）的作用：防止全局变量污染。","categories":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/tags/js/"}]},{"title":"数组,冒泡排序","slug":"js/03-数组-冒泡排序","date":"2020-10-03T03:11:01.000Z","updated":"2021-12-20T15:45:17.869Z","comments":true,"path":"2020/10/03/js/03-数组-冒泡排序/","link":"","permalink":"https://bloodthirsty2b.github.io/2020/10/03/js/03-%E6%95%B0%E7%BB%84-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/","excerpt":"数组 所谓数组，就是将多个元素（通常是同一类型）按一定顺序排列放到一个集合中，那么这个集合我们就称之为数组。 数组：多个元素的集合，这个集合有顺序，有长度。用途是存储大量的数据。","text":"数组 所谓数组，就是将多个元素（通常是同一类型）按一定顺序排列放到一个集合中，那么这个集合我们就称之为数组。 数组：多个元素的集合，这个集合有顺序，有长度。用途是存储大量的数据。 数组的构成 在javascript数组是一个有序的列表，可以在数组中存放任意的数据 创建数组，通过数组的构造函数可以创建一个数组 1var arr = new Array();//new表示新的 Array:表示数组 new Array表示创建一个数组。 通过数组的下标可以操作数组 12345//给数组设置值，数组中可以存放任意的值//数组名[下标] = &quot;值&quot; arr[0] = &quot;张三&quot;;//在下标0的地方存放张三arr[1] = 111; //在下标1的地方存放111arr[2] = true; //在下标2的地方存放true 123//获取数组中的值//数组名[下标]console.log(arr[0]);//打印下标0的值 创建数组通过构造函数创建数组 123var arr = new Array();//创建了一个空数组var arr = new Array(&quot;zs&quot;,&quot;ls&quot;,&quot;ww&quot;);//创建了一个数组，里面存放了3个字符串var arr = new Array(1,2,3,4);//创建了一个数组，里面存放了4个数字 通过数组字面量创建数组 123var arr1 = []; //创建一个空数组var arr2 = [1, 3, 4]; //创建一个包含3个数值的数组，多个数组项以逗号隔开var arr3 = [&quot;a&quot;, &quot;c&quot;]; // 创建一个包含2个字符串的数组 数组的下标与长度数组的下标：数组是有序的，数组中的每一个元素都对应了一个下标，下标是从0开始的 1var arr = [&quot;zs&quot;, &quot;ls&quot;, &quot;ww&quot;]; 数组的长度：跟字符串一样，数组有一个length属性，指数组中存放的元素的个数。 123var arr = [&quot;zs&quot;, &quot;ls&quot;, &quot;ww&quot;];arr.length;//这个数组的长度是3//空数组的长度是0 下标与长度的关系：最大的下标 &#x3D; length - 1 数组的赋值与取值数组的取值 123456//格式：数组名[下标]//功能：获取数组对应下标的那个值，如果下标不存在，则返回undefined。var arr = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];arr[0];//redarr[2];//bluearr[3];//这个数组的最大下标为2,因此返回undefined 数组的赋值 12345//格式：数组名[下标] = 值;//如果下标有对应的值，会把原来的值覆盖，如果下标不存在，会给数组新增一个元素。var arr = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];arr[0] = &quot;yellow&quot;;//把red替换成了yellowarr[3] = &quot;pink&quot;;//给数组新增加了一个pink的值 思考：如何给一个数组增加新的元素？ arr[arr.length] &#x3D; 值 arr.push(值) 数组的遍历 遍历：遍及所有，对数组的每一个元素都访问一次就叫遍历。 数组遍历的基本语法： 123for(var i =0; i &lt; arr.length; i++) &#123; //数组遍历的固定结构&#125; 冒泡排序1234567891011121314151617181920212223242526272829// 判断，如果一趟下来，一次交换都没有做，说明就已经排好序，就不需要继续比// var arr = [1, 2, 3, 4, 5, 6, 7];var arr = [65, 97, 76, 13, 27, 49, 58];var tang = 0;var ci = 0;for (var i = 0; i &lt; arr.length - 1; i++) &#123; tang++; var count = 0;// 记录交换的次数 // 思路： 两两比较，如果前面的大于后面的，交换位置 for (var j = 0; j &lt; arr.length - 1 - i; j++) &#123; ci++; if (arr[j] &gt; arr[j + 1]) &#123; count++; var temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; console.log(count); if (count == 0) &#123; // 说明，没有进行交换 break; &#125;&#125;console.log(arr);console.log(tang, ci);","categories":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/tags/js/"}]},{"title":"css2D、3D转换","slug":"css/mobile/01-css2D、3D转换","date":"2020-10-03T01:46:47.000Z","updated":"2021-12-20T15:56:32.926Z","comments":true,"path":"2020/10/03/css/mobile/01-css2D、3D转换/","link":"","permalink":"https://bloodthirsty2b.github.io/2020/10/03/css/mobile/01-css2D%E3%80%813D%E8%BD%AC%E6%8D%A2/","excerpt":"CSS3过渡过渡的属性 如果两个状态发生改变，没有过渡，效果是瞬间变化的 如果加上了过渡，那么这个过程就会有动画的效果。 整个状态变化的过程是由浏览器来完成的，我们只需要关注开始状态与结束状态即可。","text":"CSS3过渡过渡的属性 如果两个状态发生改变，没有过渡，效果是瞬间变化的 如果加上了过渡，那么这个过程就会有动画的效果。 整个状态变化的过程是由浏览器来完成的，我们只需要关注开始状态与结束状态即可。 12345678910111213/*transition-property：设置过渡属性/*也可以是width,height*/transition-property:all;/*transition-duration:设置过渡时间*/transition-duration:1s;/*transition-delay：设置过渡延时*/transition-delay:2s;/*transition-timing-function:设置过渡的速度*//*linear，ease，ease-in，ease-out，ease-in-out， steps(10)*/transition-timing-function:linear; 属性合写12/* 属性 时间 延时 速度 */transition: width 1s 3s linear; 过渡的注意点： 过渡必须要有两个状态的变化。 过渡可以写在A状态，也可以写在B状态，但是如果写在B状态，那么回来的时候，就没有过渡效果了。 2D转换 transform: 转换，是CSS3最具颠覆性的几个特性之一，既可以用于2D转换，也可以用于3D转换。 transform：2D转换，元素在平面上实现移动、旋转、缩放、斜切等操作 translate平移1234transform: translateX(100px);transform: translateY(100px);transform: translate(100px, 100px);transform: translate(50%, 50%); 注意： translate的值可以是px，也可以是百分比，如果是百分比，那么参照的是自身的宽高。 translate移动的元素并不会影响其他盒子，类似于相对定位。 scale缩放123transform: scaleX(0.5);/*让宽度变化*/transform: scaleY(0.5);/*让高度变化，注意不能写多个transform，不然会覆盖。*/transform: scale(0.5);/*让宽度和高度同时变化*/ 注意： scale接收的值是倍数，因此没有单位 scale可以是一个值，如果是一个值，不是说仅仅缩放宽度，高度也会等比例的缩放。 可以通过transition-origin设定旋转原点 rotate旋转12transform: rotate(360deg);//旋转360度transform: rotate(-360deg);//逆时针旋转360度 注意： 单位是deg，角度，不是px 正值顺时针转，负值逆时针转 可以通过transform-origin设定旋转原点 skew斜切(变形) skew在实际开发中，是用的最少的一个属性。一般来说，x和y只会倾斜其中的一个 1234/*在水平方向倾斜30deg*/transform: skewX(30deg);/*在垂直方向倾斜30deg*/transform: skewY(30deg); transform-origin转换原点 通过transform-origin可以设置转换的中心原点。 12transform-origin: center center;transform-origin: 40px 40px; 转换合写问题1transform:translateX(800px) scale(1.5) rotate(360deg) ; transform属性只能写一个，如果写了多个会覆盖 transform属性可以连写，但是要注意rotate会影响坐标轴的改变 如果多个场景下面有2D转换的情况下，需要复制前面已经存在的2D转换 3D转换 transform:不仅可以2D转换，还可以进行3D转换。 坐标轴 用X、Y、Z分别表示空间的3个维度，三条轴互相垂直。注意+Y是向下的。 perspective透视 电脑显示屏是一个2D的平面，因为我们看不出来旋转的方向，通过perspective属性，可以定义3D 元素距视图的距离，单位是px。 说白了，设置了perspective属性后，就有了近大远小的效果了，在视觉上，让我们能看出来透视的效果。 注意：当为元素定义 perspective 属性时，其子元素会获得透视效果，而不是元素本身。 1perspective：500px; rotate旋转1234transform: rotate(45deg);// 让元素在平面2D中旋转transform: rotateX(45deg);// 让元素沿着X轴转45度transform: rotateY(45deg);// 让元素沿着Y轴转45度transform: rotateZ(45deg);// 让元素沿着Z轴转45度 translate平移123456/*沿着X轴的正方向移动45px*/transform: translateX(45px);/*沿着Y轴的正方向移动45px*/transform: translateY(45px);/*沿着Y轴的正方向移动45px*/transform: translateZ(45px); transform-style transform-style 属性规定如何在 3D 空间中呈现被嵌套的元素。注意这个属性只能给父元素添加。 12flat:默认值，2d显示preserve-3d: 3d显示 transform-style: preserve-3d与perspective的区别 12345perspective透视：透视只是相当于设置了一个距离，辅助我们查看3D效果的工具，本质盒子最后显示时的变形，通常给需要透视的场景添加。transform-style: preserve-3d:给父盒子添加，让子元素保留3D的位置，说白了，只有设置了preserve-3d，这个元素才能被称之为3d元素。一个3d元素可以没有perspective，但是不能没有transform-style","categories":[{"name":"css","slug":"css","permalink":"https://bloodthirsty2b.github.io/categories/css/"},{"name":"mobile","slug":"css/mobile","permalink":"https://bloodthirsty2b.github.io/categories/css/mobile/"}],"tags":[{"name":"css","slug":"css","permalink":"https://bloodthirsty2b.github.io/tags/css/"},{"name":"mobile","slug":"mobile","permalink":"https://bloodthirsty2b.github.io/tags/mobile/"}]},{"title":"if,switch,三元,循环","slug":"js/02-if-switch-三元-循环","date":"2020-10-02T03:07:38.000Z","updated":"2021-12-20T15:45:28.529Z","comments":true,"path":"2020/10/02/js/02-if-switch-三元-循环/","link":"","permalink":"https://bloodthirsty2b.github.io/2020/10/02/js/02-if-switch-%E4%B8%89%E5%85%83-%E5%BE%AA%E7%8E%AF/","excerpt":"流程控制顺序结构 从上到下执行的代码就是顺序结构 程序默认就是由上到下一行一行的顺序执行的","text":"流程控制顺序结构 从上到下执行的代码就是顺序结构 程序默认就是由上到下一行一行的顺序执行的 123console.log(&quot;哈哈1&quot;);console.log(&quot;哈哈2&quot;);console.log(&quot;哈哈3&quot;); 分支结构分支结构，也叫选择结构，根据不同的情况，执行对应代码 循环结构循环结构：重复做一件事情 分支结构if语句 单独的if语句 123456789//语法if (条件)&#123; //只有当条件为 true 时执行的代码&#125;var age = 8;if(age &lt; 12) &#123; console.log(&quot;年龄小于12&quot;);&#125; if..else语句 123456789101112if (条件)&#123; //当条件为 true 时执行的代码&#125; else &#123; //当条件不为 true 时执行的代码&#125;var age = 8;if(age &lt; 12) &#123; console.log(&quot;年龄小于12&quot;);&#125;else &#123; console.log(&quot;年龄不小于12&quot;);&#125; if..else if..else语句 12345678910111213141516if (条件 1)&#123; //当条件 1 为 true 时执行的代码&#125; else if (条件 2) &#123; //当条件 2 为 true 时执行的代码&#125; else &#123; //当条件 1 和 条件 2 都不为 true 时执行的代码&#125;var age = 8;if(age &lt; 12) &#123; console.log(&quot;年龄小于12&quot;);&#125;else if(age &lt; 18)&#123; console.log(&quot;年龄不小于12且大于18&quot;);&#125;else &#123; console.log(&quot;年龄不小于18&quot;);&#125; 三元运算符12var 结果 = 判断条件 ? 值1 ： 值2 如果判断条件为true， 结果就是值1， 如果为false， 结果就是 值2 switch语句 if..else适用于范围的判断，switch..case适用于具体的值的判断 语法格式: 123456789101112131415switch (变量) &#123; case 值1: 语句1; break; case 值2: 语句2; break; case 值3: 语句3; break; … default: 默认语句; break;&#125; 注意： 12break可以省略，如果省略，代码会继续执行下一个caseswitch 语句在比较值时使用的是全等操作符, 因此不会发生类型转换（例如，字符串&#x27;10&#x27; 不等于数值 10） 使用场景 如果是范围性的判断，使用if..else会更加方便 如果是对具体值的判断，使用switch..case语句会更加方便，当然用if..else也是可以的。 如果if..else比较简单，可以使用三元运算符进行替代。 循环语句 在javascript中，循环语句有三种，while、do..while、for循环。 while循环 基本语法： 12345//当循环条件为true时，执行循环体，//当循环条件为false时，结束循环。while(循环条件)&#123; //循环体：需要循环执行的语句&#125; 代码示例： 123456789//计算1-100之间所有数的和//1. 初始化变量var i = 1;var sum = 0;while(i &lt;= 100)&#123;//判断条件 sum += i;//循环体 i++;//自增，修改循环条件（不能省略）&#125;console.log(sum); do..while循环 do..while循环和while循环非常像，二者经常可以相互替代，但是do..while的特点是不管条件成不成立，都会执行一次。 基础语法： 123do&#123; //循环体;&#125;while(循环条件); 代码示例： 1234567//初始化变量var i = 1;var sum = 0;do&#123; sum += i;//循环体 i++;//自增&#125;while(i &lt;= 100);//循环条件 断点调试 断点调试是指自己在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。 调试步骤： 1浏览器中按F12--&gt;sources--&gt;找到需要调试的文件--&gt;在程序的某一行设置断点 调试中的相关操作： 123Watch:监视，通过watch可以监视变量的值的变化，非常的常用。F10:程序单步执行，让程序一行一行的执行，这个时候，观察watch中变量的值的变化。F8：跳到下一个断点处，如果后面没有断点了，则程序执行结束。 for循环 for循环语法： 12345//1. for循环使用分号分隔//2. for循环有2个分号，两个分号不能少for(初始化语句;判断语句;自增语句)&#123; //循环体&#125; 执行顺序：1243 —- 243 —–243(直到循环条件变成false) 初始化语句 判断语句 自增或者自减 循环体 for循环代码示例： 12345//计算1-100之间所有数的和var sum = 0;for(var i = 1; i &lt;= 100; i++)&#123; sum += i;&#125; break和continue break:立即跳出整个循环，即循环结束，开始执行循环后面的内容（直接跳到大括号） continue:立即跳出当前循环，继续下一次循环（跳到i++的地方） 总结 循环有很多种，但是用得最多的是for循环 当不明确循环次数的时候，可以使用while循环 当无论如何都要执行一次代码的时候，可以使用do..while循环。 循环可以相互替代。","categories":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/tags/js/"}]},{"title":"变量,数据类型,运算符,运算符优先级,类型转换","slug":"js/01-变量,数据类型,运算符,运算符优先级,类型转换","date":"2020-10-01T03:13:22.000Z","updated":"2021-12-20T15:45:39.507Z","comments":true,"path":"2020/10/01/js/01-变量,数据类型,运算符,运算符优先级,类型转换/","link":"","permalink":"https://bloodthirsty2b.github.io/2020/10/01/js/01-%E5%8F%98%E9%87%8F,%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B,%E8%BF%90%E7%AE%97%E7%AC%A6,%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7,%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","excerpt":"JavaScript介绍javascript的组成 ECMAScript - JavaScript的核心，描述了语言的基本语法和数据类型，ECMAScript是一套标准，定义了一种语言的标准与具体实现无关 DOM：一套操作网页元素的API BOM：一套操作浏览器功能的API","text":"JavaScript介绍javascript的组成 ECMAScript - JavaScript的核心，描述了语言的基本语法和数据类型，ECMAScript是一套标准，定义了一种语言的标准与具体实现无关 DOM：一套操作网页元素的API BOM：一套操作浏览器功能的API JavaScript书写位置JavaScript的代码书写分为两种： 写在script标签中 123&lt;script&gt; alert(&#x27;Hello World!&#x27;);&lt;/script&gt; 引入一个js文件 1&lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt; 注意：如果script标签指定了src属性，表示引入一个外部的文件，内部写入的js代码会被忽略 注释 注释代码不会被执行，仅仅起到一个提示的作用。注释可以对复杂的代码进行解释，方便后期的维护和开发。 单行注释 12// 这是单行注释， 单行注释只能写一行代码// 快捷键： ctrl + / 多行注释 12345/* 这是多行注释，在多行注释中可以 换行 快捷键 alt + shift + a/* 输出语句 警告框alert 12//alert会弹出一个警告框alert(&quot;hello world&quot;); 确认框confirm 12//confirm弹出一个确定框confirm(&quot;你爱我吗？&quot;); 输入框prompt 12//prompt:弹出一个输入框，可以输入值prompt(&quot;请输入你的银行卡密码&quot;); 在网页中输入内容 123//可以识别标签document.write(&quot;hello world&quot;);document.write(&quot;&lt;h1&gt;hello world&lt;/h1&gt;&quot;); 在控制台输入 12//F12打开控制台，在console中可以看到打印的信息console.log(&quot;hello word&quot;); 总结：alert、comfirm、prompt三个用户体验太差，一般不用。console.log经常用来打印日志，调试的时候非常有用。 变量使用变量 var声明变量 1var age; 变量的赋值 12var age;age = 18; 同时声明并且赋值 1var age = 18; 同时声明多个变量并赋值 1var age = 10, name = &#x27;zs&#x27;; 不声明变量，直接赋值(不会报错，但是不推荐) 12age = 18;console.log(age); 不声明变量，也不赋值变量，直接使用（会报错） 1console.log(age); 结论： 变量应该声明之后再使用。 javascript代码一旦报错了，后面的代码就不再执行了。 变量的命名规则和规范 规则 - 必须遵守的，不遵守会报错 由字母、数字、下划线、$符号组成，不能以数字开头 不能是关键字和保留字，(不用死记，慢慢就见得多了) 区分大小写 规范 - 建议遵守的，不遵守不会报错 变量名必须有意义 遵守驼峰命名法。首字母小写，后面单词的首字母需要大写。例如：myName、userPassword 关键字： 保留字: 数据类型 javascript中数据类型分为简单数据类型和复杂数据类型，这里是简单数据类型 number、string、boolean、undefined、null number-数字类型 数字： 11 255 333 1024 整数 - 进制在javascript中表示一个数字，除了有我们常用的十进制11, 22,33等，还可以使用八进制、十六进制表示等。 十进制 1234//我们最常用的进制，进行算术运算的时候，八进制和十六进制最终都要转换成十进制//逢10进1var num = 9;var num = 29; 八进制 123// 0开头的数字， 逢8进1var num1 = 07;var num2 = 012; 十六进制 123// 0x开头的数字，逢16进1， 数字范围1-9A-Fvar num = 0xA;var num = 0x12; tips:计算机只认识二进制，所以所有的代码最终都会转换成二进制数据。 浮点数 浮点数就是小数,，比如0.1 浮点数 1var num = 0.1; 科学计数法 123//当一次数字很大的时候，可以用科学计数法来表示var num = 5e5; //5乘以10的5次方var num = 3e-3;//3乘以10的-3次方 浮点数精度丢失问题 1234//在进行浮点数运算的时候，可能会出现精度丢失的问题0.1 + 0.2 = 0.30000000000000004;0.2 + 0.2 = 0.4;//尽量少用浮点数进行运算，不要让浮点数进行比较。 数值范围1234最小的小数值：Number.MIN_VALUE，这个值为： 5e-324最大值：Number.MAX_VALUE，这个值为： 1.7976931348623157e+308无穷大：Infinity无穷小：-Infinity 字符串类型字符串类型，使用双引号 &quot; 或者 &#39; 包裹起来的字符 123//双引号和单引号必须成对出现var str = &#x27;hello world&#x27;;var str = &quot;hello world&quot;; 字符串长度每一个字符串都有一个length属性，可以获取到字符串中字符串的个数 12var str = &quot;zdgfjgk&quot;;console.log(str.length); 转义字符 字符串拼接 +号具有字符串拼接功能，它能将两个字符串拼接成一个字符串。 +号同时具有算术加法的功能，它能将两个数字进行相加 如果+号两边有一个是字符串，那么就是拼串的功能，如果都是数字，那么就是算数的功能。 1234567891011var a = &quot;hello&quot;;var b = &quot;itcast&quot;;console.log(a + b);//字符串拼接功能var a = &quot;100&quot;;var b = 100;console.log(a + b);//字符串拼接功能var a = 100;var b = 100;console.log(a + b);//加法功能 布尔类型 布尔类型：true 和 false 123//布尔类型只有两个值true:表示真false:表示假 注意：区分大小写，不要写成True或者是False undefined和null undefined表示一个没有赋值的变量 null表示一个空的对象 字面量与变量 字面量，也叫直接量，值是固定不变的，浏览器能够直接识别的量，比如11, &quot;abc&quot;, true, false, undefined, null等都是字面量，可以直接使用。 变量：浏览器必须要经过声明之后，才认识变量，如果没有声明，直接使用变量是会报错的。 操作符算术运算符 赋值运算符 赋值运算符有： &#x3D; , +&#x3D;, -&#x3D;, *&#x3D;, &#x2F;&#x3D;, %&#x3D; 123456var num = 10;num += 1; //num = num + 1;num -= 1; //num = num - 1;num *= 2; //num = num * 2;num /= 2; //num = num / 2;num % = 2; //num = num % 2; 一元运算符一元运算符：只有一个操作数的运算符 二元运算符：有两个操作数的运算符，比如算术运算符、赋值运算符 自增运算符：++ 先自增： ++i 后自增：i++ 1234567//先自增：var num = 1;console.log(++num); //先自增：表示先加1，后返回值//后自增：var num = 1;console.log(num++);// 后自增：表示先返回值，后+1 自减运算符：– 先自减：--i 后自减：i-- 逻辑运算符 &amp;&amp;：与运算符，表示且，只有当两个操作数都为true的时候，结果才是true ||：或运算符，表示或，只要有其中一个操作数是true,结果就是true !：非运算符，取反 123456789101112console.log( true &amp;&amp; true );console.log( false &amp;&amp; true );console.log( true &amp;&amp; false );console.log( false &amp;&amp; false );console.log( true || true );console.log( false || true );console.log( true || false );console.log( false || false );console.log(!true);console.log(!false); 比较运算符 比较运算符也叫关系运算符， &lt; &gt; &gt;&#x3D; &lt;&#x3D; &#x3D;&#x3D; !&#x3D; &#x3D;&#x3D;&#x3D; !&#x3D;&#x3D;， 关系运算符的结果是布尔类型 1234567891011var a = 5;var b = 6;console.log(a &gt; b);//大于console.log(a &lt; b);//小于console.log(a &gt;= b);//大于等于console.log(a &lt;= b);//小于等于console.log(a == b); //相等，只比较值，不比较类型console.log(a === b); //全等，比较类型和值console.log(a != b); // 不等， 只判断值，不判断类型console.log(a !== b); // 不全等 判断值，且判断类型 运算符优先级 ()的优先级最高 一元运算符(++, –, !) 算术运算符（先*/%, 后+-） 关系运算符 (先&gt; &lt; &gt;= &lt;=， 后== === != !==) 逻辑运算符（先&amp;&amp;后||） 不确定的时候，使用()增加优先级 类型转换查看变量的类型typeof关键字可以查看数据的类型 1234var num = 11;console.log(typeof num);num = &quot;abc&quot;;console.log(typeof num); 在控制台可以根据颜色来判断数据类型 转换成数字类型 Number() 12console.log(Number(&#x27;55&#x27;));Number()可以把任意值转换成数值类型，但是如果字符串中有不是数字的字符，返回NaN parseInt() 12var num1 = parseInt(&quot;12.3abc&quot;); // 返回12，如果第一个字符是数字会解析直到遇到非数字结束var num2 = parseInt(&quot;abc123&quot;); // 返回NaN，如果第一个字符不是数字或者正负符号就返回NaN parseFloat() 1234parseFloat()把字符串转换成浮点数parseFloat()和parseInt()非常相似，不同之处在与 parseFloat会解析第一个. 遇到第二个.或者非数字结束 如果解析的内容里只有整数，解析成整数 算术运算 1234var str = &#x27;500&#x27;;console.log(+str); // 取正console.log(-str); // 取负console.log(str - 0); NaN NaN: not a number, 表示一个number类型的非数字 在js中，NaN用来表示一个非数字的特殊值，当发现无法进行运算时，js不会报错，而是会返回一个NaN NaN的注意事项： NaN的类型是number类型的，表示一个非数字 NaN不等于任何值，包括NaN本身 通过isNaN()可以判断一个number类型的值, 是否是一个数字，返回false的时候，表示是一个数字。 12var num = 5;console.log(isNaN(5)); 转换成字符串 toString() 123var num = 5;console.log(num.toString());// 把数值5变成字符串5//将来所有的数据都会有toString()方法，除了null和undefined String() 123var num = 5;num = String(num);console.log(num); 拼串，使用起来最方便 123var num = 5;num = num + &quot;&quot;;console.log(num); 转换成布尔类型 所有的值都可以转换成布尔类型 其中，&quot;&quot;，NaN，undefined，null，0，false这几个值会转换成false，其他值都会转换成true Boolean() 12console.log(Boolean(1));console.log(Boolean(0)); !! 12var a = &quot;abc&quot;;console.log(!!a);","categories":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/tags/js/"}]}],"categories":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/categories/js/"},{"name":"html","slug":"html","permalink":"https://bloodthirsty2b.github.io/categories/html/"},{"name":"RegExp","slug":"js/RegExp","permalink":"https://bloodthirsty2b.github.io/categories/js/RegExp/"},{"name":"React","slug":"React","permalink":"https://bloodthirsty2b.github.io/categories/React/"},{"name":"webpack","slug":"webpack","permalink":"https://bloodthirsty2b.github.io/categories/webpack/"},{"name":"canvas","slug":"canvas","permalink":"https://bloodthirsty2b.github.io/categories/canvas/"},{"name":"miniProgram","slug":"miniProgram","permalink":"https://bloodthirsty2b.github.io/categories/miniProgram/"},{"name":"css","slug":"css","permalink":"https://bloodthirsty2b.github.io/categories/css/"},{"name":"JQuery","slug":"js/JQuery","permalink":"https://bloodthirsty2b.github.io/categories/js/JQuery/"},{"name":"Vue","slug":"Vue","permalink":"https://bloodthirsty2b.github.io/categories/Vue/"},{"name":"Vuex","slug":"Vue/Vuex","permalink":"https://bloodthirsty2b.github.io/categories/Vue/Vuex/"},{"name":"Element-ui","slug":"Vue/Element-ui","permalink":"https://bloodthirsty2b.github.io/categories/Vue/Element-ui/"},{"name":"plugin","slug":"plugin","permalink":"https://bloodthirsty2b.github.io/categories/plugin/"},{"name":"test","slug":"test","permalink":"https://bloodthirsty2b.github.io/categories/test/"},{"name":"Git","slug":"test/Git","permalink":"https://bloodthirsty2b.github.io/categories/test/Git/"},{"name":"nodejs","slug":"js/nodejs","permalink":"https://bloodthirsty2b.github.io/categories/js/nodejs/"},{"name":"es6","slug":"js/es6","permalink":"https://bloodthirsty2b.github.io/categories/js/es6/"},{"name":"Ajax","slug":"js/Ajax","permalink":"https://bloodthirsty2b.github.io/categories/js/Ajax/"},{"name":"webAPI","slug":"js/webAPI","permalink":"https://bloodthirsty2b.github.io/categories/js/webAPI/"},{"name":"mobile","slug":"css/mobile","permalink":"https://bloodthirsty2b.github.io/categories/css/mobile/"}],"tags":[{"name":"js","slug":"js","permalink":"https://bloodthirsty2b.github.io/tags/js/"},{"name":"html","slug":"html","permalink":"https://bloodthirsty2b.github.io/tags/html/"},{"name":"RegExp","slug":"RegExp","permalink":"https://bloodthirsty2b.github.io/tags/RegExp/"},{"name":"React","slug":"React","permalink":"https://bloodthirsty2b.github.io/tags/React/"},{"name":"webpack","slug":"webpack","permalink":"https://bloodthirsty2b.github.io/tags/webpack/"},{"name":"canvas","slug":"canvas","permalink":"https://bloodthirsty2b.github.io/tags/canvas/"},{"name":"miniProgram","slug":"miniProgram","permalink":"https://bloodthirsty2b.github.io/tags/miniProgram/"},{"name":"css","slug":"css","permalink":"https://bloodthirsty2b.github.io/tags/css/"},{"name":"JQuery","slug":"JQuery","permalink":"https://bloodthirsty2b.github.io/tags/JQuery/"},{"name":"Vue","slug":"Vue","permalink":"https://bloodthirsty2b.github.io/tags/Vue/"},{"name":"Vuex","slug":"Vuex","permalink":"https://bloodthirsty2b.github.io/tags/Vuex/"},{"name":"Element-ui","slug":"Element-ui","permalink":"https://bloodthirsty2b.github.io/tags/Element-ui/"},{"name":"plugin","slug":"plugin","permalink":"https://bloodthirsty2b.github.io/tags/plugin/"},{"name":"test","slug":"test","permalink":"https://bloodthirsty2b.github.io/tags/test/"},{"name":"Git","slug":"Git","permalink":"https://bloodthirsty2b.github.io/tags/Git/"},{"name":"nodejs","slug":"nodejs","permalink":"https://bloodthirsty2b.github.io/tags/nodejs/"},{"name":"es6","slug":"es6","permalink":"https://bloodthirsty2b.github.io/tags/es6/"},{"name":"Ajax","slug":"Ajax","permalink":"https://bloodthirsty2b.github.io/tags/Ajax/"},{"name":"webAPI","slug":"webAPI","permalink":"https://bloodthirsty2b.github.io/tags/webAPI/"},{"name":"mobile","slug":"mobile","permalink":"https://bloodthirsty2b.github.io/tags/mobile/"}]}